<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jpa on Polarlights</title>
    <link>https://polarlights.github.io/tags/jpa/</link>
    <description>Recent content in jpa on Polarlights</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 06 Dec 2018 18:08:59 +0800</lastBuildDate>
    
	<atom:link href="https://polarlights.github.io/tags/jpa/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>hibernate-best-practice</title>
      <link>https://polarlights.github.io/post/hibernate-best-practice/hibernate-best-practice/</link>
      <pubDate>Thu, 06 Dec 2018 18:08:59 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/hibernate-best-practice/hibernate-best-practice/</guid>
      <description>1. 设置数据库存储时间的时区如果某个应用考虑到国际化，服务会部署在多个时区，或者用户会和不同时区的人打交道；存储的时间建议使用 UTC 时间。比如美国有夏令时，会根据季节调整时间。使用 UTC 时间会更好地适应变化。 Hibernate 在时间的存取的时候，会调用PreparedStatement.setTimestamp()/ResultSet.getTimestamp，默认情况下，会 fall back 为 JVM 所在的时区。为了能够存储 UTC 时间，将 JDBC 的链</description>
    </item>
    
    <item>
      <title>JPA stream query with java8</title>
      <link>https://polarlights.github.io/post/jpa-stream-query/jpa-stream-query/</link>
      <pubDate>Sun, 11 Nov 2018 16:00:00 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/jpa-stream-query/jpa-stream-query/</guid>
      <description>最近有小伙伴在做批量导出数据的功能，原来是这样写的： image::15417517310823.jpg[] 后来在看其他代码的时候，有个类似功能，突然意识到那个代码在数据量很大的时候，会存在性能问题（最坏会OOM，导致不可用)。后面在交流过程中，小伙伴突然想到上面那个代码也会有类似问题。 在 Rails 的 ActiveRecord 中有find_in_batches功能，它会生成select ... from XX where id &amp;gt; ? limit N offset M类似的 SQL，实现批量查询。 在 Java 中，首先想到的是使用 Pagable 翻页查找，但是这个不是</description>
    </item>
    
  </channel>
</rss>