<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bean validation tutorial]]></title>
    <url>%2F2019%2F08%2F03%2Fbean-validation-tutorial%2F</url>
    <content type="text"><![CDATA[Preface在开发 Web 接口的时候，客户端给到的输入参数往往是不可控，亦不可信的；需要在 server 端做一些校验，以使处理数据符合业务预期；除了web 接口之外，我们写的方法、DAO 对象都有类似的需求。也就是校验的需求贯穿服务的各个层。 简单粗暴一点的可以在每一层这样写：123456if (param.getName() == null) &#123; throw BadRequestException(&quot;name can not be null&quot;);&#125;if (param.getAge() &lt; 1) &#123; throw BadRequestException(&quot;age can not less than 1&quot;);&#125; 如果遇到错误，我想最后统一抛出，用户可以一次知道哪些输入是有问题。那么我们可以这样写: 12345678910111213List&lt;String&gt; errorMessages = new ArraysList&lt;&gt;();if (params.getName() == null) &#123; errorMessages.add(&quot;name can not be null&quot;);&#125;if (param.getAge() &lt; 1) &#123; errorMessages.add(&quot;age can not less than 1&quot;);&#125;if (errorMessages.size() &gt; 0) &#123; ...&#125; 这样写会有什么样的问题呢？ ① 通用性不够② 重复代码很多 那么如何解决这个问题呢？ Java 提供了 Bean Validation 的概念，先后经过了 [JSR303, 2009]、[JSR 349, 2013], [JSR 380, 2017] 三个标准。 Bean Validation 的目的是解决程序从表现层到持久层的对象的重复校验逻辑。它使用注解、XML 对对象的属性进行约束。 除了默认提供的校验注解，Bean Validation 还提供了自定义注解来实现自己的校验逻辑、本地化违反约定信息等能力。 下文我们主要以 Bean Validation 2.0为例进行讲解。 使用Bean Validation 2.0的官方认证实现为Hibernate Validator。spring boot 项目只要引入了 spring-boot-starter-web 依赖就自动引入了相关依赖。 它需要的依赖有: javax.validation:validation-api org.hibernate.validator:hibernate-validator 前者提供抽象描述和抽象接口，后者提供具体实现。 常用约束 注解 适用对象类型 说明 null 是否被视为有效 AssertFalse boolean 元素必须为 false； Y AssertTrue boolean 元素必须为 true； Y DecimalMax BigDecimal, BigInteger, CharSequence, byte/short/int/long 及包装类型 元素必须小于等于给定值； Y DecimalMin BigDecimal, BigInteger, CharSequence, byte/short/int/long 及包装类型 元素必须大于等于给定值； Y Digits BigDecimal, BigInteger, CharSequence, byte/short/int/long 及包装类型 元素的整数与分数部分分别约束最大值； Y Email String 字符串必须是有效的邮件地址 N Future Date/Calendar/Instant/LocalDate/LocalTime/LocalDateTime/MonthDay/OffsetDateTime/OffsetTime/Year/YearMonth/ZonedDateTime 元素必须大于当前时间 Y FutureOrPresent Date/Calendar/Instant/LocalDate/LocalTime/LocalDateTime/MonthDay/OffsetDateTime/OffsetTime/Year/YearMonth/ZonedDateTime 元素必须大于等于当前时间 Y Max BigDecimal/BigInteger/byte/short/int/long 元素小于等于给定值 Y Min BigDecimal/BigInteger/byte/short/int/long 元素大于等于给定值 Y NotEmpty String/Collection/Map/Array 元素不能为 null 或者为空 N NotNull any 元素不能为 null N Post Date/Calendar/Instant/LocalDate/LocalTime/LocalDateTime/MonthDay/OffsetDateTime/OffsetTime/Year/YearMonth/ZonedDateTime 元素必须小于当前时间 Y Pattern String 字符串必须符合给定的正则 Y Size String/Collection/Map/Array 元素的长度/元素数量在给定范围内 Y 简单使用在 Controller 参数前添加 @Valid 注解，即:12345678910111213// modelpublic class UserRequest &#123; @NotEmpty private String name; @Range(min=1, max=125) private int age; @Valid private Address address;&#125;# controller@PostMapping("/users")public String createUser(@Valid @RequestBody UserRequest user); 需要注意的是：① 如果对象嵌套了其它对象(即需要级联校验)，需要在里面使用 @Valid 注解 ② 如果 controller 使用继承实现，那么要符合里氏替换原则原则（即子类的约束被强化或者弱化; 父方法的约束会自然被子类方法继承)。 另外 Spring 默认不提供方法级别的校验，如果需要校验，需要在类级别添加@Validated注解。 如果想全局处理 Bean Validation 异常，则可以再 ErrorAdvice 处理类中，添加对MethodArgumentNotValidException异常处理即可。如果添加了对方法参数的校验，还需要再 ErrroAdvice 中添加 ConstraintViolationException异常类的处理。 更多用法自定义约束如果默认的校验不能满足业务场景的需要，我们可以自定义约束。 每个约束注解的定义包括但不限于： 注解的校验类 [非必需] 校验不通过的 message 字符串 [必需] 注解所属的分组(Group) [必需] 注解所属的负载(Payload) [必需] 假如说现在有一个场景，某个字符串属性，只接受特定的几个值.1234567891011121314151617181920212223242526272829303132333435// 定义约束注解@Documented@Constraint(validatedBy = &#123;StringRangeValidator.class&#125;)@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE&#125;)@Retention(RUNTIME)public @interface StringRange &#123; String[] values() default &#123;&#125;; String message() default "属性值只能在指定的范围内"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125;// 定义校验实现类public class StringRangeValidator implements ConstraintValidator&lt;StringRange, String&gt; &#123; Set&lt;String&gt; valueSets = new HashSet&lt;&gt;(); @Override public void initialize(StringRange constraintAnnotation) &#123; for (String str : constraintAnnotation.values()) &#123; if (Objects.nonNull(str)) &#123; valueSets.add(str); &#125; &#125; &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; return valueSets.contains(value); &#125;&#125; 这样我们就很方便地实现了一个自定义的校验类。 分组校验分组校验主要用于同一个 Bean 对象的特定属性在不同场景下约束行为不同服务的。比如一个 User 对象，创建与更新的对象大部分是相同的，不同的是更新时 ID 不为空，而创建时必须为空。那么我们可以分别定义两个组(组名一般是接口; 默认分组是 javax.validation.groups.Default.class)： 12345678public interface CreatedGroup &#123;&#125;public interface UpdatedGroup &#123;&#125;// User.java@NotNull(group = UpdatedGroup.class)@Null(group = CreatedGroup.class)private Long id; 在启用校验的地方:12@RequestMapping("/users")public User createUser(@Validated(CreatedGroup.class) CreateUserRequest createUserRequest) &#123; ... &#125; 其它我们没有处理的有 Payload(负载)的使用，它是附加在 Group 之外的一种元数据描述，一种用途是：描述校验的错误严重级别。因为使用较少，我们不多描述。有兴趣的朋友可以读一下Bean Validation 的 spec 文档。 如果我们在没有 Spring 的条件下想使用 Bean Validation 怎么办？123Validator validator = Validation.buildDefaultValidatorFactory().getValidator();validator.validate(instantce, constraintGroups); 关联 repo: https://github.com/polarlights/bean_validation_tutorial 参考资料 使用Bean Validation实现数据校验 JSR 303 - Bean Validation 介绍及最佳实践 Bean validation specification Bean validation payload example https://www.logicbig.com/tutorials/java-ee-tutorial/bean-validation.html Hibernate Validator Documentation]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>bean validation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Feign Code Analysis and Best Practice]]></title>
    <url>%2F2019%2F07%2F20%2Ffeign-code-analysis-and-best-practise%2F</url>
    <content type="text"><![CDATA[在日常开发过程中，程序员需要调用第三方或者第二方的接口。有的第三方或者第二方提供了供其他人使用的 client libarary, 还有一部分只是提供了接口声明和返回，需要调用者自己去根据接口约定去发起请求。在spring 程序中，Feign^footnote_feign是我们经常用到的一个库。本文主要讲解 Feign 的代码解析和在日常工作中的最佳实践。 什么是 FeignFeign |/feɪn/| 的意思是假装。它假装了什么呢？顾名思义，它让我们调用 HTTP 请求像调用本地方法一样。 它简化了HTTP 请求的调用，是一种声明式的 Web 服务客户端，灵感来源于Retrofit、JAXRS-2.0和WebSocket。 Feign 的概念：在讲解 Feign 概念之前，我们先不去关心 Feign。假想一下，如果让我们去设计一个这样的库，我们需要哪些因素。 请求应答的基本要素有： 请求的 URL：知道请求发往哪里。 请求的 method： 知道请求使用什么 Http Method。 请求的参数: server 需要客户端传哪些参数。 请求的应答：server 的应答如何处理。应答又分为两种：成功请求应答和失败请求应答。 有了以上的要素，就可以基本确定一个请求的所有信息了。但是，这还不够： 声明了接口，请求还是得需要代码处理才能发出去。代码处理的第一步：它需要知道我们的声明和意图，即能够解析我们的声明。所以一个约定的解析器(Contract)是必需的。 代码懂了我们的意图，还需要行动，将请求发出去。请求的发出者，相对于服务提供者就是一个 Client。由 Client 具体执行，按照我们的意图，把请求发出去。 有了上面的信息，一个完整的请求就够了。但是，这还不够完美？ 加入我希望一个请求在 1S 内就能收到反馈，而实际服务提供者，需要 3S 钟才能有应答。这时候该如何声明我的期望，如何处理请求超时？ 我们作为客户端将请求发出去，必须要考虑我们的应用希望客户端多久可以返回。相信大家都不相等太久，所以我们要声明我们对请求的时间去期待，即超时时间。如果我们设置了超时时间，就需要有能力定制万一超时了怎么办: 要么重试或者直接报错返回。 如果服务需要客户端带上 token，或者作为服务中的一环，我希望可以追踪这次请求，怎么办？ 有时候服务端的请求需要我们带上 token，或者我们想在请求的头中加上用于追踪请求的 Http Header，要是有个请求拦截器就好了。 到这里，由我们“设计”的声明式请求库就出炉了。回到我们前面的话题，Feign 是如何实现的呢？它有哪些概念？与我们上面的构思有何异同？ Contract: 契约；用于解析接口声明，生成HTTP请求所需基本参数。 默认契约在 feign 的 github 主页有介绍。spring-cloud-feign 中使用SpringMvcContract 解析 Spring 的注解，我们可以使用统一的注解，定义请求的基本参数。 Encoder: 编码器；用于对请求内容作编码。 Decoder: 解码器：解析请求应答；一般只解析成功返回的应答。 ErrorDecoder: 错误解码器。一般 400~5xx 的错误由此解析。 Target: 目标: 即请求所对应的目标类及请求的url. Client: 请求具体客户端。可以由用户定制，默认为 HttpUrlConnection; 还可以使用 HttpClient、OkHttp、WebClient 等。 Retryer: 重试器；在网络 IO 有错误（比如超时、服务不可用等)，触发重试机制，具体重试的规则，在这个里面声明。 Logger: 日志；请求参数、url、应答、重试等日志的输出具体实现。 Options: 请求配置，一般用于定义请求的连接、读取应答的超时时间、是否响应 302 跳转。 RequestInterceptor: 请求拦截器，在请求发出前，对请求作修改。比如添加请求追踪，requestId 等。 我们看一下 Feign 的基本声明和使用代码：1234567891011121314151617181920212223242526272829303132333435interface GitHub &#123; @RequestLine("GET /repos/&#123;owner&#125;/&#123;repo&#125;/contributors") List&lt;Contributor&gt; contributors(@Param("owner") String owner, @Param("repo") String repo); @RequestLine("POST /repos/&#123;owner&#125;/&#123;repo&#125;/issues") void createIssue(Issue issue, @Param("owner") String owner, @Param("repo") String repo);&#125;public static class Contributor &#123; String login; int contributions;&#125;public static class Issue &#123; String title; String body; List&lt;String&gt; assignees; int milestone; List&lt;String&gt; labels;&#125;public class MyApp &#123; public static void main(String... args) &#123; GitHub github = Feign.builder() .decoder(new GsonDecoder()) .target(GitHub.class, "https://api.github.com"); // Fetch and print a list of the contributors to this library. List&lt;Contributor&gt; contributors = github.contributors("OpenFeign", "feign"); for (Contributor contributor : contributors) &#123; System.out.println(contributor.login + " (" + contributor.contributions + ")"); &#125; &#125;&#125; 设计思路可见 Feign 的设计与我们之前的“设计”非常接近；作为一个框架，它提供了很好的扩展能力，这些扩展能力的设计，也是我们需要着重学习的。 Feign 把很多概念定义为接口或者抽象类，方便我们扩展和定制已有的实现，也可以定义自己的私有实现。比如拍拍贷团队基于 Feign开发的 Raptor库，它拓展了 Feign 的实现，支持 google 的 protobuf。 代码解析以下代码解析基于 Feign 10.2.3，不同版本实现细节可能会有差异。 解析 ParseHandlersByName.apply 使用 contract(契约)解析接口类上的注解，获取到相关的 meta 信息，将方法与BuildTemplateByResolvingArgs(用于构建 RequestTemplate)及SynchronousMethodHandler做绑定。 ReflectiveFeign 对 1 的结果进行处理，新建一个 java 代理，非默认方法使用代理类处理；默认方法绑定到代理方法上。 返回代理类。 执行执行的过程本质是java 代理类的调用过程，实际调用的是代理类对应的 MethodHandler。 新建 MethodHandler 实例 将 RequestTemplate转为 Request，发起 HTTP 请求。 这个过程会对请求编码，如果有拦截器，则会使用拦截器对请求做处理。 根据返回的 Response的状态，判断正常 decode 还是调用 ErrorDecoder。如果超时的话，会调用重试器实例进行处理，由它决定继续重试还是抛出异常。 如果正常返回，调用 Decoder 反序列化为方法声明的返回类型。 更为详细的代码解析，大家可以参考拍拍贷技术博客的一篇文章 ^footnote_paipaidai Feign 涉及到的设计模式代理模式Feign 本质上通过 Java 的代理，将声明与实现进行解耦。调用者不用关心具体的实现，只需要假装调用本地方法一样来调用 HTTP 请求。 BuilderFeign.Builder 调用者不需要关心 Feign 的实现细节，构建一个代理类。比如前面例子中的 GitHub接口，在被初始化之后就成为了实现了 GIthub 接口的代理类。 策略模式服务声明接口中定义的默认接口方法和普通接口方法，分别使用 DefaultMethodHandler 和 SynchronousMethodHandler处理。前者相当于调用接口的普通默认方法，后者为实际代理方法。 简单工厂方法InvocationHabndlerFactory 根据传入的 Target 和方法 Handler 映射构建 InvodationHandler 类。 Feign 有哪些不足 没有提供细粒度地控制接口超时时间的注解 我们不能具体在接口层面约定请求的超时时间，只能将不同超时时间的接口，分别放在不同的文件中。当然，这个也不会是大问题，有赖于 Feign 的良好扩展性，我们可以添加自己的注解和扩展已有的契约(Contract)，使它支持更精细粒度的控制。 最佳实践 必须声明接口的超时时间 默认情况下，Feign 的连接超时时间为 10S，读取超时时间为 60S。不论是当前的微服务条件下，还是作为单独一个应用，默认的超时时间肯定不可以直接用。否则会降低服务的吞吐量，也影响着客户端的使用体验。 一个服务内，统一 ErrorDecoder 从应用的角度来讲，我们给客户端的应答的 body 结构应该是统一的，类似： 12345678&#123; "errors": [ &#123; "code": "error.system.remote_service_call", "detail": "获取天气信息失败" &#125; ]&#125; 对于 RPC的异常情况，错误的 code可以统一，错误的 detail 有利于我们理解到底发生了什么。使用 ErrorDecoder，解析错误的应答，可以帮助我们实现之。 参考链接]]></content>
      <categories>
        <category>java</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>feign</tag>
        <tag>feign best practice</tag>
        <tag>feign 代码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hibernate-best-practice]]></title>
    <url>%2F2018%2F12%2F06%2Fhibernate-best-practice%2F</url>
    <content type="text"><![CDATA[1. 设置数据库存储时间的时区如果某个应用考虑到国际化，服务会部署在多个时区，或者用户会和不同时区的人打交道；存储的时间建议使用 UTC 时间。比如美国有夏令时，会根据季节调整时间。使用 UTC 时间会更好地适应变化。 Hibernate 在时间的存取的时候，会调用PreparedStatement.setTimestamp()/ResultSet.getTimestamp，默认情况下，会 fall back 为 JVM 所在的时区。为了能够存储 UTC 时间，将 JDBC 的链接时区设置为 UTC 即可。即spring.jpa.properties.hibernate.jdbc.time_zone=UTC。 需要注意的是，对于 MySQL 数据库，在连接 URL 上要添加上useLegacyDatetimeCode=false，否则会导致时间并不会被转换为 UTC 时间。 当然，如果服务的时区是稳定的（比如固定在东八区），存储为服务当前时间服务也可以正常工作。 2. 检查生成的 SQL 是否与预期中的一致在查询、更新、删除记录的时候，一并检查生成的 SQL 是否与预期一致，可以在早期发现并解决潜在的性能问题。 JPA 开启打印日志的设置:123456spring.jpa.show-sql=truespring.jpa.properties.hibernate.type=tracespring.jpa.properties.hibernate.use_sql_comments=truespring.jpa.properties.hibernate.format_sql=truelogging.level.org.hibernate.type.descriptor.sql=tracelogging.level.org.hibernate.SQL=trace 打印日志还可以比较早地发现 N+1查询问题。 注意：仅在非生产环境打印SQL。 如何懒加载某个属性使用代码增强，并在属性上添加相应的注解：12345@Lob@Basic(fetch = FetchType.LAZY)public byte[] getPicture() &#123; return picture;&#125; 特点： 在使用的时候，会额外产生一条查询的 SQL 代码增强会修改原来的代码，做一些处理 需要注意的是：懒加载属性懒加载生效的前提是，没有 eager load 的关联；如果存在的话，注解失效。 使用子类123456789101112131415161718@MappedSuperclasspublic class BaseAttachment &#123; @Id @GeneratedValue private Long id; private String name;&#125;@Entity@Table(name = "attachment")public class AttachmentSummary extends BaseAttachment &#123;&#125; @Entity@Table(name = "attachment")public class Attachment extends BaseAttachment &#123; @Lob private byte[] content;&#125; 特点： 无侵入性代码，性能会更好 调用者需要对子类要有意识 实现 equals/hashCode/toString 方法equals/hashCodeequals 用于比较两个对象是否相等，重载时要遵守： 自反性：对于任何非null的引用值x, x.equals(x)必须返回true 对称性：对于任何非null的引用值x和y,当且仅当y.equals(x)返回true时，x.equals(y)必须返回true 传递性：对于任何非null的引用值x,y和z，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true 一致性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false 非null 引用与 null 比较，永远返回false hashCode 主要用于对象存储在 Hash 相关的存储模型，提供散列计算。 如果两个对象 equals，那么 hashCode 必然要相等。不同对象 hashCode 最好不要相同，尤其在数据量较大的时候。 考虑到实体的特性，实体一般都有标识符字段，它的来源有： 分配的（比如 UUID/ISBN/ID number)等 DB生成 对于前者，可以直接使用分配的标识符作为 equals/hashCode 的关键要素:123456789101112@Overridepublic boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Book)) return false; Book book = (Book) o; return Objects.equals(getIsbn(), book.getIsbn());&#125; @Override public int hashCode() &#123; return Objects.hash(getIsbn()); &#125; 对于后者，需要这样做：123456789101112@Overridepublic boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Book)) return false; Book book = (Book) o; return id != null &amp;&amp; id.equals(book.id);&#125; @Overridepublic int hashCode() &#123; return 31;&#125; 大家会发现 hashCode 永远返回31，使用固定值的原因是：如果使用下面的代码:123456789101112@Overridepublic boolean equals(Object o) &#123; if (this == o) return true; if (!(o instanceof Book)) return false; Book book = (Book) o; return id != null &amp;&amp; id.equals(book.id);&#125; @Overridepublic int hashCode() &#123; return Objects.hash(getId());&#125; 因为 ID 是在持久化之后，由数据库分配的；如果在持久化之前，他们是存储在一个 HashSet 中，入库之前，它的 hashCode 是 0；持久化之后，它的值发生了改变，HashSet 就不会包含当前的实体了。 toStringtoString 不建议包含关联实体。 如果关联是 Eager 加载的，容易引起性能问题（子实体关联的子实体，形成链式的查询)；如果关联是 Lazy加载的，会抛出：LazyInitializationException 异常。 如果主键是 UUID将id的类型设置为 UUID 即可,另外需要确保 GeneratedType 为AUTO: 12345678@Entity(name = "Post")@Table(name = "post")public class Post &#123; @Id // @GeneratedValue 默认策略为 GenerationType.AUTO @GeneratedValue private UUID id;&#125; 如果想自定义其它 ID 生成策略，可以参考 hibernate 的 UserGuide，里面有简单的例子可以参考。 自增主键的生成策略Hibernate 5之前，可以使用:1234567@Entity(name = "Post")@Table(name = "post")public class Post &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id;&#125; 自 Hibernate 5之后，MySQL需要调整为1234567@Entity(name = "Post")@Table(name = "post")public class Post &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id;&#125; AUTO 会 fall back 为性能差的 TABLE 生成器，需要显式声明为 IDENTITY。 检查生成的 SQL 是否与预期中的一致在查询、更新、删除记录的时候，一并检查生成的 SQL 是否与预期一致，可以在早期发现并解决潜在的性能问题。 JPA 开启打印日志的设置:123456spring.jpa.show-sql=truespring.jpa.properties.hibernate.type=tracespring.jpa.properties.hibernate.use_sql_comments=truespring.jpa.properties.hibernate.format_sql=truelogging.level.org.hibernate.type.descriptor.sql=tracelogging.level.org.hibernate.SQL=trace 打印日志还可以比较早地发现 N+1查询问题。 注意：仅在非生产环境打印SQL。 EAGER 加载是一种 code Smell加载策略不应该是实体关联的责任，简单地将在实体上将关联设置为 EAGER加载，会造成性能问题。在不同的业务场景下，需要加载不同的关联实体,所以要根据业务场景，在查询的时候，将关联实体一并查出来。 在实体上写的关联关系，加载策略要全部设置为 LAZY。默认情况下，不同关联关系的加载策略为: 关联关系 默认加载策略 OneToOne EAGER ManyToOne EAGER OneToMany LAZY ManyToMany LAZY subselect 是一种 code smelltransaction open-in-view 是一种 code smellJPA 读取数据的时候也显示地声明只读事务Do you need a database transaction for reading data? All database statements are executed within the context of a physical transaction, even when we don’t explicitly declare transaction boundaries (BEGIN/COMMIT/ROLLBACK). If you don&#39;t declare transaction boundaries, then each statement will have to be executed in a separate transaction (autocommit mode). This may even lead to opening and closing one connection per statement unless your environment can deal with connection-per-thread binding. Declaring a service as @Transactional will give you one connection for the whole transaction duration, and all statements will use that single isolation connection. This is way better than not using explicit transactions in the first place. On large applications, you may have many concurrent requests, and reducing database connection acquisition request rate will definitely improve your overall application performance. JPA doesn&#39;t enforce transactions on read operations. Only writes end up throwing a transaction required exception in case you forget to start a transactional context. Nevertheless, it&#39;s always better to declare transaction boundaries even for read-only transactions (in Spring @Transactional allows you to mark read-only transactions, which has a great performance benefit). Now, if you use declarative transaction boundaries (e.g. @Transactional), you need to make sure that the database connection acquisition is delayed until there is a JDBC statement to be executed. In JTA, this is the default behavior. When using RESOURCE_LOCAL, you need to set the hibernate.connection.provider_disables_autocommit configuration property and make sure that the underlying connection pool is set to disable the auto-commit mode. Casecase 要按需使用级联处理是 ORM 的 feature，在使用的时候首先要按照业务需求设置，不能简单地在父实体上设置为 CascadeType.ALL；而且级联处理要放在父实体上，而不是子实体，不滥用。 Casecade 最佳实践OntToOne双向 OneToOne 关联： 双向关联需要在父子两边都更新变动，父实体应该包含 addChild 和 removeChild 方法组合，以保证变动的一致性。 123456789101112131415161718192021222324@Entitypublic class Post &#123; @OneToOne(mappedBy = "post", cascade = CascadeType.ALL, orphanRemoval = true) private PostDetails details; public void addDetails(PostDetails details) &#123; this.details = details; details.setPost(this); &#125; public void removeDetails(PostDetails details) &#123; if (details != null) &#123; details.setPost(null); &#125; this.details = null; &#125;&#125;@Entitypublic class PostDetails &#123; @OneToOne @MapsId private Post post;&#125; 单向 OneToOne 关联：1234567891011121314151617181920212223242526@Entitypublic class Commit &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String comment; @OneToOne(cascade = CascadeType.ALL) @JoinTable( name = "Branch_Merge_Commit", joinColumns = @JoinColumn( name = "commit_id", referencedColumnName = "id"), inverseJoinColumns = @JoinColumn( name = "branch_merge_id", referencedColumnName = "id") ) public void addBranchMerge( String fromBranch, String toBranch) &#123; this.branchMerge = new BranchMerge( fromBranch, toBranch); &#125; public void removeBranchMerge() &#123; this.branchMerge = null; &#125;&#125; OneToManyOneToMany关联的对象不宜太多，如果太多，同样也会在更新子实体的时候，加载很多无用的实体。 双向1234567891011121314151617181920212223@Entitypublic class Post &#123; @OneToMany(cascade = CascadeType.ALL, mappedBy = "post", orphanRemoval = true) private List&lt;Comment&gt; comments = new ArrayList&lt;&gt;(); public void addComment(Comment comment) &#123; comments.add(comment); comment.setPost(this); &#125; public void removeComment(Comment comment) &#123; comment.setPost(null); this.comments.remove(comment); &#125;&#125;@Entitypublic class Comment &#123; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = "post_id") private Post post;&#125; 单向1234567@Entity(name = "Post")@Table(name = "post")public class Post &#123; @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true) @JoinColumn(name = "post_id") private List&lt;PostComment&gt; comments = new ArrayList&lt;&gt;();&#125; ManyToMany可以使用 ManyToMany 注解，也可以将其拆分为两个 OneToMany 关联。 前者比较自然；后者可以更好地控制数据的粒度。 123456789101112131415161718192021222324252627282930@Entity(name = "Post")@Table(name = "post")public class Post &#123; @ManyToMany(cascade = &#123;CascadeType.PERSIST, CascadeType.MERGE &#125;) @JoinTable(name = "post_tag", joinColumns = @JoinColumn(name = "post_id"), inverseJoinColumns = @JoinColumn(name = "tag_id")) private Set&lt;Tag&gt; tags = new HashSet&lt;&gt;(); public void addTag(Tag tag) &#123; tags.add(tag); tag.getPosts().add(this); &#125; public void removeTag(Tag tag) &#123; tags.remove(tag); tag.getPosts().remove(this); &#125; // equals &amp;&amp; hashCode&#125;@Entity(name = "Tag")@Table(name = "tag")public class Tag &#123; @ManyToMany(mappedBy = "tags") private Set&lt;Post&gt; posts = new HashSet&lt;&gt;(); // equals &amp;&amp; hashCode&#125; 对于有额外字段的多对多关联，可以参考 The best way to map a many-to-many association with extra columns when using JPA and Hibernate 只读查询添加上只读事务使用只读事务， detach 状态的记录不再被 Persistence Context保存，可以减少内存的使用和 GC 消耗的时间。 适当设置 DB 连接池的大小数据库连接池太大或者太小都会影响性能。太小，会等待连接的获取消耗太多时间；太大，时间消耗在线程的上下文切换上。默认情况下，JPA 的数据库连接池大小为10（够用)，各位可以根据自身应用的情况，设置比较合适的大小。 另外连接池的大小设置，要考虑到死锁的情况。之前我们遇到过这样的问题：我们使用了一个框架，除了在 Spring Boot 业务中使用了连接，在连接没有关闭的时候，框架又去申请了新的数据库连接。在框架处理完之后，两个连接会全部释放。假设现在，连接池有2个连接，在并发的时候，请求 A 和请求 B 同时获取了一个连接，这是 A 要调用框架，框架去连接池获取一个新的连接。这时数据库连接池的连接已经在使用了，请求 A 的处理线程只能等待；同样请求 B 的处理线程也只能等待。等待最终超时，程序报错。 那么如何避免连接池出现死锁的情况呢? pool_size = Tn x (Cm - 1) + 1 T 指得是程序的进程数；C 指的是每个进程执行的线程数。重点在于后面要有一个空余的连接。 如何找到合适的连接池大小，请参考另外一篇文章: TBD 附录从源码层面实现代码增强:在build.gradle 文件中，添加代码增强的插件:12345678910111213141516171819202122# build.gradlebuildscript &#123; ext &#123; hibernateVersion = &apos;5.2.17.Final&apos; &#125; dependencies &#123; classpath(&quot;org.hibernate:hibernate-gradle-plugin:$&#123;hibernateVersion&#125;&quot;) &#125;&#125;apply plugin: &apos;org.hibernate.orm&apos;hibernate &#123; enhance &#123; // Whether enhancement for lazy attribute loading should be done. enableLazyInitialization = true // Whether enhancement for self-dirty tracking should be done. enableDirtyTracking = true // Whether enhancement for bi-directional association management should be done enableAssociationManagement = true enableExtendedEnhancement = false &#125;&#125; 在需要懒加载的关联关系(OneToOne/ManyToOne)上添加: @LazyToOne(LazyToOneOption.NO_PROXY). 需要注意的是，IDEA 并不支持该插件，需要在设置中，将 gradle 的 Runner 设置为代理到 gradle。 参考链接： The best way to lazy load entity attributes using JPA and Hibernate The best way to implement equals, hashCode, and toString with JPA and Hibernate How to implement Equals and HashCode for JPA entities https://vladmihalcea.com/uuid-identifier-jpa-hibernate/ The Open Session In View Anti-Pattern How to store date, time, and timestamps in UTC time zone with JDBC and Hibernate About Pool Sizing The Open Session In View Anti-Pattern]]></content>
      <categories>
        <category>java</category>
        <category>hibernate</category>
        <category>jpa</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Add release to sentry]]></title>
    <url>%2F2018%2F11%2F12%2Fadd-release-to-sentry%2F</url>
    <content type="text"><![CDATA[Sentry 是一个开源的，用来帮助开发监控异常和跟进错误修复的服务。 Java 集成 Sentry 十分地方便，很方便地就可以实现异常的监控。如果我们想更加精细化地区分某个错误是在哪个版本中出现的，需要我们额外将 release 信息告知 Sentry。具体怎么操作呢？ 1. 添加SentryConfig配置类，将相关信息注入到 Sentry1234567891011121314151617181920212223242526272829303132333435363738@Configrationpublic class SentryConfig implements InitializingBean &#123; @Value("$&#123;application.host.name:localhost&#125;") private String hostName; @Value("$&#123;application.module.name&#125;") private String serviceName; @Value("$&#123;spring.profiles.active&#125;") private String activeProfile; @Value("$&#123;release.version:local&#125;") private String releaseVersion; // 将 sentry 的配置放到 application.properties 中， // 可以根据环境配置到不同 sentry 服务地址 @Value("$&#123;sentry.dsn&#125;") private String sentryDsn; @Value("$&#123;sentry.timeout&#125;") private String sentryTimeout; @Override public void afterPropertiesSet() throws Exception &#123; MDC.put("Host", hostName); MDC.put("Module", serviceName); MDC.put("Profile", activeProfile); System.setProperty("sentry.environment", activeProfile); System.setProperty("sentry.release", releaseVersion); if (StringUtils.isNotBlank(sentryDsn)) &#123; System.setProperty("sentry.dsn", sentryDsn); System.setProperty("sentry.timeout", sentryTimeout); &#125; &#125;&#125; 我们需要解决 release.version 从哪里获取，简单一些可以把 project.version在 build 的时候，写入到application.properties中。 123456789101112131415161718task createProperties(dependsOn: processResources) &#123; doLast &#123; def releaseVersion = 'release.version=' + project.version.toString() def file = new File("$buildDir/resources/main/application.properties") if (file.exists()) &#123; file.append(releaseVersion) &#125; file = new File("$projectDir/resources/main/application.properties") if (file.exists()) &#123; file.append(releaseVersion) &#125; &#125;&#125;classes &#123; dependsOn createProperties&#125; 我们可以继续完善：在版本信息的基础上把 Git 的 Commit ID 也加上，可以这样做： 方法 1. 添加gradle-git-version1234567buildscript &#123; dependencies &#123; classpath('gradle.plugin.com.palantir.gradle.gitversion:gradle-git-version:0.11.0') &#125;&#125;apply plugin: 'com.palantir.git-version' 添加这个插件后，我们可以调用versionDetails()获取当前项目的一些信息： def details = versionDetails() details.lastTag details.commitDistance details.gitHash details.gitHashFull // full 40-character Git commit hash details.branchName // is null if the repository in detached HEAD mode details.isCleanTag 里面有我们需要的gitHash，所以我们上面的脚本就可以修改为: 123456789101112131415161718task createProperties(dependsOn: processResources) &#123; doLast &#123; def releaseVersion = 'release.version=' + project.version.toString() = '-' + versionDetails().gitHash def file = new File("$buildDir/resources/main/application.properties") if (file.exists()) &#123; file.append(releaseVersion) &#125; file = new File("$projectDir/resources/main/application.properties") if (file.exists()) &#123; file.append(releaseVersion) &#125; &#125;&#125;classes &#123; dependsOn createProperties&#125; 上面的实现需要添加较多地配置，我们可以使用另外一个 gradle 插件gradle-git-properties 达到类似的效果： 方法 2：使用 gradle-git-properties 插件 添加依赖： 1234567buildscript &#123; dependencies &#123; classpath("gradle.plugin.com.gorylenko.gradle-git-properties:gradle-git-properties:1.5.1") &#125;&#125;apply plugin: 'com.gorylenko.gradle-git-properties' gradle-git-properties 会添加一个generateGitProperties的任务，执行之后生成git.properties；它相较于 git-version 提供的内容更多： git.branch git.build.host git.build.time git.build.user.email git.build.user.name git.build.version git.closest.tag.commit.count git.closest.tag.name git.commit.id git.commit.id.abbrev git.commit.id.describe git.commit.message.full git.commit.message.short git.commit.time git.commit.user.email git.commit.user.name git.dirty git.remote.origin.url git.tags git.total.commit.count 我们需要的是git.commit.id.abbrev，为了输出release.version我们需要添加一行配置： 1234// build.gradlegitProperties &#123; customProperty 'release.version', &#123; project.version + "-" + it.head().abbreviatedId &#125;&#125; 因为它生成的 properties 文件默认不会加载，需要在SentryConfig上添加@PropertySource注解，加载它:1@PropertySource(value = "classpath:git.properties", ignoreResourceNotFound = true) 在程序抛出异常后，我们就可以在 Sentry 中看到异常信息已经包含了应用的版本及 commitId 信息了：]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>sentry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JPA stream query with java8]]></title>
    <url>%2F2018%2F11%2F11%2Fjpa-stream-query%2F</url>
    <content type="text"><![CDATA[最近有小伙伴在做批量导出数据的功能，原来是这样写的： 后来在看其他代码的时候，有个类似功能，突然意识到那个代码在数据量很大的时候，会存在性能问题（最坏会OOM，导致不可用)。后面在交流过程中，小伙伴突然想到上面那个代码也会有类似问题。 在 Rails 的 ActiveRecord 中有find_in_batches功能，它会生成select ... from XX where id &gt; ? limit N offset M类似的 SQL，实现批量查询。 在 Java 中，首先想到的是使用 Pagable 翻页查找，但是这个不是很优雅，要自己去处理总页数、当前页等数据。 有没有更优雅一些的做法呢？搜索之后，发现了两篇文章： Streaming MySQL Results Using Java 8 Streams and Spring Data JPA What’s new in JPA 2.2 – Stream the result of a Query execution 原来 JPA 早就支持了 Java 8 的 stream。使用 Pageable 翻页方法，与 stream 的相比，多了 DB offset 的操作；后者实质上使用的是数据库的游标。 第一篇文章的内容结合自己业务数据，对文章内容作了一次验证： 测试数据库的 Post 表有 56W 条数据。测试机器信息： CPU: i7 2.3GHzMemory: 8GBx2 1600MHz DDR3 测试代码: case 1: 123# PostRepository.java @Query("select p from Post p")Stream&lt;Post&gt; streamAll(); case 2: 1234# PostRepository.java case 1:@QueryHints(value = @QueryHint(name = HINT_FETCH_SIZE, value = "" + Integer.MINI_VALUE))@Query("select p from Post p")Stream&lt;Post&gt; streamAll(); case 3: 1234# PostRepository.java case 1:@QueryHints(value = @QueryHint(name = HINT_FETCH_SIZE, value = "200")@Query("select p from Post p")Stream&lt;Post&gt; streamAll(); 需要注意的是，在调用 Repository 的地方，要显示声明为只读事务，否则会抛出异常。 没有堆(Heap)大小限制的情况下： case 1: 正常工作 case 2: 正常工作 case 3: 正常工作 以上3个时间相差不大。 将堆大小做了限制参数：-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -XX:MaxRAMFraction=1 -Xmx1080m -Xms512m 在几个测试案例中，只有case 2可以正常工作，且比前面的速度快了1/3。其它两种 case 全部不能正正常工作，最终 OOM，而且 GC 时间非常多。 case 1: case 2: case 3: 结论使用 stream 查询大量数据的时候，务必要添加@QueryHints(value = @QueryHint(name = HINT_FETCH_SIZE, value = &quot;&quot; + Integer.MIN_VALUE))注解，它可以在保证速度的同时，内存可以得到很好的控制。]]></content>
      <categories>
        <category>JPA</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JPA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac mail app tricks]]></title>
    <url>%2F2018%2F11%2F09%2Fmac-mail-tricks%2F</url>
    <content type="text"><![CDATA[常用设置1.修改邮件的一些默认设置1234567891011121314151617181920# Disable send and reply animations in Mail.appdefaults write com.apple.mail DisableReplyAnimations -bool truedefaults write com.apple.mail DisableSendAnimations -bool true# Copy email addresses as `foo@example.com` instead of `Foo Bar &lt;foo@example.com&gt;` in Mail.appdefaults write com.apple.mail AddressesIncludeNameOnPasteboard -bool false# Add the keyboard shortcut ⌘ + Enter to send an email in Mail.appdefaults write com.apple.mail NSUserKeyEquivalents -dict-add "Send" "@\U21a9"# Display emails in threaded mode, sorted by date (oldest at the top)defaults write com.apple.mail DraftsViewerAttributes -dict-add "DisplayInThreadedMode" -string "yes"defaults write com.apple.mail DraftsViewerAttributes -dict-add "SortedDescending" -string "yes"defaults write com.apple.mail DraftsViewerAttributes -dict-add "SortOrder" -string "received-date"# Disable inline attachments (just show the icons)defaults write com.apple.mail DisableInlineAttachmentViewing -bool true# Disable automatic spell checkingdefaults write com.apple.mail SpellCheckingBehavior -string "NoSpellCheckingEnabled" 邮件分类放在不同目录下邮件全部放在收件箱里面，不做分类的话，随着邮件越积越多，邮件非常杂乱。我们可以在邮件中添加目录(mail.app 中叫 mailbox)，然后在“Preferences&quot; -&gt; &quot;Rules&quot;，添加新的邮件规则。 过滤规则中，还可以设置发送通知，以便于我们不错过重要的邮件。 Smart Mailbox邮件放在不同目录下会比较有序，但是它只是比较粗的分类，有时我们需要更加定制化的从另外一个层面去透视邮件。比如筛选某些特定发件人、邮件主题、旗标、某个发件日期等邮件。 在邮箱左侧“Smart Mailboxes&quot;，选择添加， VIP对于某些 Very Import Person 发送的邮件，可以很方便地将其加入到 VIP 列表：在发件人邮箱上点击右键，选择添加到 VIP 即可。 旗标默认旗标只有一些颜色名称，而没有其它语义。给颜色添加一种语义，以方便我们理解。 先给邮件添加某个旗标，然后在左侧可以看到对应旗标出现；右键选择重命名(或者单击某个旗标，再次点击)，即可对其重命名。如果没有对应旗标的邮件，改旗标不会出现在左侧，也无法对其更名。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Mail</tag>
        <tag>tricks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea popular plugins]]></title>
    <url>%2F2018%2F09%2F19%2Fidea-popular-plugins%2F</url>
    <content type="text"><![CDATA[基本 lombok plugin GenerateSerialVersionUID Adds a new action &#39;SerialVersionUID&#39; in the generate menu (alt + ins). The action adds an serialVersionUID field in the current class or updates it if it already exists, and assigns it the same value the standard &#39;serialver&#39; JDK tool would return. The action is only visible when IDEA is not rebuilding its indexes, the class is serializable and either no serialVersionUID field exists or its value is different from the one the &#39;serialver&#39; tool would return. 效率篇 Jrebel for IDEA JRebel is a productivity tool that allows developers to reload code changes instantly. save actions Supports configurable, Eclipse like, save actions, including &quot;optimize imports&quot;, &quot;reformat code&quot;, &quot;rearrange code&quot;, &quot;compile file&quot; and some quick fixes for Java like &quot;add / remove &#39;this&#39; qualifier&quot;, etc. The plugin executes the configured actions when the file is synchronised (or saved) on disk. ace-jump AceJump allows you to quickly navigate the caret to any position visible in the editor. 代码质量 checkstyle Find bugs The FindBugs plugin for IntelliJ IDEA. SonarLint SonarLint is an IDE extension that helps you detect and fix quality issues as you write code. alibaba-coding-guideline Alibaba Java Coding Guidelines plugin support. 语法高亮 ignore .ignore is a plugin for .gitignore (Git), .hgignore (Mercurial), .npmignore (NPM), .dockerignore (Docker), .chefignore (Chef), .cvsignore (CVS), .bzrignore (Bazaar), .boringignore (Darcs), .mtn-ignore (Monotone), ignore-glob (Fossil), .jshintignore (JSHint), .tfignore (Team Foundation), .p4ignore (Perforce), .prettierignore (Prettier), .flooignore (Floobits), .eslintignore (ESLint), .cfignore (Cloud Foundry), .jpmignore (Jetpack), .stylelintignore (StyleLint), .stylintignore (Stylint), .swagger-codegen-ignore (Swagger Codegen), .helmignore (Kubernetes Helm), .upignore (Up), .prettierignore (Prettier), .ebignore (ElasticBeanstalk) files in your project. markdown-support Provides the capability to edit markdown files within the IDE and see the rendered HTML in a live preview. asciidoc AsciiDoc language support for IntelliJ platform. 其它 ideavim IdeaVim supports many Vim features including normal/insert/visual modes, motion keys, deletion/changing, marks, registers, some Ex commands, Vim regexps, configuration via ~/.ideavimrc, macros, window commands, etc. grep-console Change colors of matching text. Grep output into a new console tab. Change output or execute any action using custom groovy scripts or plugins. Filter out unwanted lines. Fold output. Play sounds on matches. Clear Console on matches. Tail files*. key-promoter-x Shows the user the keyboard short-cuts when a button is pressed with the mouse. This provides an easy way to learn how to replace tedious mouse work with keyboard keys and helps to transition to a faster, mouse free development. Currently, it supports toolbar buttons, menu buttons, and tool windows and the actions therein.]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>plugins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea productive tips]]></title>
    <url>%2F2018%2F09%2F19%2Fidea-productive-tips%2F</url>
    <content type="text"><![CDATA[This article is wroten according to a youtube video: https://www.youtube.com/watch?v=eq3KiAH4IBI. We use Idea programming everyday. How can we use it effectively, now let&#39;s reading it below: Close the tab list of IDE Preferences → Editor → Editor Tabs; Change Tab Placement from default Top to None. Tab is annoying when many files are opened. It&#39;s hard to find file when opening to many files, which it&#39;s inevitable. Use recent files window or search everywhere (Double Shift). We can use ⌘+E to explore recent files instead. Auto scroll to source When we select a file, we want to explore the file content, other than just the file name. If we want to see the source, we have to double click the file in project window, by default. While Idea provides us a feature that when we select a file, Idea will open the source automatically: In the project window, right top of the window, click the config icon, check the &quot;scroll to source&quot; in the dropdown list. Create directory or file effectivelly If I want to create a nested directory or package, I will select the parent directory and press ⌘+N, then input the directory name, before. There&#39;s more effective way: Just input the relative directory path, Idea will create the sub directory for us, if it doesn&#39;t exist. We can create file or directory through the navigation bar. Search file or class by search Double shift(press shift double times) is our friend, it pops up a search window which we can search file, class. It will list the more recent used files at the file lists. Scratch file feature It is a very common scenario that we want test a piece of code outside of the project context. We can press ⌘+⇧+N to create a scratch file which will be removed after we finish test. See more details, please visit https://www.jetbrains.com/help/idea/scratches.html Shrink Selection: Increase selection: ⌥ + ↑ Shrink selection: ⌥ + ↓ Move code block move code block up: ⌥ + ⇧ + ↑ move code block down: ⌥ + ⇧ + ↓ Rename (Refectory) Shift + F6 Auto comple Please follow both steps: Enable Automake from the compilerPress: ctrl + shift + A (For Mac ⌘ + shift + A)Type: make project automaticallyHit: EnterEnable Make Project automatically feature Enable Automake when the application is runningPress: ctrl + shift + A (For Mac ⌘ + shift + A)Type: RegistryFind the key compiler.automake.allow.when.app.running and enable it or click the checkbox next to it Auto wrap code When editing code: File → Editor → Code Style → Java → Wrappings And Brackets Change: Wrap On Typing → true When viewing code: https://stackoverflow.com/questions/23004520/code-wrap-intellij Insert Language Template https://www.jetbrains.com/help/idea/using-language-injections.html Navigation Bar Command + ↑]]></content>
      <categories>
        <category>editor</category>
      </categories>
      <tags>
        <tag>idea</tag>
        <tag>editor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些好用的工具之 Tmux 篇]]></title>
    <url>%2F2018%2F09%2F18%2Ftmux-tutorial%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。突然来了兴致，想利用一下睡觉前的时间，整理一下自己用过的，感觉很棒的命令行工具，作为一个系列。其中有的工具会比较复杂，有的会比较简单。复杂的，多写一些。简单的，拼盘拼成一篇。 今天的主题是 Tmux。 一. Tmux 是什么？Tmux 是一个终端复用工具。它可以允许在一个窗口创建、访问以及控制的多个终端。 二. Tmux 解决了什么问题？ Alice SSH 登录到远程机器，对机器进行维护。她要跑一个任务耗时很久。程序已经开始跑了。但是……中间发生了一个小插曲：Alice 因为自己电脑的故障，断开了远程机器的连接。结果因为执行任务的父进程被杀掉，导致程序跑了一半，被杀掉了。Alice 又需要从头开始执行。Poor Alice... Bob 平时使用 Vim 开发自己的项目。他一边要编辑代码，一边要做 Debug，一边需要一个交互式 Shell 查询数据库的数据情况。于是 Bob 开了3个 Tab 窗口来回切换。他发现，这样操作太麻烦了，需要来回手动切换 Tab 才可以看到自己想看的内容。 有小伙伴给他推荐了 iTerm2，它可以支持分割窗口。Bob 使用了一阵子后，依然觉得不爽：a. 不够灵活 b. 不小心关掉后窗口或 Tab 后，在执行的命令同样会中断。c. 切出来的窗口，停留在 Home 目录，需要手动执行cd命令，才能跳转到工作目录。 有了 Tmux 上面的问题，都迎刃而解。它可以： 在目标机器上运行，可以后台运行，即使网络连接断开也不受影响。 很方便的切换窗口，而且还可以自动切换到工作目录。 支持配置，通过配置文件管理初始化会话时的窗口及执行的命令。 支持 Pair Programming。 三. 一些概念 1. ServerTmux 能够让用户断连后，重新登录回来，可以保留工作现场的原因是，它本身是 C/S 架构的。Server 和 各个客户端之间通过在/tmp/的 socket 来进行通信。 Tmux 启动的时候，默认会创建一个Session（会话）。 2. SessionSession 是在 tmux 管理下的虚拟终端的集合。每个 Session 下面会有很多窗口(Window) 3. WindowWindow 是单个可见的窗口，它有自己的编号，默认从0开始。Window 可以被分割成很多的 Pane（窗格)。 4. Pane 就像一个大窗户会有很多小窗格一样，tmux 可以很方便的将窗口分割成一个个的小格子，每个格子可以称之为：Pane。 他们之间的关系可以很形象地用一张图来标明： 5. Prefix Key 四. 安装 Ubuntu 1sudo apt-get install tmux macOSX 1brew install tmux 五. 常用操作及配置1. 操作会话tmux 创建会话很简单，只需要在终端输入 tmux 就可以，个人不推荐在日常使用中这样做。因为人比较擅长记忆有语义性的东西，建议在启动的时候指定 session 的名字: tmux new -s sessionA。界面启动后是这样的： 如何查看现在正在运行的 session 列表呢？tmux ls，它就会列出所有的 session 列表。 如果我们想 attatch 到特定的 session，我们可以执行tmux at -t [sessionName]。 有些 session 在创建了之后，我们不想再看到它。处女座的盆友们不能忍。执行tmux kill -t [sessionName]。 那如果想干掉整个 tmux 服务呢？ tmux kill-server。 # 切换session bind -r ( switch-client -p bind -r ) switch-client -n 普遍用户对之不太习惯。我们可以对它做一下设置，使之符合我们的日常使用习惯。 2. 通用配置我们先看一张键盘图： 是不是觉得很怪异？上图是 ADM-3A 的键盘图，实际上也是 vi 编辑器的默认的按键绑定的图。tmux 的按键同样也是用了 vi 的键盘布局。tmux 的 Prefix 按键是C-b，所以为了方便使用，建议将按键改为 C-a，当然，建议小伙伴们将 Capslock 按键映射成 Ctrl。 # 取消默认绑定的按键，改为 Ctrl-a unbind C-b set -g prefix C-a # 设置 prefix,防止 tmux 按键和程序按键冲突。比如c-a 在 vim 配置为全选,在运行 tmux 时，需要先按 c-a,然后再按 vim 中的 c-a bind C-a send-prefix # 修改默认延迟时间 set -g escape-time 0 # 设置终端颜色，有时 vim 的 colortheme 有问题，设置它可以解决 set -g default-terminal &quot;screen-256color&quot; # 重新加载配置文件 bind r source ~/.tmux.conf \; display &quot;Configuration reloaded!&quot; # 设置历史大小 set -g history-limit 10000 3. 切换窗口#设置 window 窗口 index 默认开始值 set -g base-index 1 #设置 pane 的 index 默认起始值 set -g pane-base-index 1 #分割窗口 unbind &apos;&quot;&apos; bind | split-window -h bind-key v split-window -h -p 50 -c &quot;#{pane_current_path}&quot; unbind % bind - split-window -v bind-key s split-window -p 50 -c &quot;#{pane_current_path}&quot; #Disable rename window name of shell command set-option -g allow-rename off # Renumber the windows of current session set -g renumber-windows on #Unbind Space. Not use layout change unbind Space 4. 操作 Pane#在 pane 中移动 bind h select-pane -L bind j select-pane -D bind k select-pane -U bind l select-pane -R #调整 pane大小 bind H resize-pane -L 5 bind J resize-pane -D 5 bind K resize-pane -U 5 bind L resize-pane -R 5 #pane 转为 window unbind Up bind Up new-window -d -n tmp \; swap-pane -s tmp.1 \; select-window -t tmp unbind Down bind Down last-window \; swap-pane -s tmp.1 \; kill-window -t tmp 5. 复制粘贴6. 鼠标模式7. 定制样式8. 管理会话9. 结对编程六. 推荐资料 Productive Mouse-Free Development By Brian P.Hogan tmux man page. ADM-3A Tmux 插件 Tmuxinator 管理复杂的 tmux 会话 Google :)]]></content>
      <categories>
        <category>great tools</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Enable reload chagned java and template files In IntelliJ]]></title>
    <url>%2F2018%2F01%2F06%2Fenable-intellij-template-reload%2F</url>
    <content type="text"><![CDATA[最近在学习 Spring Boot 的时候发现真心不如 Ruby on Rails 爽，其中一点是：RoR 在 开发模式下默认可以自动 reload 相关路径下的文件： 123456789$ bin/rails r 'puts ActiveSupport::Dependencies.autoload_paths'.../app/assets.../app/controllers.../app/helpers.../app/mailers.../app/models.../app/controllers/concerns.../app/models/concerns.../test/mailers/previews 在 app/views下的文件在修改后也会立即产生效果。 但是在 Java 世界里，就没有全家桶了。开始的时候很不习惯，需要各种重启，每次重启8-10秒，几乎时时刻刻在和重启打交道。 还好在 Java 世界里是有解决方法的。 *.javajava 文件可以使用 spring-boot-devtools，但是，但是，任何在classpath中的文件的变动，都会引起整个程序重启。是的，没看错，是重启。233。好消息是：静态文件和模板文件的变动不会引起程序重启。 它不会提高太多效率，因为我们需要的是重新加载，而不是重启。 还好我们有JRebel，在 IntelliJ 的 &quot;Perferences&quot; → &quot;Plugins&quot; → “Browse Repositories&quot;，搜索JRebel，安装插件后重启。安装成功后，在Run菜单下，会多出两个子菜单：a. 使用 JRebel 启动程序。 b. 使用 JRebel 调试程序。 使用 JRebel 启动程序后，修改源文件，保存后，可以在标准输出看到JRebel: Reloading class &#39;io.polarlights.web.HomeController&#39;.这样的字样，说明它在正常工作了。 templates 启用自动构建项目 File –&gt; Setting –&gt; Build, Execution, Deployment –&gt; Compiler –&gt; check Build project automatically 启用执行时自动编译 打开 Action 窗口: Linux : CTRL+SHIFT+A Mac OSX : SHIFT+COMMAND+A Windows : CTRL+ALT+SHIFT+/ 输入&quot;Registry...&quot;，启用compiler.automake.allow.when.app.running 附录激活 JRebel 打开 https://my.jrebel.com/，使用 twitter/facebook 账号，填写相关的信息。注意：邮箱请一定不要乱填。就可以收到官方发来的激活码。 输入邮箱收到的相关数据就 OK。 References: https://www.mkyong.com/spring-boot/intellij-idea-spring-boot-template-reload-is-not-working/ http://www.jhipster.tech/configuring-ide-idea/ https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html https://www.jetbrains.com/help/idea/navigating-to-action.html http://guides.rubyonrails.org/autoloading_and_reloading_constants.html]]></content>
      <categories>
        <category>Intellij</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Switch java versions on Mac OSX]]></title>
    <url>%2F2017%2F12%2F27%2Fhow-to-switch-differents-version-of-java-on-mac%2F</url>
    <content type="text"><![CDATA[最近公司部分产品开始从 Ruby 转到 Java，这应该是很多创业公司走的路吧，在业务变化快速阶段，希望可以使用高效率的开发套件；而到了业务相对稳定以及用户量上升之后，希望可以保证它的稳定性以及高性能。当然最主要的原因是招 Ruby 的小伙伴还是比较有难度. 233. 比较欣喜的是在 Java 9 中终于有了 Jshell，可以像 Ruby 那样动态调试代码；不过我还是最爱 Ruby On Rails，可以更快地去关注自己的业务，不用啰嗦地去写很多冗余分层的代码。但是我们的核心代码还是使用 Java 8 进行开发，偶尔还需要使用 JShell。 搞定 java 都需要设置环境变量 JAVA_HOME 的，如果要切换 Java 版本就需要修改 JAVA_HOME 的值。有没有比较好的方式来操作呢？ 当然首先想到的是使用 alias，动态去搞定 Java 的环境变量，比如像这样: 12alias j9="export JAVA_HOME='/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home'"alias j8="export JAVA_HOME='/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home'" 这样可以解决问题，但是呢，我们要追求优雅，避免写 HARD CODE。 有没有更好的方法呢？答案必然是：有！ 在 Mac OS X Leopard^java_home 及以后版本，在 /usr/libexec/ 开始有了一个命令叫 java_home^apple_java_home。 该命令默认返回当前系统中安装的最高版本的 Java 版本。 我们先看它支持的参数及含义： 123456789101112131415&gt; /usr/libexec/java_home -hUsage: java_home [options...] Returns the path to a Java home directory from the current user's settings.Options: [-v/--version &lt;version&gt;] Filter Java versions in the "JVMVersion" form 1.X(+ or *). [-a/--arch &lt;architecture&gt;] Filter JVMs matching architecture (i386, x86_64, etc). [-d/--datamodel &lt;datamodel&gt;] Filter JVMs capable of -d32 or -d64 [-t/--task &lt;task&gt;] Use the JVM list for a specific task (Applets, WebStart, BundledApp, JNI, or CommandLine) [-F/--failfast] Fail when filters return no JVMs, do not continue with default. [ --exec &lt;command&gt; ...] Execute the $JAVA_HOME/bin/&lt;command&gt; with the remaining arguments. [-R/--request] Request installation of a Java Runtime if not installed. [-X/--xml] Print full JVM list and additional data as XML plist. [-V/--verbose] Print full JVM list with architectures. [-h/--help] This usage information. 对于我们比较有意义的是-v和-V两个参数。-V返回当前系统中安装的 Java 版本，-v 返回指定版本的 Java 的所在目录。 1234567891011╰ ➤ /usr/libexec/java_home -VMatching Java Virtual Machines (2): 9.0.1, x86_64: "Java SE 9.0.1" /Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home 1.8.0_152, x86_64: "Java SE 8" /Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home# java_home -v╰ ➤ /usr/libexec/java_home -v 9/Library/Java/JavaVirtualMachines/jdk-9.0.1.jdk/Contents/Home╰ ➤ /usr/libexec/java_home -v 1.8/Library/Java/JavaVirtualMachines/jdk1.8.0_152.jdk/Contents/Home 现在已经知道了动态获取指定版本 Java 所在目录的方法，那么对之前的 alias 做一下简单重构： 12alias j9="export JAVA_HOME=`/usr/libexec/java_home -v 9`"alias j8="export JAVA_HOME=`/usr/libexec/java_home -v 1.8`" 现在，我们可以愉快地和多个 Java 版本玩耍了。]]></content>
      <categories>
        <category>Mac</category>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[how_to_test_class_and_module]]></title>
    <url>%2F2016%2F03%2F23%2Fhow-to-test-a-class%2F</url>
    <content type="text"><![CDATA[前面我们简要介绍了Minitest的运行原理。知其然而知其所以然，如果了解了别人好的代码是如何设计的，对于自己编码技术的提升会有促进作用。 好了，我们接下来继续了解如何使用Minitest测试我们的类、模块、model及钩子、控制器和试图。后面还会涉及mock和使用种子数据、定制minitest等内容。 本文主要讲如何测试我们写的类。 Ruby是一种面向对象语言非常高的语言，因为即使像数字、纯字符串等都是对象，都有属于它的方法。现实是复杂的，为了方便理解和处理我们遇到的事物、问题、概念，我们会把它抽象为对象，再高级一些就是类。对象是具体的某个事物，类，泛指一类事物。 假定我们有下面的一个类： 12345class MyString &lt; String def palindrome? self.reverse.eql? self endend 如何测试它呢？ 123456789101112131415require 'minitest/autorun'class MyStringTest &lt; Minitest::Test def test_should_be_palindrome ms = MyString.new('') assert ms.palindrome? ms = MyString.new('mom') assert ms.palindrome? end def test_should_not_be_palindrome ms = MyString.new('name') refute ms.palindrome? endend 需要requre Minitest的autorun文件，测试类一般带有Test字样，而且必须继承自Minitest::Test类。具体原因我们在前面分析Minitest的原理时，有谈到。里面的测试方法需要以test_开头，否则不会执行该方法。]]></content>
      <categories>
        <category>ruby</category>
        <category>minitest</category>
      </categories>
      <tags>
        <tag>ruby</tag>
        <tag>minitest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby Class And Module]]></title>
    <url>%2F2016%2F03%2F23%2Fclass-and-modules%2F</url>
    <content type="text"><![CDATA[Class一个类的实例可以使用类名.new来初始化，new方法会自动调用该类的initialize方法，但是由于initialize方法是类的私有方法，所以不能显式的调用它。 12345678class Point def initialize(x, y) @x = x @y = y endendp = Point.new(2, 4) 上面的实例p并不能直接访问里面的实例变量@x,@y，因为Ruby是面向对象的语言，所以访问这些实例变量实际上是访问与实例变量的方法而已。如果直接使用p.x，Ruby会告诉你:&quot;NoMethodError: undefined method `x` for #&lt;Point:0x007fc7c40b1ee8 @x=2, @y=4&gt;&quot;。为了能够访问里面的实例变量，我们可以定义对应的访问方法。 1234567891011121314151617class Point def initialize(x, y) @x = x @y = y end def x @x end def x=(x) @x = x endendp = Point.new(2, 4) 上面我们定义了Point对实例变量x的getter和setter方法，现在我们就可以正常访问x了。如果调用p.x = 4,那么这里实际调用的是p.x=(4)，即调用的为x=方法。 在Java语言中，getter和setter方法在Bean中是如此的常见，每次写都挺麻烦。那么在Ruby中有没有更好简略方法呢？有。在Ruby中有访问控制器，attr_reader方法定义了那些实例变量可以被外部所使用，attr_accessor方法定义了哪些实例变量可以被外部获取也定义了setter相似的功能，即它是getter和setter方法的合集。 attr_reader和attr_accessor方法后面可以直接跟变量的名称，也可以使用Symbol，也可以使用字符串 Ruby使用了常见的数学符号来当做方法，比如；+,-,*，注意，它们不是简单的符号，在Ruby中，它们其实是方法。对于减号操作-，有一元和二元两种形式，一元减的定义要使用-@，在调用的时候为-对象.变量。 12345678910111213141516171819class Point def initialize(x, y) @x = x @y = y end def +(other) return Point.new(@x+other.x, @y+other.y) end def -@ return Point.new(-@x,-@y) end def -(other) return Point.new(@x-other.x, @y-other.y) endend Duck Typing：它的含义是：如果它走路像一只鸭子并且也像鸭子一样嘎嘎叫，那它就是一只鸭子。 对于这句话怎么理解呢？以我们上面的代码为例，在定义+方法时，我们并没有对other作类型的校验，只要other有x,y这两个方法且返回一个数值就可以。如果把Point类当做一只鸭子，而other又像Point一样拥有x,y方法，我们不管它是否真的是Point对象，那么other就是一个&quot;鸭子&quot;。那么如果万一other并没有x或者y方法呢？没有就报异常咯。 如果我们要添加类型的检查，可以这样做： 12345def +(other) Point.new(@x + other.x, @y + other.y)rescue raise TypeError, "Point addtion is not like a Point Duck Way"end 俗语有言：条条大道通罗马。123456789101112def +(other) raise TypeError, "Point addtion is not like a Point Duck Way" unless other.respond_to? :x and other.respond_to? :y Point.new(@x + other.x, @y + other.y)enddef +(other) raise TypeError, "Point addtion is not like a Point Duck Way" unless other.is_a? Point Point.new(@x + other.x, @y + other.y)end 对于Point的实例变量我们可以使用[]方法来访问： 12345678910def [](index) case index when 0, -2: @x when 1, -1: @y when :x,"x": @x when :y,"y": @y else nil endend 对于Point类我们也可以定义each方法，来遍历实例变量。1234def each yield @x yield @yend 由于Point中的实例变量是有限的，我们只需要yield两次就可以了。调用的时候是需要p.each {|x| puts x}即可。 如果类实现了each方法，那么就可以混入Enumerable模块的一些方法，这些方法都是基于each定义的，include Enumerable。混入了Enumerable模块，可以写出以下的代码: 1p.all? &#123;|x| x &gt; 0&#125; #return true if all of the elements of Point larger than zero. 在Java中，如果要判断两个实例是否&quot;相等&quot;需要覆写equals方法的。那么在Ruby中如何判断两个实例是否相等呢？我们可以定义==方法。 1234567def ==(other) if other.is_a? Point @x == other.x and @y == other.y elsif false endend 在Ruby中eql?也可以用来比较对象是否相等，但是它不会自动进行类型的转换，而==是会对类型进行自动转换的。 12puts 1 == (1.0) #true FixNum will be converted to Floatputs 1.eql?(1.0) #false FixNum is not the same as Float 如果想让两个操作在一个类中看起来是一样的，我们可以使用前面学到的alias来对方法进行重命名。 1alias eql? == 如果对Point有两种比较方式，一种不严格的坐标相等，一种严格的坐标相等。那么第一种就是==方法了。第二种我们可以定义 eal?方法来实现。 1234567def eql?(other) if other.instance_of? Point #sub-class instance is not allowed @x.eql?(other.x) and @y.eql?(other.y) #type convert is not allowed elsif false endend 对于Hash值的相等性判断 Hash类的eql?使用主键进行比较，如果没有定义eql?方法，哈希表会用对象标志对对象进行比较，这意味着如果有一个哈希元素的主键是p，那么只能使用p来访问这个元素，而不能使用q,即使p==q。可变对象不适合做哈希表的主键，让eql?方法保持未定义可以绕过这个问题。 eql?方法用于Hash对象，不能单独定义它，类似于Java，它还需要定义如何计算它的hash值。有一个简单的方法来做到： 123def hash @x.hash + @y.hashend 有一个比较通用的hash生成方法，适合于大部分的Ruby类: 1234567def hash code = 17 code = 37 * code + @x.hash code = 37 * code + @y.hash #the 17 and 37 is from the "Effective Java" codeend 如何比较两个Point的大小呢？ 如果要比较两个对象的大小，一般要混入Comparable模块，实现&lt;==&gt;方法。 1234def &lt;==&gt;(other) return nil unless other.instance_of Point @x ** 2 + @y ** 2 &lt;==&gt; other.x ** 2 + other.y ** 2end Comparable使用&lt;==&gt;来定义==方法，但是由于Point显式定义了==方法，所以Comparable中定义的==不会被调用到。 Enumerable模块定义的若干方法，比如sort, min和max等包含比较的方法只有在被枚举的对象定义了&lt;==&gt;才能够正常工作。 在定义一些可变方法的时候，如果会修改原来对象的值，一般对象方法后会有!来标志，如果不修改原有对象，一般会返回对象的一个副本。 12345678910def add!(other) @x += other.x @y += other.y selfenddef add(other) q = self.dup q.add!(other)end 可变类Mutable Class 我们可以使用Struct类来定义可变的类，Struct类是Ruby的内核类，可以用于生成其它的类。在生成的类中定义的实例变量自动具有访问器方法。使用Struct来定义一个新类有两种方式: 12Struct.new("Point", :x, :y)Point = Struct.new(:x, :y) 在上面例子中，第二行代码使用了&quot;命名匿名类&quot;，如果把一个未命名的类对象赋值给一个变量的时候，这个变量名就自动称为该类的名称。上面的类就自动成为了&quot;Point&quot; 使用Struct定义的新类会自动定义getter、setter、[]、[]=、each、each_pair、==、to_s方法。如果需要继续在Point类中添加新的方法，可以直接这样定义: 12345class Point def my puts "I am a add-handed method" endend 这不仅仅限于我们定义的新类，还包括任何其它的类。如果想要取消某些方法，可以使用前面学到的undef方法。 123class Point undef []=, x=, y=end BTW：所谓的可变与不变是指实例能否被外界的值所改变内部的实例变量。变与不变只是相对的，不变可以变为变的，变的可以变为不变的。 类方法Class Method 类方法就是传说中的单例方法，它可以单独调用，也可以使用对象.方法名来调用。定义它的方式有很多种： 12345678910111213141516171819202122232425262728293031323334class Point #method one def Point.sum(*points) x, y = 0, 0 points.each &#123;|p| x += p.x, y += p.y&#125; Point.new(x, y) end #method two def self.sum(*points) x, y = 0, 0 points.each &#123;|p| x += p.x, y += p.y&#125; Point.new(x, y) end #method three class &lt;&lt; self def sum(*points) x, y = 0, 0 points.each &#123;|p| x += p.x, y += p.y&#125; Point.new(x, y) end endend#method fourclass &lt;&lt; Point def sum(*points) x, y = 0, 0 points.each &#123;|p| x += p.x, y += p.y&#125; Point.new(x, y) endend 定义类常量 常量一般都是使用全大写的单词，常量既可以从类中定义，也可以在类外自己动态添加(oh my god, it is so powerful weapon！) 12345def Point ORIGINAL_POINT = [0,0]endPoint::DYNAMIC = [100, 100] 要访问这些常量一般要加类的限定词，而在类内部对此没有任何要求。 类变量 Class Variables 类变量在不同实例之间共享，使用@@开头，只在内部可以引用，但是在外部是无法访问到的。类变量可以在类方法中可以被访问，类实例变量却是不可以的。 类实例变量 类实例变量是在类方法外定义的变量，但是这些变量是不能被实例方法所访问。不过类实例变量可能会让我们与普通的实例变量所混淆。类实例变量的优于类常量的一个重要特性是在继承现有类时，类实例变量的行为不像类变量那样让人混淆。 下面是分别用类变量和类实例变量写的用于统计Point的代码； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#class variableclass Point @@n = 0 @@totalX = 0 @@totalY = 0 def initialize(x,y) @x,@y = x,y @@n += 1 @@totalX += x @@totalY += y end def self.report puts "Number of points created: #@@n" puts "Average X coordinate: #&#123;@@totalX.to_f / @@n&#125;" puts "Average Y coordinate: #&#123;@@totalY.to_f / @@n&#125;" endend#class instance variable #Because the class instance variable can't be used in the instance method, so define it in the class methodclass Point @n = 0 @totalX = 0 @totalY = 0 def initialize(x,y) @x,@y = x,y end def self.new(x,y) @n += 1 @totalX += x @totalY += y super end def self.report puts "Number of points created: #@@n" puts "Average X coordinate: #&#123;@@totalX.to_f / @@n&#125;" puts "Average Y coordinate: #&#123;@@totalY.to_f / @@n&#125;" end end 因为类实例变量是类对象的实例变量，我们可以使用attr_reader和attr_accessor为它们创建访问器方法。我们可以这样做: 123class &lt;&lt; self attr_accessor :n, :totalX, :totalYend 方法的可见性Ruby像其它大部分面向对象一样使用public、private和protected来分别表示公开、私有和受保护的。 在ruby中定义的方法默认为public的，但是initialize方法不是，它是私有的。在类外定义的全局方法也是被定义为类的私有方法。 标准的定义类的顺序是这样的； 1234567891011class Point #public methods #... #protected methods protected #private methods privateend 除了常量外，Ruby的变量自动都是私有的，所以我们不能在外面直接访问它，除非有定义访问器方法设定的变量。 也可以在定义了方法后，在类的半部分同义定义某些方法的访问性: private :x, :y 如果想要定义工厂类，那么我们一般不让直接使用类.new来获取新实例的，所以需要定义new的可访问性，但是由于new是类方法，所以这里需要特殊处理下，即使用private_class_method方法。当然如果想要将某个方法变为public的，那么可以使用public_class_method方法。 继承类在继承的时候不会继承父类的实例变量，这些变量是在方法调用的时候自动生成的，这一点与Java等语言是不一样的。 ##对象创建和初始化 Ruby一个new方法看起来像这样的: 12345def new(*args) o = self.allocate #创建类的新对象 o.initialize(*args) #调用对象的初始化方法，使用传入的参数进行初始化 o #返回对象end allocate是Class类的实例方法，被所有的类所继承，它的作用是创建类的一个实例。此方法不能被覆盖，因为Ruby只会调用它的原始版本，所以不会被真的覆盖掉。 initialize方法是一个实例方法，它的作用是为类的实例变量作初始化并赋初值。由于它是一个私有方法，所以我们不能显式地调用它。 Class类定义了两个名为new的方法，一个是Class#new，它是一个实例方法，另外一个是Class::new，它是一个类方法。Class#new用于创建一个类的新对象，而CLass::new用于创建一个新类。 ###创建一个工厂方法 创建工厂方法方法必须不能让外界直接使用new方法，如何做到呢？这就用到了我们上面提到的方法可见性控制的内容了。 123456789101112131415class Point def initialize(x,y) @x,@y = x,y end private_class_method :new def Point.cartes(x,y) new(x,y) end def Point.polar(r, theta) new(r * Math.cos(theta), r * Math.sin(theta)) endend dup、clone和initialize_copy使用dup和clone方法也可以返回一个新对象，它分配一个调用者所属类的实例，然后把调用者的所有实例变量和修改都拷贝到新创建的对象中。clone方法比dup方法拷贝的更彻底，包括对象的单例方法和冻结状态。 如果类定义了一个名为initialize_copy的方法，那么clone和dup方法在拷贝完实例变量后，会执行这个方法，这个方法也是私有方法。 clone和dup方法把实例变量从原始对象拷贝到拷贝对象中时，它们拷贝的是引用而非实际值。也就是说，它们用的是浅拷贝，在修改拷贝对象时，它会修改被拷贝对象的值，所以一般我们在定义一个类时都要定制这两个方法的原因。 123456789101112131415161718192021222324252627def Point attr_accessor :x,:y def initialize(x,y) @x,@y = x,y endenddef Test attr_accessor :p def initialize(p) @p = p endendp = Point.new(0,0) #x=0,y=0t = Test.new(p) #t.p.x=0, t.p.y=0t1 = t.clonet2 = t.dup #the same as the abovet1.p.x = 1 #p.x=1, t.p.x=1, t2.p.x=1t2.p.y = 4 #p.y = 4, t.p.y=4, t1.p.y=4t1.p = nil #t.p = pt2.p = nil #it have no affect on t 为了防止拷贝对象，我们可以使用def；来删除clone和dup方法，也可以将之定义为私有的方法，暴扣new,allocate。 marshal_dump和marshal_load创建对象的第三种方式是调用Marshal.load方法来重新生成前面使用Marshal.dump序列化的对象。Marshal.dump方法保存一个对象的类，并递归序列化其中每个实例变量的值。绝大多数对象都可以使用这两个方法进行存储和序列化。 那么什么是序列化呢？序列化是我们将对象的一些状态保存成其它形式，或变量或文件，在需要重新恢复它的状态时，我们可以从序列化的结果进行反向操作，将对象的状态恢复过来。 有些类要修改实现序列化的方式，这样做的原因是为对象状态提供更加紧凑的方式，不去序列化那些缓存易变的数据。修改的方法就是重新定义marshal_dump来定制序列化方式，以及marshal_load来定制反序列化的方式。marshal_load方法被一个使用allocate方法新分配但是未初始化的的对象所调用，它需要一个由marshal_dump返回的可再生的对象拷贝作为参数，然后根据参数对象的状态初始化接收者对象。 123456789101112131415161718class Point def initialize(*coords) @coords = coords end def marshal_dump @coords.pack('w*') end def marshal_load(s) @coords = s.unpack('w*') end endp = Point.new(1,2,3,4)s = p.marshal_dumpt = Point.allocatet.marshal_load(s) #t will be the same instance variables as the instance of p 下面的例子展示了如何将对象序列化到文件，并从文件反序列化对象的实例。 12345678910111213141516171819202122232425262728293031323334353637class Logfile def initialize(filename) @filename = filename @io = File.open(@filename,'w') end def marshal_dump log "Begin marshal..." @filename #just dump the filename, and leave the io object alone end def marshal_load(filename) @filename = filename @io = File.open(@filename, 'a') ``log "Begin ummarshal..." end def log(msg) @io.puts "#&#123;Time.now&#125;: #&#123;msg&#125;" endendlogfile = if File.exists?('logfile') File.open('logfile') do |file| Marshal.load(file) end else Logfile.new('log.txt') endARGV.each do |msg| logfile.log msgendFile.open('logfile', 'w') do |file| Marshal.dump(logfile, file)end 如果对一个类禁用了clone和dup方法，我们可能需要定制序列化方法，通过序列化和反序列化可以很容易实现对象的拷贝，我们就不可以不使用marshal_dump和marshal_load方法，让Marshal.load方法返回对象 单例类如果需要设定某个类是单例的，可以将new设置为私有，并且要阻止dup和clone方法不返回新的拷贝。也可以包含singleton模块，并在类中include Singleton就可以。这样会定义一个名为instance的方法来返回该类的一个实例。不过需要注意的是，这样定义的类是不能使用带参数的initialize方法。 12345678910111213141516171819require "singleton"class PointStats include Singleton def initialize @n, @totalX, @totalY = 0, 0, 0 end def record(point) @n +=1 @totalX += point.x @totalY += point.y end def report puts "Number of points are: #@n" endend 在Point类中可以这样定义initialize方法: 1234def initialize(x,y) @x,@y = x,y PointStats.instance.record(self)end 想要获取返回的值，可以这样做: 1PointStats.instance.report 模块Modules模块与类是很相似的，是方法、常量和变量的命名组，它使用关键字module。与类不同的地方是模块不能被实例化，也不能被继承，只能作为命名空间和混入(Mixin)使用。 模块用于命名空间一个模块内部是可以相互嵌套的，这样会产生嵌套的命名空间。 12345678910111213141516module Base64 DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' class Encoder def encoder end end class Decode def decoder end end def Base.help #or self.help endend 在外部使用常量需要Base64::DIGITS，使用某个方法可以使用Base64.help, encoder = Base64::Encoder.new ##Module用于混入 模块的第二个作用是用于混入，Enumerable和Comparable是两个比较常见的模块，前者在混入的类中，如果定义了each方法，那么这个类就会有很多强大的迭代器,如each_with_index,each_with_object。如果Comparable模块被混入，且类定义了&lt;==&gt;方法，那么这个类的&gt;、&lt;、=方法就会自动拥有。 123class Point include Comparableend 上面的include看起来是一个关键字，但实际上它是Module类的一个私有方法,隐式地被self调用。self.include(Comparable)。但是在代码中这样书写是错误的，它必须以函数的形式被调用。include方法可以接受多个Module对象进行混入，所以如果一个类定义了each和&lt;==&gt;方法的类可以加入include Enumerable, Comparable。 虽然class也是模块，但是类不允许include在另一个类中，include的参数必须是以module进行声明的模块。但是将模块包含在另一个模块中是合法的。 1234567module Iterable include Enumerable def each loop &#123; yield self.next &#125; endend 混入一个模块的方式除了使用include外，还可以使用Object.extend方法，它可以将指定模块的实例方法变成接收对象的单键方法。 123456789countdown = Object.newdef countdown.each yield 1 yield 3 yield 2endcountdown.extend(Enumerable) #now the each method becomes a singleton method of Object and have the mothods in Enumerableprint countdown.sort 可包含的命名空间模块前面我们定义的module中的方法都是以混入类的实例方法来调用的，我们可以将混入的方法以类的私有方法来进行调用。在就爱那个方法定义为了实例方法之后，使用module_function将这些方法定义为“模块函数”。module_function与public、private等类似，它的主要作用是对给定方法创建类方法的拷贝和将实例方法变为私有的。module_function可以不跟参数，类似与private、public这样的效果，所以如果不想让某些方法成为非模块函数时需要将它定义在module_function的前面。 使用module_function不是出于访问控制的需要，真实目的是让这些方法必须用无接受者的函数风格的调用方式。强制被包含模块的方法以无接收者的方式调用，减少了与真正的实例方法混淆的可能。 123456789101112131415161718module My def test puts "hello world" end module_function :testendclass Point def my test endendp = Point.newp.test #Wrongp.my #hello worldMy.test #hello world 加载和请求模块Ruby程序被分散在多个文件的时候，我们需要将它们“组装”起来，组装的方法就是require和 load。require和load的作用类似，但是require更加常用，require还可以用于从标准库中加载文件。require还可以加载二进制扩展，如so和dll。load方法要求加载的为包含文件扩展名的完整文件名称，而require只需要传入文件的名字，而不需要后缀。如果一个目录下同时拥有同名的不同后缀的文件，那么require优先加载文件格式的文件，而不是二进制文件。load方法会加载一个路径多次，而require由于会将文件路径展开，所以不会重复，且它把已经加载过的文件名方在全局数组$&quot;中。 Ruby的加载路径可以使用$LOAD_PATH或$:来获取。越是靠前的路径优先被搜索。在ruby 1.9中，load_path数组的元素可以是字符串，也可以是任何实现了to_path的类对象。 执行加载的代码load和require会立刻执行制定文件的代码，但是这种执行方式与直接调用文件中的代码并不是等价的。 用load和require加载的文件在顶级范围中被执行，而不是在load或require被调用的层级中执行。被夹在的文件可以访问那些加载时已定义的所有全局变量和常量，但是实例变量是不能在文件外被访问到。另外self的值永远是主对象，load和require不会把接收者对象传递给所加载的文件。 load方法在调用时，如果第二个参数值不是nil或false，它会wrap给定的文件到一个匿名模块中，这意味着加载的文件不会影响全局命名空间，它命名的所有常量被放入到这个匿名模块中。这种包裹加载方式作为一种安全措施而存在。 当一个文件被加载到匿名模块中，它亦然可以设置全局变量，而且这些变量也可被加载的代码所使用。 autoloading ModulesKernel和Module的autoload方法支持按需惰性加载的机制，它允许使用一个未定义的常量和定义了该常量的包名。在这个常量在第一次被引用的时候，那个注册的包就使用require进行加载。 1auload :TCPSocket, "socket" 使用autoload?或Module.autoload?方法可以测试一个常量是否加载一个文件，它们带有一个符号参数。如果这个符号参数加载了一个文件，autoload?方法返回文件名，否则返回nil。]]></content>
      <categories>
        <category>Tech</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Module</tag>
        <tag>Class</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How Minitest Works Part 2]]></title>
    <url>%2F2016%2F02%2F21%2Fhow_minitest_works_part_2%2F</url>
    <content type="text"><![CDATA[注：本文以 minitest 的最新master 分支 baf6010 ，版本为5.8.4为基础。所有代码可以在minitest_source 找到. 在上一节我们留下了以下几个问题，本节我们透过对Minitest源码的分析来一探究竟: minitest/autorun 到底做了什么？ 继承Minitest::Test的目的何在，它内部有什么特殊方法？ 为什么以test_ 开头的方法执行了，而普通的方法没有执行？里面肯定有一个&quot;惊天的阴谋&quot; Minitest 的结果是何时，如何打出来的？ Minitest有哪些钩子，调用顺序几何？ 我们首先看minitest/autorun文件，里面只有简单几行： 123456789101112begin require "rubygems" gem "minitest"rescue Gem::LoadError # do nothingendrequire "minitest"require "minitest/spec"require "minitest/mock"Minitest.autorun Minitest.autorun它做了什么事情呢？加载 minitest 相关文件，最后调用Minitest.autorun方法，即Minitest的module方法autorun。让我们继续顺藤摸瓜。它在哪里定义的呢？在 minitest.rb#L45: 123456789101112131415def self.autorun at_exit &#123; next if $! and not ($!.kind_of? SystemExit and $!.success?) exit_code = nil at_exit &#123; @@after_run.reverse_each(&amp;:call) exit exit_code || false &#125; exit_code = Minitest.run ARGV &#125; unless @@installed_at_exit @@installed_at_exit = trueend 它的主要作用是在程序进程结束前注入Minitest，并执行。 咦，at_exit是什么鬼？相信很多人很少见到它甚至是在阅读Minitest源码时第一次见到它。查询Ruby的文档，有下面这样的描述： Converts block to a Proc object (and therefore binds it at the point of call) and registers it for execution when the program exits. If multiple handlers are registered, they are executed in reverse order of registration. 它将代码块转为Proc对象，在程序退出时call这个Proc对象；如果注册了多个at_exit代码块，它会逆序执行。 我们写一个测试代码: 123456789101112# at_exit.rbputs "Into program."at_exit do puts "I'm executed at the end. start..." at_exit &#123; puts "I'm executed at last." &#125; puts "I'm executed at the end. end..."endat_exit &#123; puts "I'm executed after the 'Exit program'." &#125;puts "Exit program." 执行结果： 1234567$ ruby at_exit.rbInto program.Exit program.I'm executed after the 'Exit program'.I'm executed at the end. start...I'm executed at the end. end...I'm executed at last. 通过上面测试代码的执行结果，我们知道，Minitest.autorun会先后调用Minitest.run和Module变量@@after_run里的Proc对象。 它们又分别做了什么呢？ Minitest.run@@after_run保存的是在所有test执行结束后执行的代码块, 我们可以调用通知程序将测试完成通知给其他程序 或者发送邮件等等。 Minitest.run加载Minitest的插件；初始化reporter；执行测试，输出结果；最后返回test的执行结果给上面的exit_code Minitest.load_pluginsMinitest的插件都是以_plugin.rb结尾，放在minitest目录下。比如在Minitest中就有pride_plugin.rb，它就是Minitest默认的 插件。每个Minitest的插件都可以有(不是必须有)一个以该插件名命名的初始化方法plugin_[插件名]_init。 比如pride_plugin.rb的插件初始化方法为plugin_pride_init。Minitest的参数是用optparse解析的，它的插件也有一个支持optparse的方法: plugin_pride_options来做一些扩展。 Reporter这期间还会初始化CompositeReporter、SummaryReporter和ProgressReporter 3 个reporter，并赋值给Minitest的reporter属性，它用来展示测试的结果；它只在init_plugins中可用，在初始化完plugin后就被置为空了。所以如果想要在测试结束后调用reporter相关的操作，可以自己编写plugin（后续文章我们会涉及）。 上面说了3中Reporter。那么这三者有什么区别和联系呢？ Reporter的继承结构是这样的: AbstractReporter |__Reporter | |__ProgressReporter | |__StatisticsReporter | |__SummaryReporter |__CompositeReporter 所有的Reporter都是AbstractReporter子类，AbstractReporter定义了作为一个reporter应该有的方法，它们是start(在启动后开始记录测试结果),record(输出测试的结果；如果测试没有通过，会记录单个测试的结果),report(输出测试的概况),passed?(测试是否通过)。 Reporter默认将标准输出作为默认的输出。 ProgressReporter是一个很简单的reporter，他将测试用点打出. StatisticsReporter收集单个测试的统计信息，并没有任何IO相关的操作。如果想定制输出类型（比如CI，HTML等等），可以通过修改这个类的一些方法来做到。该类因为是统计测试结果的，所以它里面包含了测试的数量、assert的数量、开始时间、总时间、失败的测试、报错的测试和跳过的测试数量。 SummaryReporter是StatisticsReporter的子类，分别在测试开始时和测试结束的时候打印参数信息和标题、概况、失败的细节信息,类似： 1234567891011# At the beginningRun options: --seed 13908# Running:# At the endFinished in 0.003004s, 665.8359 runs/s, 665.8359 assertions/s.2 runs, 2 assertions, 0 failures, 0 errors, 1 skipsYou have skipped tests. Run with --verbose for details. 最后一句只有test中有skip的结果才会输出。 CompositeReporter可以调度多个repoter,将调用passed?、start、record、report的方法代理给所有的reporter。可以认为它是所有reporter的顶级代理类。 Minitest.__run在初始化完reporter和plugin后，开始跑测试。具体执行每个继承了Mintest::Test/Minitest::Spec/Minitest::Benchmark的子类。比如之前距离代码中的&#39;DogTest&#39;。 但是我们发现继承了Minitest::Test的子类只有以test_开头的方法执行了，魔法在哪里？我们继续往下看。 RunnableRunnable是什么鬼？它表示任何runnable的父类，任何它的子类都会自动注册到Runnable.runnables。为甚么它会自动注册呢？因为它有一个Ruby的钩子：inherited,它会在任何继承了该类的时候调用，让我们来看看它的代码： 1234def self.inherited klass self.runnables &lt;&lt; klass superend Runnable的run方法 runnable.run它可以按照用户输入的--name参数只跑符合对应正则的方法。里面定义了一个runnable_methods，它里面就会只保留满足子类定义的正则（不是用户输入的）的方法来一个个执行。比如Minitest::Test是Runnable的子类，它要求可执行方法是以test_开头；同样的Minitest::Benchmark要求方法以bench_开头. 保留的测试方法，会逐个执行，调用Minitest.run_one_method klass, method_name, reporter。它将调用Runnable的initialize方法，将method_name作为参数，作为要调用的方法名。 runnable.new.run以Minitest::Test为例，执行前它会先后调用before_setup、setup、after_setup几个钩子方法，然后调用上面作为参数传入的method_name。以实例代码为例，就是调用了DogTest.new. test_dog_should_spark，它里面就执行了具体的assert_方法，同样asert的数量就是在此时增加的。方法执行结束后，会调用before_teardown、teardown和after_teardown这几个钩子，你可以做一些你想在测试结束后想做的事情。 这里衍生出个问题：它是如何判断我是Skip还是报错的？ 如果正常执行，它会根据test_方法实际的assert_方法的数量增加asserts属性的值。那么如果报错了呢？比如抛了一个异常，如何保证程序不终止，而是继续执行其他的方法呢？ 答案是rescue，是的，对代码做保护,详见lib/minitest/test.rb:L204: 123456789def capture_exceptions # :nodoc: yieldrescue *PASSTHROUGH_EXCEPTIONS raiserescue Assertion =&gt; e self.failures &lt;&lt; erescue Exception =&gt; e self.failures &lt;&lt; UnexpectedError.new(e)end Asesrtion的继承关系如下图: Exception |__Assertion |__Skip |__UnexpectedError 如果某个方法是被skip了，那么它会抛出Skip异常，由Assertion捕获；如果方法执行代码错误，则被Exception捕获，并用UnexceptedError包一下。 总结通过以上的分析，我们现在可以把整个的调用层级重新整理下： Minitest.autorun Minitest.run(args) Minitest.__run(reporter, options) Runnable.runnables.each runnable.run(reporter, options) self.runnable_methods.each self.run_one_method(self, runnable_method, reporter) Minitest.run_one_method(klass, runnable_method) klass.new(runnable_method).run 用我们案例代码，表示为: Minitest.autorun Minitest.run(args) Minitest.__run(reporter, options) Runnable.runnables.each DogTest.run(reporter, options) [test_dog_should_spark].each DogTest.run_one_method(DogTest, test_dog_should_spark, reporter) Minitest.run_one_method(DogTest, test_dog_should_spark) DogTest.new(test_dog_should_spark).run 参考文献: Minitest github repository How minitest works The Minitest Cookbook]]></content>
      <categories>
        <category>Ruby</category>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
        <tag>Minitest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How Minitest Works Part 1]]></title>
    <url>%2F2016%2F02%2F20%2Fhow_minitest_works_part_1%2F</url>
    <content type="text"><![CDATA[注：本文以 minitest 的最新master 分支 baf6010 ，版本为5.8.4为基础。所有代码可以在minitest_source 找到. 一个简单的测试1234567891011121314151617181920212223242526# 代码 1.1# dog.rbclass Dog def spark 'Spark!' endend# dog_test.rbrequire 'minitest/autorun'require_relative './dog'class DogTest &lt; Minitest::Test def setup @dog = Dog.new end def test_dog_should_spark assert_respond_to @dog, :spark assert_equal 'Spark!', @dog.spark end def ordiary_method assert true endend 如何执行测试呢？ 123456789$ ruby dog_test.rbRun options: --seed 24057# Running:.Finished in 0.001039s, 962.5723 runs/s, 1925.1446 assertions/s.1 runs, 2 assertions, 0 failures, 0 errors, 0 skips 如果我们把require &#39;minitest/autorun&#39; 这一行注释掉，然后再执行ruby dog_test.rb，程序是否还正常执行呢？让我们执行下： 1$ ruby dog_test.rb 这一次什么都没有输出。Why? 这一行有什么魔法呢？为什么有了它之后，可以执行测试代码， 还可以输出测试结果？ 那我们看一下Minitest 的代码，就可以了然了。 如果列位有兴趣，可以继续往下看。 Minitest 的工作原理Minitest 主要代码的结构minitest │ ├── assertions.rb # 定义 assert_*方法 │ ├── autorun.rb # 自动执行测试 │ ├── benchmark.rb # Benchmark 相关方法 │ ├── expectations.rb # 使用`must` 代替`assert` │ ├── hell.rb # 并行执行测试 │ ├── mock.rb # Mock 的 expect 相关实现 │ ├── parallel.rb # 多线程执行测试 │ ├── pride.rb # Report 的一种，以颜色展示结果 │ ├── pride_plugin.rb # Pride plugin 的具体实现 │ ├── spec.rb # spec 实现，本质上是一种语法糖 │ ├── test.rb # Minitest 具体执行部分 │ └── unit.rb # test/unit 的 Minitest 实现 └── minitest.rb # Minitest 的抽象层实现 Minitest 的代码行数统计数据: ------------------------------------------------------------------------------- Language files blank comment code ------------------------------------------------------------------------------- Ruby 13 646 1061 1593 ------------------------------------------------------------------------------- SUM: 13 646 1061 1593 ------------------------------------------------------------------------------- 以上是使用cloc 统计得出。 Minitest 用了不到1600行的代码，集扩展性强、兼容性好、可读性强于一身。 从上面的代码，我们可以得到以下结论： 测试文件需要加载minitest/autorun 文件 测试类要继承自Minitest::Test 或者其子类 测试方法需要以test_ 开头。(可以看到上面只有2个 assert 执行了，里面其实有3个 assert 语句) 测试结束会输出执行的结果（是否通过、失败、跳过以及执行时间和速度） Minitest 有钩子的存在(比如setup) 那么我们会有以下疑问： minitest/autorun 到底做了什么？ 继承Minitest::Test的目的何在，它内部有什么特殊方法？ 为什么以test_ 开头的方法执行了，而普通的方法没有执行？里面肯定有一个&quot;惊天的阴谋&quot; Minitest 的结果是何时，如何打出来的？ Minitest有哪些钩子，调用顺序几何？ 以上问题，我们在下一节讨论。 参考文献: Minitest github repository How minitest works The Minitest Cookbook]]></content>
      <categories>
        <category>Ruby</category>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
        <tag>Minitest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Introduction to Minitest]]></title>
    <url>%2F2016%2F02%2F19%2Fintroduction_to_minitest%2F</url>
    <content type="text"><![CDATA[写在前面之前几乎不写测试，嗯，我属于那一类人。很多时候是自己先写一个功能，然后输入一些简单案例跑一跑，如果过了，那么就……过了，可以放心继续下面的工作了。直到维护一个个前辈们的项目，而且功能不断添加，添加。问题接着出现了：按下葫芦浮起瓢，改了一个 Bug，引出了其它的 Bug。代码在修改过程中，越来越心里没底。更别说重构了。。。。 为什么要写测试？现在的 Coder 应该都有这样的共识：写测试总比不写要好。为什么呢？因为它可以给我们带来以下好处： 便于整理编码思路 我们写代码，实际上使用计算机的语言来解决我们现实中的问题，方便我们的生活和工作。事实上，很不幸，现实比书本上描述地复杂得多。不是每个人都可以很快在头脑里对现实问题迅速抽象出来而且恰到好处的。 在写具体写代码之前，如果先按接口写测试，可以保证接口的稳定性（设计好接口，也可以方便其它人并行开发），还可以发现设计的一些缺陷（比如设计不合理、复杂度高）。 思路清晰了，那么我们代码的结构也会清晰。不仅自己看着舒服，别人维护也容易。 减少隐藏的 Bug，提高代码质量 其实这个本质上是一个覆盖率的问题。如果测试案例覆盖了几乎所有的情况（即使这个做到是有些难度的），在开发时期，很多 Bug 就会被早早地发现了。总比被别人报告 Bug 要好很多。 减少重复机械操作 在开发一个功能时，如果功能是非常简单的，类似输入abc，输出 ABC 这样大小写转换的操作，写完功能之后，简单测试下还可以。如果某个功能写好后，需要一系列的输入和操作，重复起来，那就是一个灾难。 方便重构 在看项目中别人写的代码的时候，有时会不自主的叹气：写得什么破代码；在看大牛的代码的时候，会惊叹：写得这么如此巧妙！妙哉！妙哉！不管代码写得如何，很多已经经历过很多次的迭代、重构。好的东西总是建立在巨人的肩膀上的。 重构时，如果面对的是没有任何测试案例的代码，我们肯定在重构的过程中会战战兢兢，唯恐踩到某个雷，甚至会不知何时给自己埋下一个雷。地雷，有一天会爆的。 增加对项目的理解 测试需要开发对业务逻辑有相当的理解。代码建立在你对要实现什么的基础上，其次是如何实现。整个数据的流程在伴随着测试案例的增加过程中，对系统的 来龙去脉也会更加熟悉。所谓专家，不止是技术上的牛，在业务上也是牛。如何成为大牛？千里之行始于足下。 兰尼斯特有债必还 写测试是必要的吗？如果某个项目只有个人开发，这个项目只是个一锤子买卖或者功能十分简单，可以不写测试。现实中的项目很多都是多人合作才能完成的，曾经工作的公司一个完整的开发流程是这样的： 12345678design=&gt;start: 概要设计/详细设计deliver=&gt;end: 交付dev=&gt;operation: 开发test=&gt;operation: 测试integrate=&gt;operation: 集成deploy=&gt;operation： 上线degign-&gt;dev-&gt;integrate-&gt;test-&gt;deliver-&gt;deploy 如果在测试阶段发现问题，需要开发确认，再找集成。如果线上有问题，需要反馈给交付，再由交付找产品经理，再由产品经理反馈给开发；之后流程再从开发开始走。不仅耗费了大量的时间，也消耗了好多 Money。 现在越来越多的开源项目在 Github 上被开放出来，如果某个项目没有单元测试的话，几乎没人用他/她的代码。为何？代码不是我写的，万一出了问题，解决 Bug 又是一堆坑。与其填别人的坑，不如自己搞。 如果你是一个勤奋的人，那么你可以不写任何测试。如果你是或者想成为聪明的懒人，那么写测试吧。写测试可以在别人问你这次代码靠谱吗？我们可以比较有底气地回答：是的！ 为什么很多 Coder 不写测试？是啊，为什么不写测试呢？ 任务重，时间紧？不想写？我对自己的代码很有信心，完美无 Bug？ 任务重，时间紧：在评估项目开发周期时，把测试时间一并考虑。为了速度，牺牲效率得不偿失。 不想写：嗯。继续不靠谱下去？ 完美无Bug：是人就会犯错。写测试会让用户更加相信，说这句话不是自负，而是自信。 本系列是关于什么的测试的内容有很多：单元测试、性能测试、集成测试等等。本系列是使用Minitest 执行测试的 CookBook。 每篇文章着力于某一方面， 一是为了自我总结，二是希望可以给其它人一些帮助。 初次写，难免有很多不足之处，望不吝指出。]]></content>
      <categories>
        <category>Ruby</category>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
        <tag>Minitest</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Difference Of XX-like Methods In Ruby]]></title>
    <url>%2F2015%2F10%2F23%2Fwhat-is-the-difference-in-to_s-to_str_inspect%2F</url>
    <content type="text"><![CDATA[今日打开ruby-china发现Hooopo分享的一篇文章，感觉非常好，故记录之。 to_s和inspect的区别class David def to_s &quot;to_s&quot; end def inspect &quot;inspect&quot; endend david = David.new #inspectputs david #to_sprint david #to_sp david #inspect 结论: 1. puts obj =&gt; puts obj.to_s 2. p obj =&gt; puts obj.inspect to_s和to_str的区别to_s和to_str在大部分时候是相同的，几乎每个对象都有to_s方法，(why?因为所有对象都继承自Object类)，但是不是每个对象都有to_str方法，这个方法只有在对象有string-like的行为时才定义。 但是并不是所有和字符串相关的方法都会调用to_str： class David def to_str &quot;to_str&quot; end def to_s &quot;to_s&quot; end end david = David.new #to_s &quot;hello, #{david}&quot; #hello,to_s [&apos;hello&apos;, david].join(&quot; &quot;) #heloo to_str &quot;hello &quot; + david #hello to_str File.join(&quot;hello&quot;, david) #hello/to_str 根据上面的结果得出：在字符串内插和inspect的时候会调用to_s，而在Array#join,File#join,String#+的时候优先调用to_str 其它类XX-like的方法还有to_i vs to_int; to_a vs to_ary]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Shortcuts]]></title>
    <url>%2F2015%2F08%2F31%2Fmac-shortcut%2F</url>
    <content type="text"><![CDATA[当前 App 切换窗口向后切换窗口： Ctrl + Tab；Cmd + Shift + ] 向前切换窗口： Ctrl + Shift + Tab；Cmd + Shift + []]></content>
      <categories>
        <category>Tech</category>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Shortcuts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令之du]]></title>
    <url>%2F2015%2F08%2F30%2Flinux-du%2F</url>
    <content type="text"><![CDATA[du 的基本含义和参数du 用来显示文件的磁盘使用情况。 -a 根据目录层级显示所有的文件。 -c 显示总的大小 -d [depth] 特定深度的所有文件大小 -h 以 Human 可读的格式输出，自动带 B/KB/MB/GB/TB/PB -I mask 根据执行的权限忽略(Ignore) 文件和目录。 -gkm 分别按 GB、KB 和 MB 为单位显示文件大小。 -s 只显示每个特定文件的总和`-d 0`等效。 举个栗子 显示总的文件大小 du -s 显示2层的文件大小 du -h -d 2 显示/var/demo 文件的统计信息 du -ah /var/demo du 和 df 的区别du 和df 只有一个字母之差。du是面向文件的命令，只计算被文件占用的空间。不计算文件系统metadata 占用的空间。df则是基于文件系统总体来计算，通过文件系统中未分配空间来确定系统中已经分配空间的大小。df命令可以获取硬盘占用了多少空间，还剩下多少空间，它也可以显示所有文件系统对节点和磁盘块的使用情况。 df 的参数列表： -a 全部文件系统列表 -h 以 Human 友好的方式显示 -H 和-h 相似，但是大小进制为1000，而不是1024（很多 ISP、磁盘供应商都这么来） -l 只显示 local 的文件系统 -t 列出文件系统类型(文件、目录，块等), Linux上为 T。]]></content>
      <categories>
        <category>Tech</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Bash</tag>
        <tag>du</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令之bg、fg、jobs 和 Ctrl-Z, Ctrl-C]]></title>
    <url>%2F2015%2F08%2F30%2Flinux-fg-bg-jobs%2F</url>
    <content type="text"><![CDATA[Ctrl-C, Ctrl-D, Ctrl-Z 的区别在 Linux 的日常使用中，Ctrl+C 应该是用的最多的，他的用途是终止当前进程。那么Ctrl+Z 和Ctrl+D 又有什么用途么？ Ctrl+Z 表示暂停一个进程，Ctrl+D 表示文件结束符(EOF)。 假如我们有一个会长期执行的程序，如果它原来就是在前台运行的话(bundle exec sidekiq)，如果使用Ctrl+Z，会在终端输出susppended bundle exec sidekiq。当然 Ctrl+D 是不起作用的，因为它的应用场景不是这样的。被暂停的进程可以使用ps -ef | grep [进程名]看到。Ctrl+D 更多地在文件操作上，每个文件都有对应的标志(EOF)表示文件的结束。 fg、bg 和 jobsfg %[job num]把一个任务从后台拿到前台来处理.foregroundbg %[job num] 把一个任务从前台拿到后台去执行。background 那么 job num 怎么看呢？ 使用jobs -l, 最左侧的数字即是。比如有一个后台进程job id 为2，那么执行fg %2即可。 如何将暂停的进程在后台继续执行呢？执行bg %[job num] 就可以了。如果有多个的话，使用bg(没有 job num)。]]></content>
      <categories>
        <category>Tech</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>bg</tag>
        <tag>fg</tag>
        <tag>jobs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令之Find]]></title>
    <url>%2F2015%2F08%2F30%2Flinux-find%2F</url>
    <content type="text"><![CDATA[FindFind的基本用法： find [path] -option [-print] [-exec -ok command {} \;] -print将匹配的文件输出到标准输出。 -name filename #查找名为filename的文件 -perm #按执行权限来查找 -user username #按文件属主来查找 -group groupname #按组来查找 -mtime -n +n #按文件更改时间来查找文件，-n指n天以内，+n指n天以前 -atime -n +n #按文件访问时间来查GIN: 0px&quot;&gt; -ctime -n +n #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 -nogroup #查无有效属组的文件，即文件的属组在/etc/groups中不存在 -nouser #查无有效属主的文件，即文件的属主在/etc/passwd中不存 -newer f1 !f2 找文件，-n指n天以内，+n指n天以前 -ctime -n +n #按文件创建时间来查找文件，-n指n天以内，+n指n天以前 -nogroup #查无有效属组的文件，即文件的属组在/etc/groups中不存在 -nouser #查无有效属主的文件，即文件的属主在/etc/passwd中不存 -newer f1 !f2 #查更改时间比f1新但比f2旧的文件 -type b/d/c/p/l/f #查是块设备、目录、字符设备、管道、符号链接、普通文件 -size n[c] #查长度为n块[或n字节]的文件 -depth #使查找在进入子目录前先行查找完本目录 -fstype #查更改时间比f1新但比f2旧的文件 -type b/d/c/p/l/f #查是块设备、目录、字符设备、管道、符号链接、普通文件 -size n[c] #查长度为n块[或n字节]的文件 -depth #使查找在进入子目录前先行查找完本目录 -fstype #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到 -mount #查文件时不跨越文件系统mount点 -follow #如果遇到符号链接文件，就跟踪链接所指的文件 -cpio %; #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到 -mount #查文件时不跨越文件系统mount点 -follow #如果遇到符号链接文件，就跟踪链接所指的文件 -cpio #对匹配的文件使用cpio命令，将他们备份到磁带设备中 -prune #忽略某个目录&quot; Demofind -name april* 在当前目录下查找以april开始的文件 find -name april* fprint file 在当前目录下查找以april开始的文件，并把结果输出到file中 find -name ap* -o -name may* 查找以ap或may开头的文件 find /mnt -name tom.txt -ftype vfat 在/mnt下查找名称为tom.txt且文件系统类型为vfat的文件 find /mnt -name t.txt ! -ftype vfat 在/mnt下查找名称为tom.txt且文件系统类型不为vfat的文件 find /tmp -name wa* -type l 在/tmp下查找名为wa开头且类型为符号链接的文件 find /home -mtime -2 在/home下查最近两天内改动过的文件 find /home -atime -1 查1天之内被存取过的文件 find /home -mmin +60 在/home下查60分钟前改动过的文件 find /home -amin +30 查最近30分钟前被存取过的文件 find /home -newer tmp.txt 在/home下查更新时间比tmp.txt近的文件或目录 find /home -anewer tmp.txt 在/home下查存取时间比tmp.txt近的文件或目录 find /home -used -2 列出文件或目录被改动过之后，在2日内被存取过的文件或目录 find /home -user cnscn 列出/home目录内属于用户cnscn的文件或目录 find /home -uid +501 列出/home目录内用户的识别码大于501的文件或目录 find /home -group cnscn 列出/home内组为cnscn的文件或目录 find /home -gid 501 列出/home内组id为501的文件或目录 find /home -nouser 列出/home内不属于本地用户的文件或目录 find /home -nogroup 列出/home内不属于本地组的文件或目录 find /home -name tmp.txt -maxdepth 4 列出/home内的tmp.txt 查时深度最多为3层 find /home -name tmp.txt -mindepth 3 从第2层开始查 find /home -empty 查找大小为0的文件或空目录 find /home -size +512k 查大于512k的文件 find /home -size -512k 查小于512k的文件 find /home -links +2 查硬连接数大于2的文件或目录 find /home -perm 0700 查权限为700的文件或目录 find /tmp -name tmp.txt -exec cat {} \; find /tmp -name tmp.txt -ok rm {} \; find / -amin -10 # 查找在系统中最后10分钟访问的文件 find / -atime -2 # 查找在系统中最后48小时访问的文件 find / -empty # 查找在系统中为空的文件或者文件夹 find / -group cat # 查找在系统中属于 groupcat的文件 find / -mmin -5 # 查找在系统中最后5分钟里修改过的文件 find / -mtime -1 #查找在系统中最后24小时里修改过的文件 find / -nouser #查找在系统中属于作废用户的文件 find / -user fred #查找在系统中属于FRED这个用户的文件]]></content>
      <categories>
        <category>Tech</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令之netstat, lsof]]></title>
    <url>%2F2015%2F08%2F30%2Flinux-netstat-lsof%2F</url>
    <content type="text"><![CDATA[netstatNetstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。 -a (all)显示所有选项，默认不显示LISTEN相关 -t (tcp)仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化成数字。 -l 仅列出有在 Listen (监听) 的服務状态 -p 显示建立相关链接的程序名 -r 显示路由信息，路由表 -e 显示扩展信息，例如uid等 -s 按各个协议进行统计 -c 每隔一个固定时间，执行该netstat命令。 举个例子lsoflsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。 不过 lsof 一般是以 Root 权限运行的。 举个例子 查看某个进程打开文件数量 ls -l /proc/[pid]/fd | wc -l [Linux] lsof -p [pid] | wc -l [Mac] 查看谁在使用某个文件 lsof /var/demo.txt 恢复已删除文件 当Linux计算机受到入侵时，常见的情况是日志文件被删除，以掩盖攻击者的踪迹。管理错误也可能导致意外删除重要的文件，比如在清理旧日志时，意外地删除了数据库的活动事务日志。有时可以通过lsof来恢复这些文件。 当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。 在/proc 目录下，其中包含了反映内核和进程树的各种文件。/proc目录挂载的是在内存中所映射的一块区域，所以这些文件和目录并不存在于磁盘中，因此当我们对这些文件进行读取和写入时，实际上是在从内存中获取相关信息。大多数与 lsof 相关的信息都存储于以进程的 PID 命名的目录中，即 /proc/1234 中包含的是 PID 为 1234 的进程的信息。每个进程目录中存在着各种文件，它们可以使得应用程序简单地了解进程的内存空间、文件描述符列表、指向磁盘上的文件的符号链接和其他系统信息。lsof 程序使用该信息和其他关于内核内部状态的信息来产生其输出。所以lsof 可以显示进程的文件描述符和相关的文件名等信息。也就是我们通过访问进程的文件描述符可以找到该文件的相关信息。 当系统中的某个文件被意外地删除了，只要这个时候系统中还有进程正在访问该文件，那么我们就可以通过lsof从/proc目录下恢复该文件的内容。 假如由于误操作将/var/log/messages文件删除掉了，那么这时要将/var/log/messages文件恢复的方法如下： 首先使用lsof来查看当前是否有进程打开/var/logmessages文件，如下： lsof |grep /var/log/messages syslogd 1283 root 2w REG 3,3 5381017 1773647 /var/log/messages (deleted) 从上面的信息可以看到 PID 1283（syslogd）打开文件的文件描述符为 2。同时还可以看到/var/log/messages已经标记被删除了。因此我们可以在 /proc/1283/fd/2 （fd下的每个以数字命名的文件表示进程对应的文件描述符）中查看相应的信息，如下： head -n 10 /proc/1283/fd/2 cat /proc/1283/fd/2 &gt; ~/restored_messages 显示开启文件abc.txt的进程 lsof abc.txt 显示22端口现在被什么程序占用 lsof -i 22 显示abc进程现在正在打开的文件 lsof -c abc 显示归属gid的进程情况 lsof -g gid 显示指定目录下被进程开启的文件，不会遍历该目录下的所有子目录 lsof +d /usr/local/ 显示指定目录下被进程开启的文件，会遍历该目录下得所有子目录 lsof +D /usr/local/ 显示使用fd为4的进程 lsof -d 4 不进行域名解析，缺省会进行，比较慢 lsof -n 查看进程号为12的进程打开了哪些文件 lsof -p 12 让lsof重复执行，缺省15s刷新 lsof +|-r [t] -r, lsof会永远执行，直到被中断 +r, lsof会一直执行，直到没可显示的内容 Example： 查看目前ftp连接的情况：lsof -i tcp@test.com:ftp -r 列出打开文件的大小，如果大小为0，则空 lsof -s 以UID，列出打开的文件 lsof -u username]]></content>
      <categories>
        <category>Tech</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>netstat</tag>
        <tag>lsof</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再谈Ruby的异常处理(学习笔记)]]></title>
    <url>%2F2015%2F02%2F15%2Flet-us-talk-about-exception-again%2F</url>
    <content type="text"><![CDATA[Throw &amp; Catchthrow和catch是Kernel中的方法，它们定义了一种可以从代码块中，穿过多次的代码级数，与catch一同定义的代码块退出的功能。 Throw和Catch与Break的区别：除了都可以从循环中退出外，前者还可以沿着调用栈向上传播，使一个位于调用方法中的代码块退出。 throw和catch与raise和recue还是不同的。前者只是进行退出，却不抛出异常；后者是抛出异常的。它们有着相似的行为：沿着调用栈向上传递。throw和catch属于控制结构，而不属于异常结构。 12345678910111213def routine(n) puts n throw :done if n &lt;= 0 routine(n-1)endcatch(:done) &#123; routine(3) &#125;a = ('a'..'c').to_a catch :hello do for ele in a do throw :hello if ele == 'c' endend 上面的写法是正确的，如果将catch和throw放到一层，则会报syntax error, unexpected $end, expecting keyword_end 如果catch的符号实参与throw的符号实参是不一致的，那么会在运行时报ArgumentError 备注1 异常。 catch和throw可以接受字符串和Symbol，用作符号实参。在处理字符串的时候，内部会自动转换成符号实参。 如果没有throw被调用，那么对应的catch调用就会返回代码块的最后一个值；如果throw被调用，默认是返回nil的。如何不返回nil呢？添加参数。可以对throw添加第二个参数，用作返回值。这样我们可以根据catch的返回值来处理不同的情况，区分正常返回和异常返回。 在实际情况下，throw和catch并不是很常用，如果在同一个方法中同时包含这2个关键字，那么需要考虑重构代码了。将catch放到单独的方法中，并用return取代throw。 Exceptionthrow并不是抛出异常的关键字，所以throw不是用于处理异常的，只是用于控制的关键字。下面主要设计Exception的处理。 那么异常在神马情况下出现呢？异常出现的情况比较多。比如：使用一个未定义的对象；内存本身已经不足了，而继续申请内存；传递的参数类型不对。这些都会导致异常的产生。 异常发生了之后，异常会传递到最上层或到达异常处理代码，由异常处理代码对异常进行处理或简单粗暴地停止程序的运行，在最外层将异常抛出。 异常类继承关系图: &lt;img class=&quot;bordered&quot; alt=&quot;screenshot&quot; src=&quot;/img/posts/ruby_exceptions_hierachy_2.png&quot;style=&quot;margin-top:20px; width:50%; height:50%&quot; /&gt; 大部分的异常子类都是继承自StandardError这个异常类，典型的ruby程序会去尝试去处理它们，而其他异常类则一般不会去尝试处理，因为其它异常比较难于恢复。 异常对象的方法Exception 类定义了2个返回异常细节的方法:message和backtrace。message将调用产生的异常信息以人们易于阅读的形式展现出来。message的主要目的是为了给程序员为问题的诊断提供帮助，而不是为了所谓的简单展示错误信息而已。backtrace方法返回的是一个包含错误调用栈的数组。数组的顺序依次为：发生异常的代码位置;发生异常的代码调用方法位置; 发生异常的代码调用方法的调用方法位置...以此类推。raise会自动设置调用栈的轨迹，如果要自己创建Exception,可以设置set_backtrace来自定义调用栈轨迹,当然这个方法的参数是一个数组。这个数组是任意的吗？当然不是，它要满足一定的形式：&quot;filename:LineNo:[in method]&quot;。 12345678910111213141516171819def a() raise "It is an exception"enddef b a()endbegin b() rescue Exception =&gt; e puts e.message puts e.backtrace.join("\n")end\_\_END\_\_It is an exception(irb):32:in `a'(irb):36:in `b'(irb):40:in `irb_binding' 异常的结果可以使用$!访问到，如果异常返回为nil，那么异常为RuntimeError，或者说如果只是简单的raise(msg)，那么抛出的异常是RuntimeError。如果在rescue的时候，指定了异常的变量(比如上面的e)，那么在rescue代码块后是可以使用e来继续访问异常的信息，而$!就只会是nil了。 raise的参数还可以是exception，可选第二个参数为异常的信息,第三个为异常调用栈。raise与fail同义，但是我们平常都是使用raise的。 12raise "Failed to create socket"raise ArgumentError, "No parameters", caller rescue本身并不是一个语句，而只是简单的一个方法。recue本身是附着在其它代码块上的，最常见的就是begin..end代码块了。begin..end代码块隔离出一部分代码，并将其中的一部分代码交给rescue进行处理。 rescue后面的异常类可以指定多个，recue也可以调用多次： 123456begin ...rescue RuntimeError,ArgumentError =&gt; e，recue Exception =&gt; e ...end retry可以在recue调用完毕后再次重新从代码块开始进行启动。retry适用于值得尝试的异常，比如网咯延迟、服务器宕机；而对于明确不可retry的异常则使用它就没有任何意义了。比如：ArgumentError,ZeroDevisonError。 123456789101112131415require "open-uri"tries = 0begin tries += 1; open('http://www.google.com.hk')rescue OpenURI::HTTPError =&gt; e puts e.message if (tries &lt; 4) sleep(2 ** tries) retry endensure puts "I have tried for #&#123;tries&#125; times."end 如果学习过Java，那么我们就会发现与finally对应的一个方法:ensure。rescue用于执行某些资源的释放操作，比如数据库连接的关闭，文件的关闭等等。rescue中的代码可以包含return语句，这会中断异常的传递，也会修改整个方法的返回值；如果ensure中没有显式调用return那么对整个方法的返回值是没有影响的，虽然ruby中最后一行代码的返回值为方法的返回值。 在ensure前面还可以有else方法。它是何许人也？它的作用是如果没有异常发生，那么就else了。也就是如果没有发生异常就执行else里面的句子。它一般不是很常用，除非要处理有异常或没有异常之间的区别处理。else与ensure还有一些区别：else不一定是必然执行的(即使没有异常发生)，ensure是必然执行的。else可以被break、next、return等语句打断跳过。 综上，一个异常的基本结构为: 12345678910begin raise 'A test exception.'rescue Exception =&gt; e puts e.message puts e.backtrace.inspectelse # other exceptionensure # always executedend Attension：ensure不止是限于begin..end块，还可以用于def methodend、class、module等的定义中。 备注1: 双飞燕此处是错误的，双飞燕中写的是NameError,根据1.9.3的api，这里应该是ArgumentError。]]></content>
      <categories>
        <category>Tech</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bind,live,delegate还是on ？]]></title>
    <url>%2F2015%2F02%2F14%2Fjquery-event%2F</url>
    <content type="text"><![CDATA[转自 最近写项目页面用了不少jquery的东西，过程当中对jquery的事件绑定方法有些疑惑，经过学习各种资料，现在终于明白不少。恰巧有同学和我有一样的疑惑，我正好梳理一下思路，写下本文。如果你也对jquery中眼花缭乱的事件绑定方法不太明白的话，你来对地方了。 继续阅读前，我认为你需要先知道以下几点基础知识： dom对象是树形结构的 dom中的事件会从触发事件的目标节点开始逐级向上冒泡 每当我们想给某个元素绑定事件的时候，第一个想到的方法是bind，我们就先来说说bind。 bind的作用是给具体的某个元素绑定事件，比如 $(&apos;button&apos;).bind(&apos;click&apos;,function(){}); 给所有的button元素添加了点击事件处理方法。这似乎已经可以完成大部分的事件绑定任务了，然而有一个问题它无法解决–如果某一元素是新添加的怎么办？bind将事件处理函数绑定在了具体的元素上，而新添加的元素身上是没有被绑定处理函数的。也就是说，如果执行完上面的代码后再动态添加一个button元素，新添加的这个button元素是没有被绑定事件处理函数的。 于是，live出现了。对于刚开始接触jquery的人来说，live是一个很神奇的事件绑定方法，无论某一元素已经存在还是将来会被添加到页面中，live都能将事件绑定到它身上。 真的很神奇吗？其实它的原理很简单，那就是“事件委派”。 什么是事件委派？举个简单的例子。 假如有一个表格，我们要动态增删里面的行元素，同时想给每一个行元素绑定一个点击事件。给具体的tr元素绑定事件是不现实的，因为它们总是不断变化的。于是我们可以换个思路，为什么一定要给tr元素绑定事件呢？ 我们可以把事件绑定到table元素上，发生在table的子元素身上的点击事件都会冒泡到table元素上，在这里可以做一个比较，如果点击事件的目标是tr元素，执行绑定的函数就好了。这就是事件委派，委派某个元素处理子元素触发的事件。 $(&apos;table tr&apos;).live(&apos;click&apos;,function(){}); 这样，就可以给tr元素绑定点击事件，无论它是已经存在的，还是将来被添加的。 那么，执行完上面的代码，事件确实被绑定在table元素上了吗？不！ 现实中，我们要动态添加的元素指不定在dom树的哪一层。为了让所有新添加的元素都能触发预先绑定的事件处理函数，jquery将事件处理函数委派在了dom树的根元素，也就是document元素，身上。这样一来，无论新添加的元素位于dom树的哪个层级，它触发的事件总会冒泡到根元素上。在这里，可以做一个判断，如果事件触发目标是想要绑定事件处理函数的那个元素，执行该函数就好了。 这看起来很美好，似乎我们完全可以放弃bind，在任何情况下都可以使用live了。不过，等等，如果真是这样的话，后边的delegate就没有用武之地了。 live方法的好处不言而喻，然而它也有弊端。假设我们还是要给tr元素绑定点击事件。如果页面中有一千个元素，只有10个是tr元素，会是什么情况？那990个不相干的元素触发的事件也会冒泡到根元素上，在那里做一次比较，无形当中就会带来性能的消耗。这可真是宁可错杀一千，也不放过一个啊。 显然，live并没有看上去的那么美好，于是delegate闪亮全场了。 我们要给tr元素绑定事件，离它最近的父元素就是table了。既然如此，我们为什么还要不辞辛苦地把事件绑定在document元素上，而不是绑在table身上呢？delegate就是干这个活的。 $(&apos;table&apos;).delegate(&apos;tr&apos;,&apos;click&apos;,function(){}); 上面的代码将点击事件委派在table元素上，其下的tr元素身上的点击事件会触发处理函数。 到目前为此，我们认识了三个和事件绑定有关的方法。他们的使用方法和使用时机你都记住了吗？好吧，我是费了点功夫才记住并区分它们的。 绑定事件居然有三个方法，太可怕了，要是只有一个就好了。其实，jquery的作者也是这么想的。从1.7版本开始，jquery添加了一个新的事件绑定方法–on–来代替之前提到的所有方法。这真是一个令人欣喜的消息。 on的使用方法很简单，如果你没有指定后代元素，那么就是简单的事件绑定，类似于bind。比如 $(&apos;tr&apos;).on(&apos;click&apos;,function(){}); 会把点击事件绑定在tr身上，如果执行完代码后新添加了一个tr元素，那它身上自然是没有事件处理函数的。 那怎么做事件委派呢？是这个样子的 $(&apos;table&apos;).on(&apos;click&apos;,&apos;tr&apos;,function(){}); 事件委派到了table元素身上，它的tr子元素身上的点击事件会触发事件处理函数。 好了，从今天起，忘掉bind、live和delegate吧，on才是你居家旅行，必备的神器！据说，只是据说，在新版本中，就算你调用bind、live或delegate，它内部都会调用on。既然如此，我们为什么不自己使用on呢？]]></content>
      <categories>
        <category>Tech</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>bind</tag>
        <tag>live</tag>
        <tag>delegate</tag>
        <tag>on</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery 获取兄弟节点]]></title>
    <url>%2F2015%2F02%2F14%2Fjquery-selector-find-siblings%2F</url>
    <content type="text"><![CDATA[之前对 js 了解不多，看得懂却不会怎么用，最近正好项目中用到，需要用 js获取一些数据，于是搜索之，记录之，以便查阅。 $(selector).siblings() 当前元素所有的兄弟节点 $(selector).prev() 当前元素前一个兄弟节点 $(selector).prevaAll() 当前元素之前所有的兄弟节点 $(selector).next() 当前元素之后第一个兄弟节点 $(selector).nextAll() 当前元素之后所有的兄弟节点]]></content>
      <categories>
        <category>Tech</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>sibling node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jquery 选择器总结]]></title>
    <url>%2F2015%2F02%2F14%2Fjqurty-selector%2F</url>
    <content type="text"><![CDATA[Jquery选择器简介 (1) Jquery中的选择器完全继承了CSS的风格，利用Jquery选择器，可以非常便捷和快速的找出特定的Dom元素，然后为他们添加相应的行为，而无需担心浏览器是否支持这一选择器，学会使用选择器是学习Jqeury的基础，Jquery的行为规则都必须在获取到元素后才能生效。 jquery选择器的优势 (1) 简洁的写法，$()函数 (2)支持CSS1到CSS3选择器 (3)完善的处理机制 下面我们主要来说一下Jquery中所有的选择器 基本选择器：通过元素id,class和标签名等来查找Dom元素 1). $(&quot;#id&quot;) 根据给定的ID匹配一个元素，返回单个元素 $(&quot;#name&quot;)选取Id为name的元素 2). $(&quot;.class&quot;) 根据给定的类名匹配元素 返回集合元素 $(&quot;.class&quot;)选取所有class为class的元素 3). $(&quot;element&quot;) 根据给定的元素名匹配元素，返回集合元素 $(&quot;input&quot;)选取所有的input元素 4). $(&quot;*&quot;) 匹配所有的元素，返回集合元素，$(&quot;*&quot;)选取所有的元素 5). $(&quot;selector1,selector2,...,selectorN&quot;) 将每一个选择器匹配到的元素合并后返回集合元素， $(&quot;div,span,p.myClass&quot;)选取所有&lt;div&gt;,&lt;span&gt;和拥有class为myClass的&lt;p&gt;标签的一组元素 层次选择器：如果想通过Dom元素之间的层次关系来获取特定元素，例如后代元素，子元素，相邻元素和同辈元素 1). $(&quot;ancestor descendant&quot;) 获得ancestor元素里面的所有descendant(后代)元素，$(&quot;div span&quot;)选取&lt;div&gt;里的所有的&lt;span&gt;元素 2). $(&quot;parent&gt;child&quot;) 选取parent元素下的child(子)元素，返回集合元素 $(&quot;div span&quot;)选取&lt;div&gt;元素下元素名为&lt;span&gt;的子元素 注解：和$(&quot;ancestor descendant&quot;)有区别，$(&quot;ancestor descendant&quot;)选择的是后代元素 3). $(&quot;prev+next&quot;) 选取紧接在prev元素后的next元素，返回集合元素，$(&quot;.one+div&quot;)选取class为one的下一个&lt;div&gt;同辈元素 4). $(&quot;prev~siblings&quot;) 选取prev元素之后的所有siblings元素，$(&quot;#two~div&quot;)选取Id为two的元素后面的所有&lt;div&gt;同辈元素 注解:可以使用next()方法来替代$(&#39;prev+next&#39;)选择器 $(&quot;.one&quot;).next(&quot;div&quot;);可以使用nextAll()方法来替代$(&quot;prev~siblings&quot;)选择器 $(&quot;#two&quot;).nextAll(div) (3)过滤选择器：主要通过特定的过滤规则来筛选出所需要的Dom元素，按照不同的过滤规则，过滤选择器可以分为基本过滤，内容过滤，可见性过滤，属性过滤，子元素过滤和表单对象属性过滤选择器 1). 基本过滤选择器1). $(&quot;:first&quot;) 选取第一个元素，$(&quot;div:first&quot;)选取所有&lt;div&gt;元素中第一个&lt;div&gt;元素。 2). $(&quot;:last&quot;)选取最后一个元素，$(&quot;div:last&quot;)选取所有&lt;div&gt;元素中最后一个&lt;div&gt;元素。 3). $(&quot;:not(selector)&quot;)去除所有与给定选择器匹配的元素，$(&quot;input:not(.myClass)&quot;)选取class不是myClass的&lt;input&gt;元素。 4). $(&quot;:even&quot;)选取索引是偶数的所有元素，索引从0开始，$(&quot;input:even&quot;)选取索引是偶数的&lt;input&gt;元素 5). $(&quot;:odd&quot;)选取索引是奇数的所有元素，索引从0开始，$(&quot;input:odd&quot;)选取索引是奇数的&lt;input&gt;元素 6). $(&quot;:eq(index)&quot;)选取索引等于index的元素，(index从0开始)，$(&quot;input:eq(1)&quot;)选取索引等于1的&lt;input&gt;元素 7). $(&quot;:gt(index)&quot;)选取索引大于index的元素，(index从0开始)，$(&quot;input:gt(1)&quot;)选取索引大于1的&lt;input&gt;元素(大于1，而不包括1) 8). $(&quot;:lt(index)&quot;)选取索引小于index的元素，(index从0开始)，$(&quot;input:lt(1)&quot;)选取索引小于1的&lt;input&gt;元素(小于1，而不包括1) 9). $(&quot;:header&quot;)选取所有的标题元素，例如：h1,h2,h3等等，$(&quot;:header&quot;)选取网页中的所有的&lt;h1&gt;,&lt;h2&gt;,&lt;h3&gt;... 10). $(&quot;:animated&quot;)选取当前正在执行动画的所有元素，$(&quot;div:animated&quot;)选取正在执行动画的&lt;div&gt;元素。 11). $(&quot;:focus&quot;)选取当前获取焦点的元素，$(&quot;:focus&quot;)选取当前获取焦点的元素 2). 内容过滤选择器：主要体现在它所包含的子元素或者文本内容上面1). $(&quot;:contains(text)&quot;)选取含有文本为&quot;text&quot;的元素，$(&quot;div:contains(&#39;我&#39;)&quot;)选取含有文本&quot;我&quot;的&lt;div&gt;元素 2). $(&quot;:empty&quot;)选取不包含子元素或者文本的空元素，$(&quot;div:empty&quot;)选取不包含子元素(包括文本元素)的&lt;div&gt;空元素 3). $(&quot;:has(selector)&quot;)选取含有选择器所匹配的元素的元素，$(&quot;div:has(p)&quot;)选取含有&lt;p&gt;元素的&lt;div&gt;元素 4). $(&quot;:parent&quot;)选取含有子元素或者文本的元素,$(&quot;div:parent&quot;)选取拥有子元素(包括文本元素)的&lt;div&gt;元素 3). 可见性过滤选择器：根据元素的可见和不可见状态来选择相应的元素1). $(&quot;:hidden&quot;)选取所有不可见的元素，$(&quot;:hidden&quot;)选取所有不可见的元素，包括&lt;input type=&quot;hidden&quot; /&gt;，&lt;div style=&quot;display:none;&quot;&gt;和&lt;div style=&quot;visibility:hidden;&quot;&gt;等元素。如果只想选取&lt;input&gt;元素，可以使用$(&quot;input:hidden&quot;) 2). $(&quot;:visible&quot;)选取所有可见的元素，$(&quot;div:visible&quot;)选取所有可见的&lt;div&gt;元素 4)属性过滤选择器：通过元素的属性来获取相应的元素1).$(&quot;[attribute]&quot;)选取拥有此属性的元素，$(&quot;div[id]&quot;)选取拥有属性Id的&lt;idv&gt;元素。 2).$(&quot;[attribute=value]&quot;)选取属性的值为value的元素，$(&quot;div[title=test]&quot;)选取属性title为&quot;test&quot;的&lt;div&gt;元素 3).$(&quot;[attribute!=value]&quot;)选取属性的值不等于value的元素，$(&quot;div[title!=test]&quot;)选取属性title不等于&quot;test&quot;的&lt;div&gt;元素(注意：没有属性title的&lt;div&gt;元素也会被选取) 4).$(&quot;[attribute^=value]&quot;)选取属性的直以value开始的元素，$(&quot;div[title^=test]&quot;)选取属性title以&quot;test&quot;开始的&lt;div&gt;元素 5).$(&quot;[attribute$=value]&quot;)选取属性的值以value结束的元素，$(&quot;div[title$=test]&quot;)选取属性title以&quot;test&quot;结束的&lt;div&gt;元素 6).$(&quot;[attribute=value]&quot;)选取属性的值含有value的元素，$(&quot;div[title=test]&quot;)选取属性title含有&quot;test&quot;的&lt;div&gt;元素 7).$(&quot;[attribute|=value]&quot;)选取属性等于给定字符串或以给字符串为前缀(该字符串后跟一个连字符&quot;-&quot;)的元素,$(&quot;div[title|=&quot;en&quot;]&quot;)选取属性title等于en或者以en为前缀(给字符串后跟一个&quot;-&quot;)的元素 8).$(&quot;[attribute~=value]&quot;)选取属性用空格分隔的值中包含一个给定值得元素，$(&quot;div[title~=&#39;uk&#39;]&quot;)选取属性title用空格分隔的值中包含字符uk的元素 9).$(&quot;[attribute1][attribute2][attribute3]&quot;)用属性选择器合并成一个复合属性选择器，满足多个条件，每选择一次，缩小一次范围 $(&quot;div[id][title$=&#39;test&#39;]&quot;)选取拥有属性id，并且属性title以&quot;test&quot;结束的&lt;div&gt;元素 5)子元素过滤选择器 注解：子元素过滤选择器的过滤规则相对于其他的选择器稍微有些复杂，只要将元素的父元素和子元素区分清楚，使用起来还是相当简单的 1). $(&quot;:nth-child(idenx/even/odd/equation)&quot;)选取每个父元素下的第index个子元素或者奇偶元素(idnex从1算起):eq(index)只匹配一个元素，而:nth-child将为每一个父元素匹配子元素，并且:nth-child(index)的index是从1开始的， 而:eq(index)是从0开始的 2). $(&quot;:first-child&quot;)选取每个父元素的第一个子元素，:first只返回单个元素，而:first-child选择符将为每个父元素匹配第一个子元素，例如:$(&quot;ulli:first-child&quot;);选取每个&lt;ul&gt;中的一个&lt;li&gt;元素 3). $(&quot;:last-child&quot;)选取每个父元素的最后一个子元素,和上面一样，:last只返回当个元素，而:last-child选择符将为每个符永元素匹配最后一个子元素，例如：$(&quot;ulli:first-child&quot;);选取每个&lt;ul&gt;中的最后一个&lt;li&gt;元素。 4). $(&quot;:only-child&quot;)如果某个元素是它父元素中唯一的子元素，那么将会被匹配，如果父元素中含有其他元素，这不会被匹配$(&quot;ulli:only-child&quot;)在&lt;ul&gt;中选取是唯一子元素的&lt;li&gt;元素 5). :nth-child()选择器是很常用的子元素过滤器，详细功能如下：1). $(:nth-child(even))能选取每个父元素下的索引值是偶数的元素 2). $(:nth-child(odd))能选取到每个父元素下的索引值是奇数的元素 3). $(:nth-child(2))能选取到每个父元素下索引值等于2的元素 4). $(:nth-child(3n))能选取到每个父元素下索引值是3的倍数的元素(n从1开始) 5). $(:nth-child(3n+1))能选取每个父元素下索引值是(3n+1)的元素(n从1开始) 6). 表单对象过滤选择器：对所选择的表单进行过滤1). $(:enabled)选取所有可用元素，$(&quot;#form:enabled&quot;);选取id为&quot;form&quot;的表单内的所有可用元素 2). $(:disabled)选取所有不可用的元素，$(&quot;#form:enabled&quot;);选取id为&quot;form&quot;的表单内的所有不可用元素 3). $(:checked)选取所有被选中的元素(单选框，复选框)，$(&quot;input:checked&quot;)选取所有被选中的&lt;input&gt;元素 4). $(:selected)选取所有被选中的选项元素(下拉列表)，$(&quot;selectoption:selected&quot;)选取所有被选中的选项元素 (4)表单选择器：方便的获取到表单的某个或者某类型的元素1). $(&quot;:input&quot;)选取所有的&lt;input&gt;,&lt;textarea&gt;,&lt;select&gt;,&lt;button&gt;元素 2). $(&quot;:text&quot;)选取所有的单行文本框 3). $(&quot;:password&quot;)选取所有的密码框 4). $(&quot;:radio&quot;)选取所有的单选框 5). $(&quot;:checkbox&quot;)选取所有的多选框 6). $(&quot;:submit&quot;)选取所有的提交按钮 7). $(&quot;:image&quot;)选取所有的图像按钮 8). $(&quot;:reset&quot;)选取所有的重置按钮 9). $(&quot;:button&quot;)选取所有的按钮 10). $(&quot;:file&quot;)选取所有的上传域 11). $(&quot;:hidden&quot;)选取所有的不可见元素 4.选择器中的一些注意事项(1)选择器中含有特殊符号的注意事项1). 选择器中含有&quot;.&quot;,&quot;、&quot;,&quot;#&quot;,&quot;(&quot;,&quot;]&quot;等特殊字符 根据w3c的规定，属性中是不能含有这些特殊字符的，但在实际项目中偶尔会遇到表达式中含有&quot;#&quot;,&quot;.&quot;等特殊字符，如果按照普通的方式去处理的话可能会出现错误，解决此类错误是使用转义符转义 例如：&lt;divid=&quot;id#b&quot;&gt;韩迎龙&lt;/div&gt;&lt;divid=&quot;id[1]&quot;&gt;韩迎龙&lt;/div&gt;,这时的取法是这样的$(&quot;#id\#b&quot;),$(&quot;#id\[1\]&quot;) 2). 属性选择器的@符号问题 在Jquery升级版本的过程中，jquery在1.3.1版本中彻底放弃了1.1.0版本遗留下来的@符号，加入你使用的是1.3.1以上的版本， 那么你不需要再属性前添加@符号，例如： $(&quot;div[@title=&#39;test&#39;]&quot;)，正确的写法就是去掉@符号，$(div[title=&#39;test&#39;]) (2). 选择器中含有空格的注意事项 选择器中的空格是不容忽视的，多一个空格或者少一个空格也许会得到截然不同的结果 出处：http://www.cnblogs.com/hanyinglong]]></content>
      <categories>
        <category>Tech</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>selector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Basic]]></title>
    <url>%2F2015%2F02%2F04%2Fpro-git-learning-notes%2F</url>
    <content type="text"><![CDATA[版本控制概念版本控制(Reversion Control)是一种记录文件若干文件内容变化，以便将来直接查阅特定版本的系统。 版本控制系统的发展本地版本控制系统本地控制系统是比较早的版本控制系统，它使用简单的数据库来记录文件的历次更新差异。最流行的为rcs；在许多计算机系统中都还可以砍到它的影子。 集中化的版本控制系统本地版本控制系统只是在本地用作版本控制，而对于多人协同工作却无法做到，于是出现了集中化的版本控制系统(Central Version Control System)。此类系统有CVS,Subversion以及Perforce等等。集中版本控制系统都有相应的权限控制部分，对不同的目录分配不同的权限；我们可以看到每个文件的更新历史。它的缺点就是对于版本控制服务器的依赖很强，如果服务器挂掉，那么会导致有些工作无法进行下去，如果访问器磁盘挂掉，那么后果可能是灾难性的。我们现在开发使用的客户端为VSS，日常工作时那个速度..好恶心 分布式版本控制系统分布式版本控制系统(Distributed Version Control System)兼容了前面的两种控制系统。代表有Git, Mercurial和Bzzaar、Darcs.它在获取代码时提取原始仓库的快照和最新文件，如果服务器挂掉，那么会有本地的记录来恢复。这样的系统其实是维护本地的仓库和远程的仓库。 Git的历史Git的历史也是是在管理Linux内核的历史。在1991-2002年期间，社区人员大存归档的繁琐事务上。在2002年，Linux社区开始和BitKeeper合作，使用BitKeeper来管理和维护代码。在2005系统到期，作为商业软件，社区不能再无偿使用它。不受制于人，只能靠自己努力，拥有自主的东西，于是Linus Torvalds开始设计属于自己的版本控制系统。他们对新的版本控制系统定下了如下的目标: 简单 速度快 对非线性开发的支持（多分支） 完全分布式 能管理大型软件项目。 Git与常规版本控制系统的区别保存文件的快照，而非比较差异CVS和Subversion等控制系统，不仅判断文件是否修改，还记录文件更新的哪一部分内容。Git与之大不相同，它直接保存文件的快照，如果文件修改了，那么对文件进行快照；如果没有修改，那么就不保存它。Git只对上次保存的快照作连接。 几乎所有操作都可以在本地完成由于Git属于分布式版本控制软件，本地就保存着和服务器的仓库，如果需要对比文件的差异性操作，只用在本地操作就足够了。而传统的集中化版本控制系统都需要从服务器获取要比较的文件与本地或与服务器的某个版本文件进行比较。显然Git操作会更快。 另外Git可以在本地随时进行更新和提交，最后统一push到服务器；对于这一点，在断网的情况下，Subversion和CVS只能本地修改，不能进行提交，这意味着本地只能保留最新近修改的文件，而不能保留中间过程中的文件历史。 保持数据完整性Git使用SHA-1算法对所有数据进行校验和计算，并使用该校验和作为该版本的索引。每个SHA-1索引是由40个十六进制的字符构成。对所有文件进行校验和计算，这意味着如果某个文件修改了或丢失了能够迅速判断出来。 Git的状态Git的状态有三种：已提交(Commited),已修改(Modified)和已暂存(Staged)。已提交说明文件已经保存在本地数据库中；已修改说明修改了文件的内容，但是未提交；已暂存说明已修改的文件放在下次提交时要保存的清单中了。 Git的工作区域包括：Git本地数据目录、工作目录和暂存区域。 本地文件Checkout后会进入工作目录，修改后的文件会放入暂存区域，提交后的文件会从暂存区域转向本地数据目录。 对于Git来说，最重要的文件是.git目录。它保存着元数据和对象数据库，每次clone镜像仓库时，实际拷贝的就是它。暂存区域实际是简单的文件，放在.git目录下。 Git配置Git提供了git config工具来对Git相关的环境变量进行配置，这些配置文件决定了Git在各个环节的具体工作方式。 /etc/gitconfig文件是对系统内部的所有用户都普遍适用的配置，git config时使用--system选项。 ~/.gitconfig文件是适用于某个用户的配置，git config 时使用 --global选项。 当前项目下的.git/config文件是针对某个项目有效的配置。 这三种配置文件会依次覆盖，从下到上。 配置用户信息用户信息是要配置自己的用户名和邮箱，每次Git提交时都会用到这两个信息，用于说明谁提交了更新，并记录历史。 git config --global user.name &quot;david&quot; git config --global user.email example@example.com 如果没有--global选项，默认在当前项目的.git/config文件下。 文本编辑器Git有时候需要额外输入一些信息，这里就用到了文本编辑器。 git config --global core.editor mvim 差异分析工具在解决合并冲突时，使用差异分析工具是很重要的。 git config --global merge.tool vimdiff Git这里配置的可以有kdiff3, tkdiff, meld, xxdiff, emerge, vimdiff, gvimdiff等等。 查看所有的配置信息使用git config --list就可以。 Git基础获取项目的Git仓库获取Git仓库的方法有两种，一是自己创建，二是从远程获取。 在项目目录下执行git init，这条命令会初始化一个仓库，这个仓库现在是空的。从远程获得仓库的方法为git clone https://&lt;URL&gt;,git clone支持的协议包括git://和http(s)，user@server:/.git。git工程下面会有一个.git目录用来存放Git需要的数据和资源。 如果需要忽略某些文件，则需要编辑Git仓库下面的.gitignore文件，将不跟踪的文件列入其中。 *.[oa] #忽略以o或a为结尾的文件 *~ #忽略以~结尾的文件 tmp/ #忽略tmp目录，这里需要有/ !lib.a #排除lib.a，即要跟踪lib.a doc/*.txt #忽略doc目录下的txt文件 Git常用命令git获取帮助的方法为 git &lt;命令&gt; --help man git &lt;命令&gt; 查看当前状态 git status On branch master nothing to commit (working directory clean) 跟踪新文件 git add README git add支持通配符，如果跟踪的是目录，那么它会自动进行迭代跟踪。 3.比较文件变化 git diff 这条命令会显示尚未暂存的文件更新了哪些部分，默认比较的是当前文件和暂存区域快照直接的差异。如果要查看缓存的文件和上次提交的快照之间的差异，可以使用git diff --cached。 提交更新 git commit -m 将已经暂存的文件提交，-m参数用来对本次提交写comment，将更新内容简要写出来。 如果想从暂存区域将已经跟踪的某个文件移除，可以使用git rm命令，此命令也会将文件删除掉。如果该文件已经修改过且已经在暂存区，必须添加强制删除参数-f。如果只希望仅仅从仓库跟踪列表中删除，而保留文件，那么需要添加--cached参数，即git rm --cached &lt;文件&gt;。 注意：如果使用通配符，注意星号*一般最好添加一个反斜杠\进行转义。因为Git有自己的文件模式扩展匹配方式，在上面的星号*会自动进行递归。如果不转义，则达不到此效果。 移动文件 git mv 此命令运行后，Git并不跟踪文件移动操作。如果在Git中重命名了某个文件，仓库中存储的元数据并不会体现出这是一次改名操作。 查看提交历史 git log 默认会按提交时间列出所有的更新，最近的更新排在最上面。 git log可以使用--pretty=format:&quot;&lt;format string&gt;&quot;来对git log的结果进行美化： 选项 说明 %H 提交对象的完整Hash %h 提交对象的简短Hash %T 树对象的完整Hash %t 树对象的简短hash %P 父对象的完整Hash %p 付对象的简短Hash %an 作者的名字 %ae 作者的email %ad 作者修订日期 %ar 作者修订日期，按多久之前的方式显示 %cn 提交者的名字 %ce 提交者的email %cd 提交日期 %cr 提交日期，按多久之前的方式显示 %s 提交说明 作者和提交者的区别是：作者是实际作出修改的人，提交者是将修改提交到仓库中的人。 git log还支持按时间段对提交记录进行查询： -(n)最近的n条提交 --since, --after 显示指定实际自后的提交 --until, --before 指定时间之前的提交 --author 指定指定作者的记录 --committer 显示指定提交者相关的提交 撤销操作 git commit --amend 此命令将当前的暂存区域快照提交，如果刚才提交为完成任何改动，那么相当于重新编辑提交说明。 git commit -m &apos;initial commit&apos; git add forgoten_file git commit --amend 上面的命令会将第二次提交替换掉第一次提交的内容。 撤销暂存的文件 git reset HEAD 取消对文件的修改 git checkout 添加远程仓库 git remote add git://github.com/example/testcase.git git fetch origin #假设origin为上面配置的local name git push origin master #推送分支master到origin服务器端 删除和重命名远程仓库 git remote rename origin new_origingit remote rm new_origin 打标签 git tag #显示所有标签git tag -l &#39;v1.4&#39; #只显示v1.4的tag 标签有轻量级(lightweight)和含附注的(annotated)。轻量级标签是不会变化的分支，实际上它指向特定提交对象的引用。附注标签实际上是存储仓库中的一个独立对象，有自身的校验和信息，包含着标签的名字，电子邮件和日期以及标签说明。 git tag -a v1.4.1 -m &apos;stable version&apos; git show v1.4.1 #显式对应标签的信息 git tag -v [tag-name] #使用共钥验证签名，共钥需要放在keyring中。 如果有自己的私钥，可以使用用GPG来签署标签， git tag -s v1.4.2 -m &apos;signed version&apos; 轻量级标签： git tag v1.4.3 对于以前的某个版本签标签，需要在标签后面加上提交对象的校验和(前面几位就可以了) git tag -a v1.9.0 af82423 如果需要将标签推送到远程服务器，使用git push origin [tag-name]，弄人不会将标签传送到远程服务器。推送所有的标签上去，可以使用--tags选项。 分支Git仓库中有5个对象：表示文件快照内容的blob对象，记录目录树内容及其中各个文件对应blob对象索引的tree对象，指向tree对象的索引和其它提交信息元数据的commit对象。 1.创建分支 git checkout -b newbranch 切换分支 git checkout master 合并分支 git merge &lt;要合并的分支&gt; #合并到当前所在的分支 合并过程中，如果遇到在两个分支同时修改了相同的文件，那么就需要手工进行修改合并。或者2选1，或者把两者不同部分手动修改。 删除分支 git branch -d &lt;branch_name&gt; #-D表示强制删除 显示分支 git branch 可选的参数： -v 表示显示最后一次的commit信息。 --merged 和 --no-merged表示已经合并和未进行合并的分支。 分支式工作流程长期分支由于Git使用简单的三方合并（即如果要合并的和当前的分支属于树的两个分支，那么在合并时会取两个分支共同的父节点+当前+要合并的分支进行合并），就算在较长一段时间内，反复多次把某个分支合并到另一分支，也不会很难。此类分支适合完成特定任务，随着开发的推进，将这个分支合并到其它分支。 特性分支特性(Topic)分支是指一个短期的，用来实现单一特性或与其相关工作的分支。 远程分支如果需要将自己的分支推送到远程仓库，那么可以使用git push (远程仓库名) (分支名)命令。 git push origin mybranch mybranch分支名会被Git自动扩展为refs/heads/mybranch:refs/heads/mybranch,意为取出本地的mybranch分支，推送到远程的mybranch。也可以使用git push origin mybranch:newbranch来实现相同的效果。 从远程服务器同步过来的分支，即使用fetch命令获取的分支只会获取数据，但是本地不会产生新的分支，需要手动checkout: git checkout -b mybranch origin/mybranch 删除远程分支： git push origin :mybranch 它的实际语法是:git push [远程名] [本地分支]:[远程分支],上面命令的意思是提取本地的空分支推送到远程。 合并分支除了使用merge命令，还可以使用rebase命令。对于两个不同的分支如果使用merge，则取两个分支的共同祖先进行三方合并。衍合(rebase)会回到两个分支的共同祖先，提取两个分支每次提交时的不同，把差异分别保存在临时文件里然后从当前分支转换到要衍合的分支，依次序施用每个补丁。 git checkout tobe_rabased git rebase master #rebase the tobe_rabased to the master 服务器上的GitGit支持本地传输、SSH协议、Git协议和HTTP协议。 git clone file:///opt/git/mygit.git git clone /opt/git/mygit.git git clone ssh://user@server:mygit.git git clone user@server:mygit.git #default use the SSH Protocol]]></content>
      <categories>
        <category>Tech</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用资源]]></title>
    <url>%2F2015%2F01%2F30%2Fgit-resources%2F</url>
    <content type="text"><![CDATA[在工作目录中创建新仓库进入新建的目录GitTest 1$ git init 检查状态1$ git status 添加与提交在当前工作目录中创建文件，这里我新建了ReadMe.md 添加变化1$ git add ReadMe.md 检查变化1$ git status 提交1$ git commit -m "Add ReadMe" 添加所有变化比如添加所有的.md文件 1$ git add '*.md' 提交所有变化1$ git commit -m 'Add all md files' 历史1$ git log 远程仓库1$ git remote add TestGit https://github.com/lay1010/TestGit.git 注意：按照官方教程，命令是add origin，而我之前已经误用过origin这个名字了，如果仍然git remote add origin，会出现fatal：remote origin already exists. 解决办法：将origin更换为其他名字，比如我现在更换为TestGit，后面的命令也相应地把origin替换为TestGit。感谢一楼评论小明 曹童鞋。 远程推送1$ git push -u TestGit master 远程拉入1$ git pull TestGit master 区别1$ git diff HEAD 阶段区别12$ git add testfamily/3.md$ git diff --staged 3.md是刚刚添加的文件。 重置阶段1$ git reset testfamily/3.md 移除3.md，注意这里只是将3.md从staged状态移除。 撤销1$ git checkout -- 2.md 注意：checkout的用法不是很懂，这儿得问问。 分支出去1$ git branch clean_up 创建一个名叫clean_up的分支。 切换分支1$ git checkout clean_up 从master切换到了clean_up 移除所有东西1$ git rm '*.md' 提交分支变化1$ git commit -m "remove all things" 切换回master分支1$ git checkout master 准备合并分支1$ git merge clean_up 保持简洁（删除分支）1$ git branch -d clean_up 最终推送1$ git push 推送所有东西。 注意：完成所有步骤后发现blog里面所有的文件都消失了。原因我也不知道，看来看是得系统看书去。 退回到之前1天的版本1$ git log --before="1 days" ###资料链接 Try Git]]></content>
      <categories>
        <category>Tech</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Spreadsheet读取和修改Excel文件]]></title>
    <url>%2F2012%2F08%2F19%2Fthe-usage-of-spreadsheet-and-read-write-excel-files%2F</url>
    <content type="text"><![CDATA[Spreadsheet是神马Spreadsheet是一个Ruby实现的gem，它可以使我们很方便的使用它对excel进行操作。 如何安装gem install spreadsheet #你懂得 简单使用Spreadsheet基本使用的包括以下几部分(C表示类,M表示模块): Column: (C)用来指定列的格式化和提供了以列的形式遍历所有单元格的方法。 Datatypes: (M)定义了可以将参数转换为Spreadsheet常用的属性的方法(boolean,colors,enum)， Encoding: (C)定义了编码转换的方法，基本用不到。 Row: (C)定义了对行为单位对Excel进行处理的方法,它是Array的子类，所以很多Array的方法它都可以使用。 Workbook: (C)主要来操作Excel的标签页，每个标签页就是一个Workbook. Worksheet: (C)一个新的实例就是一个Excel。 Format: (C)定义Cell的格式的。 :font=&gt;Spreadsheet::Font :number_format=&gt;&quot;GENERAL&quot;, :rotation=&gt;0, :pattern=&gt;1, :bottom_color=&gt;:builtin_black, :top_color=&gt;:builtin_black, :left_color=&gt;:builtin_black, :right_color=&gt;:builtin_black, :diagonal_color=&gt;:builtin_black, :pattern_fg_color=&gt;:yellow, :pattern_bg_color=&gt;:border, :regexes=&gt;{:date=&gt;&gt;/[YMD]/, :date_or_time=&gt;&gt;/[hmsYMD]/, :datetime=&gt;&gt;/([YMD].[HS])|([HS].[YMD])/, :time=&gt;&gt;/[hms]/}, :used_merge=&gt;0, :horizontal_align=&gt;:center, :text_wrap=&gt;false, :vertical_align=&gt;:bottom, :rotation_stacked=&gt;false, :indent_level=&gt;0, :shrink=&gt;false, :text_direction=&gt;:context, :left=&gt;:none, :right=&gt;:none, :top=&gt;:none, :bottom=&gt;:none, :cross_down=&gt;false, :cross_up=&gt;false Font: (C)看名字就知道这个字体。 :name=&gt;&quot;Arial&quot;, :color=&gt;:text, :weight=&gt;700, :size=&gt;14, :italic=&gt;false, :strikeout=&gt;false, :outline=&gt;false, :shadow=&gt;false, :escapement=&gt;:normal, :underline=&gt;:none, :family=&gt;:swiss, :encoding=&gt;:iso_latin1 操作一个Spreadsheet# 引入spreadsheet插件 require &quot;spreadsheet&quot; # 声明Spreadsheet处理Excel文件组时的编码 Spreadsheet.client_encoding = &quot;UTF-8&quot; # 创建一个Spreadsheet对象，它相当于Excel文件 book = Spreadsheet::Workbook.new # 创建Excel文件中的一个表格，并命名为 &quot;Test Excel&quot; sheet1 = book.create_worksheet :name =&gt; &quot;Test Excel&quot; # 设置一个Excel文件的格式 default_format = Spreadsheet::Format.new(:weight =&gt; :bold,#字体加粗 :size =&gt; 14, :horizontal_align: =&gt; :merge, #表格合并 :color=&gt;&quot;red&quot;, :border=&gt;1, :border_color=&gt;&quot;black&quot;, :pattern =&gt; 1 , :pattern_fg_color =&gt; &quot;yellow&quot; )#这里需要注意，如果pattern不手动处理，会导致pattern_fg_color无实际效果 data = &quot;测试&quot; # 指定一个在表格中的第一行对象 test_row = sheet1.row(0) # 为第一行的前5个列指定格式 5.times do |i| test_row.set_format(i, default_format) end # 为第一行的第一列指定值 test_row[0] = data # 将创建的Spreadsheet对象写入文件，形成电子表格 book.write &apos;book2.xls&apos; 如果需要合并某些列，建议使用merge_cells(begin_row,begin_col,end_row,end_col)。i 格式化时间当设置某个cell为时间时，Spreadsheet将会尝试将cell的number_format到一个相关的值。如果自己定义了时间的格式，Spreadsheet将会使用程序员定义的。如果一个Cell已经被格式化，Spreadsheet将会保留原有的格式。 row[4] = Date.new 1975, 8, 21 # -&gt; assigns the builtin Date-Format: &apos;M/D/YY&apos; book.add_format Format.new(:number_format =&gt; &apos;DD.MM.YYYY hh:mm:ss&apos;) row[5] = DateTime.new 2008, 10, 12, 11, 59 # -&gt; assigns the added DateTime-Format: &apos;DD.MM.YYYY hh:mm:ss&apos; row.set_format 6, Format.new(:number_format =&gt; &apos;D-MMM-YYYY&apos;) row[6] = Time.new 2008, 10, 12 # -&gt; the Format of cell 6 is left unchanged. 参考资料: http://blog.csdn.net/xianqiang1/article/details/7298389 http://stackoverflow.com/questions/7730112/ruby-spreadsheet-row-background-color3.http://stackoverflow.com/questions/11603216/merging-cells-with-ruby-gem-spreadsheet Spreadsheet Guide]]></content>
      <categories>
        <category>Tech</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Spreadsheet</tag>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB Basic]]></title>
    <url>%2F2012%2F07%2F29%2Fnotes-about-mongodb%2F</url>
    <content type="text"><![CDATA[MongoDB特点 数据类型丰富。MongoDB是面向文档的数据库，不是关系型数据库。它将原来关系型数据库的“行”概念变换为更为灵活的“文档”模型。面向文档的方式可以将文档或数组内嵌进来，用一条记录表示可能需要关系数据库多个表关联的数据。 扩展容易MongoDB采用面向文档的数据模型可以很方便的在多台服务器之间分割数据，环科院实现集群的数据和负载，自动重排文档。 功能丰富MongoDB支持通用辅助索引，能进行多种快速查询，也提供唯一、复合和地理空间索引能力。 可以直接在服务器端存取Javascript的函数和值。 支持MapReduce等聚合工具。 集合的大小有上限，对某些数据特别有用。 MongoDB支持易用的协议存储大型文件和文件的元数据。 高速MongoDB使用自己的传输协议作为与服务器交互的方式，对文档进行动态填充，预分配数据文件，用空间换取性能的文档。 易管理MongoDB尽量让服务器自己来管理自己，而且还可以自己在主服务器down掉的时候，自动切换到备用服务器。它的管理理念就是尽量让服务器自动配置，让用户能在需要的时候调整设置。 MongoDB基础MongoDB的基本单元是：文档。每个文档都有一个特殊的键:&quot;_id。MongoDB的单个实例可以容纳多个独立的数据库，每个数据库都有自己的集合和权限。 文档是MongoDB的基础，多个键及其相关的值有序地放在一起就构成了文档。 MongoDB文档的键是字符串，但是这些键不能使用\0（表示键的结束),.和$一般 不可以使用，以下划线&quot;_&quot;开头的键是保留的，一般不建议使用。 MongoDB的键不可以有重复的。 文档是构成MongoDB的基本单元，多个文档组合到一起就是集合。集合的名字不能包含\0，system.以及$。 多个集合构成了一个数据库，数据库的名字不能使用空字符串，不能含.,$,/,\和\0，不能超过64字节，全部小写。 插入post = { &quot;title&quot;: &quot;My First Blog&quot;, &quot;content&quot;: &quot;test,test&quot;,&quot;date&quot;: new Date() } db.blog.insert(post) 查询db.blog.find() #默认返回20条记录 更新update至少需要2个参数，第一个是更新文档的限定条件，第二个是新的文档。 post.comments = [&quot;yeah, It is cool.&quot;] db.blog.update({title: &quot;My First Blog&quot;}, post) 删除remove默认删除集合内的所有文档，当然也可以设置限定条件。 db.blog.remove({title: &quot;My First Blog&quot;}) 数据类型MongoDB的文档类似JSON，在概念上和JavaScript相似。JSON包含null, 布尔，整数、字符串、数组和对象几种类型。MongoDB扩展了JSON类型。MongoDB还包括64位浮点数，符号、对象ID，日期，正则表达式、代码，二进制数据，最大值，最小值和未定义的类型，内嵌文档等等。 数字MongoDB的数字都是以64位浮点数的形式保存的。内嵌文档表示shell显示的是一个用6位浮点数近似表示的64位整数。如果插入的64位整数不能精确地表示为双精度数字显示，shell会添加两个键top和bottom，分别表示高32位和低32位。 DateMongoDB的日期通常使用new Date()来记录，如果使用Date()函数就会导致日期和字符串不匹配，对更新表和查询带来问题。它记录的是从标准纪元开始的毫秒数，但是不包含任何时区相关的数据，如果要保存，那么就需要额外的字段来保存了。 数组数组可以包含不同数据类型的元素。MongoDB可以“理解”文档中的数组的结构，并可以深入数组内部对数组进行操作。 内嵌文档内嵌文档是把MongoDB文档作为另一个文档键的一个值。这样数据组织的更加自然，而且不用保存成扁平结构的。 对象IDMongoDB中存储的每个文档都有一个&quot;_id&quot;键，这个键的值可以是任何类型的，默认为ObjectId对象。在每个集合里面，每个文档都有唯一的&quot;_id&quot;值，来确保集合里面的每个文档都可以被唯一标识。 ObjectId在不同机器上都能用全局唯一的同种方法方便地自动生成它。所以MongoDB采用它，而不是使用自动增长的主键。ObjectId使用12字节的存储空间，每个字节两位十六进制，所以一个ObjectId是一个有24位字符的字符串。 ObjectId的前4位表示从标准纪元开始的时间戳，3位表示机器名的散列值，2位表示PID，3位表示计数器。 ObjectId分别从时间上，同一机器的同一进程的不同时间上产生的ObjectId是唯一的。 插入数据MongoDB可以批量插入数据，这样可以大大提高插入的速度。原因在于批量的插入相当于有一个TCP头，服务器可以减少解析众多其它TCP头的时间，从而提高了速度。但是批量也不是对TCP数据的大小无所要求，它要求它不能超过16MB. 在MongoDB插入数据的时候，数据首先会被转换成BSON格式的数据，然后检查数据是否包含&quot;_id&quot;键和文档大小是否超过4MB，然后将数据原样保存到数据库。不执行插入数据中的任何命令，可以有效保证数据库不会被注入攻击。但是这样做的坏处就是数据库可能会插入很多无效数据。 如果需要对数据进行检查，在启动数据库的时候可以添加--objcheck选项。 删除数据MongoDB删除数据是永久性的，无法进行回滚撤销，所以不太适合事务类的业务。或许这也是它删除文档会很快的原因之一——不用去关注数据库日志保证数据库的完整性。 更新数据MongoDB使用update对数据进行更新，它接收两个参数，一个是更新条件，另一个是描述对文档做了哪些修改。 $set修改器可以更新某个原子的值： db.blog.update({&quot;title&quot;: &quot;test&quot;}, {&quot;$set&quot;: {&quot;what&quot;: &quot;what the hell?&quot;}}) $unset可以取消某个原子文档。 db.blog.update({&quot;title&quot;: &quot;test&quot;, {&quot;$unset&quot;: {&quot;what&quot;: 1}}}) $inc修改器可以增加已有的键值，或者在不存在的时候创建一个键。 db.blog.update({&quot;title&quot;: &quot;test&quot;, {$inc: {&quot;_id&quot;: 1}}}) update想已有的数组末尾添加一个元素，如果没有该数组，就会创建一个新的数组。 db.blog.update({&quot;title&quot;: &quot;hello&quot;}, {$push : {&quot;comments&quot; : {&quot;name&quot;:&quot;test&quot;,&quot;content&quot;:&quot;just for test&quot;}}}) 如果一个值不再某个数组里面则加入，如果存在则跳过： db.blog.update({&quot;comments&quot;: {&quot;$ne&quot;: &quot;test&quot;},{$push: {&quot;comments&quot;: &quot;test it&quot;}}) $addToSet也可以达到同样的效果。 db.blog.update({&quot;_id&quot;:ObjectId(&quot;34234&quot;)}, {$addToSet: {&quot;emails&quot;: &quot;test@example.com&quot;}}) $addToSet和$each搭配可以插入多个不同的值： db.blog.update({&quot;_id&quot;:ObjectId(&quot;1231&quot;)},{$addToSet:{&quot;emails:&quot;:{&quot;$each&quot;: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]}}}) $pop可以从数组的任一端删除元素。{$pop : { key : 1 }}从数组尾部删除，{$pop : { key : -1 }}从头部删除。如果需要基于特定条件删除元素，而不是根据位置，可以使用$pull命令。 db.blog.update({},{&quot;$pull&quot; : { &quot;title&quot; : &quot;hello world&quot;}}) 使用定位符$可以删除第一个匹配的元素： db.blog.update({&quot;title&quot;:&quot;test&quot;}, {&quot;$set&quot; : {&quot;comments.$.author&quot; : &quot;David&quot;}}) 如果知道某个记录的下标还可以使用下标进行指定操作： db.blog.update({&quot;title&quot;:&quot;test&quot;}, {$inc : { &quot;comments.0.votes&quot; : 1 }}) 在文档大小不变的情况下，修改器速度会很快。$inc由于不会修改文档的大小，所以速度非常快。而$set可能会修改文档的大小，所以速度会比较低。 upsert是一种特殊的更新。如果没有文档符合更新条件，就会以这个条件和更新文档为基础创建一个新的文档。如果找到了匹配的文档，则正常更新。upsert属于upadte的第三个参数，如果需要使用，只需要将update的第三个参数设置为true即可。 db.blog.update({&quot;title&quot;:&quot;my blog&quot;}, {$inc : { &quot;page.counts&quot; : 1 }}, true) save函数是一个shell函数，可以在文档不存在时插入，在存在时进行更新。save函数会调用upsert。 post = db.blog.findOne(); post.counts = 0; db.blog.save(post) # db.blog.update({&quot;_id&quot; : post._id}, x) 如果需要更新多个文档，则需要将update的第四个参数设置为true. 获取更新记录的条数可以使用getLastError命令，键n的值就是所要的数字。 db.runCommand({getLastError : 1}) 获取已更新的文档可以使用findAndModify命令。 db.runCommand({&quot;findAndModify&quot; : &quot;processes&quot;}, &quot;sort&quot; : { &quot;priority&quot; : -1 }, &quot;update&quot;: {&quot;$set&quot; : { &quot;status&quot; : &quot;READY&quot; }}) 查询findfind的第一个参数决定了返回哪些文档，也就是它是作为查询的条件的。如果为空，则查询全部数据。 db.blog.find({ &quot;title&quot;: &quot;hello&quot;, comments: 0 }) $lt,$lte, $gt,$gte,ne分别表示 &gt;, &gt;=, &lt;, &lt;=,!=,使用方法是： db.blog.find({&quot;age&quot; : { &quot;$lt&quot; : 30}}) $or的用法: db.blog.find({&quot;$or&quot; : [{condition1: c1, condition2 : c2}]}) $in的用法： db.blog.find({&quot;cond1&quot; : {&quot;$in&quot; : [c1, c2]}) 取反使用$nin。 $not的用法： db.blog.find({&quot;age&quot; : { &quot;$not&quot; : { &quot;$mod&quot; : [10,1] } }}) 上面的句子返回年龄mod 10不为1的文档。 第二个参数用于设定返回的键，如果希望某个键返回，在:后数字应该为1，否则为0，这样就不会返回这个字段了。在没有特殊设定下，_id总是默认返回的。 $all用于查询同时满足若干条件的数组，注意它只适用于查询数组。 db.food.find({&quot;fruit&quot; : { $all : [&apos;apple&apos;,&apos;banana&apos;] }}) 查询数组还可以指定匹配元素的下标。比如上面的fruit可以添加fruit.2，当然这样一来，后面的$all就不能使用了。 $slice既可以指定查询结果的条数，也可以制定查询结果的偏移。 db.blog.posts.find({},{&quot;comments&quot; : { $slice : [20,10] }}) #21-30 db.blog.posts.find({},{&quot;comments&quot; : { $slice : 10 }}) #前十条 查询内嵌文档db.blog.find({&quot;post.title&quot; : &quot;test&quot;, &quot;post.username&quot; : &quot;author1&quot;}) 与之相比db.blog.find({&quot;post&quot; : {&quot;title&quot; : &quot;test&quot;, &quot;username&quot; : &quot;author1&quot;}})要严格根据条件的顺序进行匹配的，如果文档中添加了其它的字段，就会导致数据无法正常查找到。 点表示法表示&quot;深入潜入文档内部&quot;，这也导致MongoDB不允许插入的文档包含.的原因，如果保存的文档中包含.，那么需要在保存前对其进行特殊处理。 如果匹配的内容是一个数组，那么上面的查询方法是无法起作用的，上面的会匹配数组中的所有元素，这也导致结果是不正确的。为了避免这个问题，需要使用$eleMatch. db.blog.find({&quot;post&quot; : { &quot;$eleMatch&quot; : { &quot;title&quot; : post, &quot;username&quot; : &quot;author1&quot; } }}) 如果需要比较某个文档内部满足条件的文档，则前面的查询条件是无法得到满足的，所以就有了$where子句。它后面可以跟一个Javascript函数，函数如果返回true，则返回该文档。不过使用它的坏处就是性能，因为BSON数据与要转换为JavaScript对象，然后通过$where字句的表达式运行，而且还不能使用索引，所以效率很低。在使用的时候可以私用非$where子句对条件先进行筛选，使用$where对结果进行调优。 游标如果将执行结果赋值给某个变量，那么这个变量就是一个游标了。游标用于对结果进行遍历，cursor.next取下一个文档，cursor.hasNext()用于查询结果集是否遍历完成。另外，游标实现了forEach迭代器方法： var cursor = db.blog.find() cursor.forEach(function(x) { print(x.name); }); 在调用find的时候，shell并不立即查询数据库，而是等待真正要获取数据的时候才发送查询；这样也可以对查询附加额外的玄仙。 var cursor = db.blog.find().sort({&quot;x&quot; : 1}).limit(2).skip(3) 在执行hasNext时，shell会立即去获取前100条或4MB大小的数据（取小）。 var cursor = db.blog.find().limit(50).sort({&quot;price&quot; : -1}) skip在略过的记录数量比较大时，通常就会出现性能问题。如果不能避免使用skip，那么可以利用上次查询的结果来计算获取的下一次数据。 索引创建索引 db.blog.ensureIndex({&quot;title&quot; : 1, &quot;date&quot; : -1}, {&quot;name&quot; : &quot;myindex&quot;, background : true}) 删除索引 db.runCommand({&quot;dropIndexes&quot; : &quot;db_name&quot;, &quot;index&quot; : &quot;index_name&quot;}) db.runCommand({&quot;dropIndexes&quot; : &quot;db_name&quot;, &quot;index&quot; : &quot;*&quot;}) #delete all the indexes of db_name 地理空间索引 db.map.ensureIndex({&quot;gps&quot; : &quot;2d&quot;}) #这里需要使用2d 查找附近的点： db.map.find({&quot;gps&quot; : { &quot;$near&quot; : [40,30] }}).limit(10) db.runCommand({geNear : &quot;map&quot;, near : [40,30], num : 10}) 后者还会返回每个文档到查询点的距离，单位为插入数据的单位。 聚合获取查询的结果的数据个数： 12db.blog.count()db.blog.count(&#123;"title" : ”test&#125;) 获取不同的值 db.runCommand({&quot;distinct&quot; : &quot;blog&quot;, &quot;key&quot; : &quot;title&quot;}) #键是必需的 分组获取数据。以获取大于某日的股票收市价格为例: 1234567891011121314151617181920212223242526272829303132333435363738db.runCommand(&#123;"group" : &#123; "ns" : "price", #文档名称 "key" : "init_date", #key "initial" : &#123;"time" : 0&#125; #initial value "$reduce" : function(doc, prev)&#123; if (doc.time &gt; prev.time)&#123; prev.price = doc.price; prev.time = doc.time; &#125; &#125;&#125;&#125;, &#123;"condition" : &#123;"day" : &#123;"$gt" : "20120801"&#125;&#125;&#125;)#eg.2db.runCommand(&#123;"group" :&#123; "ns" : "price", "key" : &#123;"tags" : true&#125;], "initial" : &#123;"tags" : &#123;&#125;&#125;, "$reduce" : function(doc,prev)&#123; for (i in doc.tags)&#123; if(doc.tags[i] in prev.tags)&#123; prev.tags[doc.tags[i]] ++; &#125;else&#123; prev.tags[doc.tags[i]] = 1; &#125; &#125; &#125;,"finalize" : function(prev) &#123; var mostPopular = 0; for (i in prev.tags)&#123; if (prev.tags[i] &gt; mostPopular)&#123; prev.tag = i; mostPopular = prev.tags[i]; &#125; &#125; delete prev.tags;&#125;&#125;&#125;) MapReduce的操作过程：映射，将操作映射到集合中的每个文档；洗牌，按照键分组，并将产生的键值组成列表放在对应的键中；化简，将列表中的值化简成一个单值。继续上面的过程，直到每个键的列表只有一个值结束。 1234567891011121314151617181920212223242526272829303132#get all the keys in a documentmap = function()&#123; for(var key in this)&#123; emit(key, &#123;count : 1&#125;); &#125;&#125;;reduce = function(key, emits)&#123; total = 0; for (var i in emits)&#123; total += emits[i].count; &#125; return &#123;"count" : total&#125;&#125;mr = db.runCommand(&#123;"mapreduce": "blog", "map" : map, "reduce" : reduce&#125;,out : &#123;replace:"mr", db: "test"&#125;)&#123; "result" : &#123; "db" : "test", "collection" : "mr" &#125;, "timeMillis" : 353, #执行时间 "counts" : &#123; "input" : 1, #集合个数 "emit" : 2, #emit被调用的次数 "reduce" : 0, #reduce的次数 "output" : 2 #结果集合中创建文档的数量 &#125;, "ok" : 1&#125;db.mr.find() #显示详细信息 MongoDB命令MongoDB的命令其实是作为特殊的查询来实现的，这些查询的集合为$cmd，runCommand仅仅是接收命令文档，执行等价查询，如db.runCommand({&quot;drop&quot; : &quot;test&quot;})等价于db.$cmd.find({&quot;drop&quot; : &quot;test&quot;})。 创建固定集合: db.createCollection(&quot;my_collection&quot;, {capped: true, size:10000, max:100}) #固定集合，大小为1000字节，最大可以容纳100个文档。 固定集合的文档按照顺序存储的，而且只有固定集合是顺序存储的，在对查询结果进行排序的时候，可以制定排序的方式。 db.my_collection.find().sort({&quot;natural&quot;: -1}) #逆序 尾部有标和tail -f命令类似，它不会获取不到数据后自动销毁游标，一旦有新的文档添加到集合中，新添加的文档就会被取出并输出。 GridFS存储文件GridFS是MongoDB存储大二进制文件的机制，使用它可以: 简化需求，GridFS不需要使用独立文件存储架构。 直接利用业已建立的复制或分片机制，对文件存储和故障恢复及扩展都很容易。 避免用户用于存储的文件系统出现问题。 可以不产生磁盘碎片，因为MongoDB分配数据空间以2GB为一块。 ─ ➤ mongofiles put logfile connected to: 127.0.0.1 added file: { _id: ObjectId(&#39;501e5b94d6079bdd94ce708d&#39;), filename: &quot;logfile&quot;, chunkSize: 262144, uploadDate: new Date(1344166804850), md5: &quot;70377c17d05fe2aa19bf8209137dfdc4&quot;, length: 27 } done! ─ ➤ mongofiles list connected to: 127.0.0.1 logfile 27 ─ ➤ rm logfile ─ ➤ mongofiles get logfile connected to: 127.0.0.1 done write to: logfile ─ ➤ mongofiles search logfile connected to: 127.0.0.1 logfile 27 ─ ➤ mongofiles delete logfile connected to: 127.0.0.1 done! GridFS是一个建立在普通MongoDB文档基础上的轻量级文件存储规范。GridFS的基本思想是将大文件分成很多块，每块作为单独的文档存储，这样就能存储大文件。MongoDB支持在文档中存储二进制数据，所以可以最大限度地减小块的存储开销。除了存储文件本身的块，还有一个单独的文档用来存储分块信息和文件元数据。]]></content>
      <tags>
        <tag>mongodb</tag>
        <tag>nosql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby Reflection And Metaprograming]]></title>
    <url>%2F2012%2F07%2F04%2Freflection-and-metaprograming%2F</url>
    <content type="text"><![CDATA[定义反射(Reflection)也称为内省(introspection)，表示一个程序可以审视自身的状态和结构。如Ruby可以获得类定义的方法列表，实例变量的值，可以修改自身的状态和结构，动态地增加方法和变量。 元编程(Metaprograming)可以被粗略定义为程序帮助你写程序。在百度百科上的定义为：某类计算机程序编写或操纵其它程序或自身作为它们的数据，或者在变异时完成部分本应在运行时应该完成的工作。 编写元程序的语言被称为元语言，被操作的语言称为目标语言。一门语言同时也是自身的元语言的能力称为反射。 Ruby的反射API大部分定义在Kernel、Module和Object中。反射的本质不是元编程，元编程通常要使用到若干反射机制。 类型、类和模块Types,Classes And Modulesmodule A end module B; include A; end; class C; include B; end; C &lt; B #true B &lt; A #true C &lt; A #true Fixnum &lt; Integer #True Integer &lt; Fixnum #false not all integers are fixnums Integer &lt; Comparable #true String &lt; Numeric #nil, strings are not numbers A.ancestors #[A] B.ancestors #[B,A] C.ancestors #[C, B, A, Object, Kernel, BasicObject] String.ancestors #[String, Comparable, Object, Kernel, BasicObject] C.include?(B) #true C.include?(A) #true B.include?(A) #true A.include?(A) #false A.include?(B) #false A.included_modules #[] B.included_modules #[A] C.included_modules #[B,A,Kernel] include方法为Module模块的私有方法，所以只能在类或模块的定义中才可以使用。与include方法相关的是公开方法:extend。它可以将制定模块的实例方法作为调用对象的单键方法。 定义类和模块Ruby可以动态的创建一个匿名模块或类并赋值给一个常量，常量的名字就称为这个模块或类的名字: M = Module.new #module M C = Class.new #class C D = Class.new(C) { #D is a subclass of C that includes module M include M } D.to_s #D Evaluating Strings and BlocksRuby中最强大和最直接的反射特性之一就是eval方法，它可以对字符串进行求值。 x = 1; eval &quot;x + 1&quot; #2 bingding方法返回一个实例变量的绑定状态。Bingding对象可以作为第二个参数传递给eval方法，指定的字符串就会在绑定的上下文中进行求值。 class Object def bingdings bingding end end class Test def initialize(x) @x = x end end t = Test.new(10) eval(&quot;@x&quot;, t.bingdings) #10 instance_eval和class_evalObject类定义了instance_eval方法，Module类定义了class_eval方法，这些方法都可以像eval一样对Ruby代码进行求值。但是和eval还是有些区别的。1.这些方法会在指定对象或模块的上下文中对代码进行求值，该对象或模块成为代码求值时self的值。 instance_eval方法为某个对象创建了一个单键方法，而class_eval则定义了一个普通方法。 2.它们可以对代码块进行求值。当参数是代码块而非字符串时，代码块中的代码会在适当的上下文中执行。 String.class_eval { def len size end } instance_exec和class_execRuby 1.9中还定义了instance_exec和class_exec两个求值方法，这些方法在接受者对象的上下文中对给定的代码块求值。与前面的class_eval等不同的的地方在于exec可以接收参数，并把参数传递给代码。这样给定的代码块会在给定对象的上下文中执行，并可以获得对象外的参数。 class Point; end x = 10 p = Point.new p.instance_exec(x) { |x| puts x } 变量和常量Kernel、Object和Module类定义了很多反射方法列出各种名字，包括所有定义的全局变量、局部变量、实例变量、类变量和常量。 global_variables #[:$;, :$-F, :$@, :$!, :$SAFE, :$~, :$&amp;, :$`, :$&apos;, :$+, :$=, :$KCODE, :$-K, :$,, :$/, :$-0, :$\, :$_, :$stdin, :$stdout, :$stderr, :$&gt;, :$&lt;, :$., :$FILENAME, :$-i, :$*, :$?, :$$, :$:, :$-I, :$LOAD_PATH, :$&quot;, :$LOADED_FEATURES, :$VERBOSE, :$-v, :$-w, :$-W, :$DEBUG, :$-d, :$0, :$PROGRAM_NAME, :$-p, :$-l, :$-a, :$binding, :$1, :$2, :$3, :$4, :$5, :$6, :$7, :$8, :$9] x = 1 local_variables #[:x,:_] class Point def initialize(x,y) @x,@y = x,y end @@n = 0 ORIGIN_POINT = Point.new(0,0) end Point::ORIGIN_POINT.instance_variables #[:@x, :@y] Point.class_variables #[:@@n] Point.constants #[:ORIGIN_POINT] 查询、修改、检测变量Ruby有很多反射方法用于查询、设置和删除变量、类变量、常量。 x = 1 varname = &quot;x&quot; eval(varname) #1 eval(&quot;varname = &apos;$g&apos;&quot;) #$g eval(varname) #nil,because varname now is $g,so its eval is nil eval(&quot;#{varname} = x&quot;) #1 eval可以任何对象的实例变量、任何类或模块的类变量和常量进行查询、设置和存在性检测操作: o = Object.new o.instance_variable_set(:@x, 0) #require @ prefix o.instance_variable_get(:@x) #0 o.instance_variable_defined?(:@x) #true Object.class_variable_set(:@@x, 1) Object.class_variable_get(:@@x) #1 Object.class_variable_defined?(:@xx) Math.const_set(:EPI, Math::PI * Math::E) #8.539734222673566 Math.const_get(:EPI) Math.const_defined?(:EPI) 在Ruby 1.9中如果把false作为const_get和const_defined?的第二个参数，则对应的变量是在当前类或模块中进行查找，不会去寻找父类或模块的常量。 Object和Module对象中的一些私有方法被用来取消实例变量、类变量和常量的定义，它们都返回被删除变量或常量的值。因为这些方法都是私有的，所以不能直接用在对象、类和模块上，只能通过eval或send方法完成。 o.instance_eval { remove_instance_variable :@x } String.class_eval { remove_class_variable :@@x } Math.send :remove_const, :EPI 如果一个模块定义了const_missing方法，当找不到该变量的时候，该方法就会被调用。 def Symbol.const_missing(name) name #return the name of the missing Const end Symbol::TEST #:TEST Methodso = &quot;hello world&quot; o.methods #all the public methods of String o.public_methods #the same as the above o.public_methods(false) #the inherited methods o.protected_methods #all the protected methods o.private_methods #all the private Methods o.private_methods(false) #inherited private methods def o.single; 1; end o.singleton_methods #:single #Query String.instance_methods == &quot;s&quot;.public_methods #true String.instance_methods(false) == &quot;s&quot;.public_methods(false) #true String.public_instance_methods == String.instance_methods #true String.protected_instance_methods #[] String.private_instance_methods(false) #[:initialize, :initialize_copy] #Check String.public_method_defined? :reverse #true String.protected_method_defined? :reverse #false String.private_method_defined? :initialize #true String.method_defined? :upcase #true Module.method_defined?方法用于检测给定的名称是否用于定义了一个公开或保护的方法，它与Object.respond_to?方法的功能基本类似。在Ruby 1.9中可以制定该方法的第二个参数为false表示不考虑继承方法。 要查询某个特定名称的方法，可以在任意对象上调用method方法，或者在任意模块上调用instance_method方法。前者返回一个绑定于接收者的可调用Method对象，后者返回一个UnboundedMethod对象。在Ruby 1.9中，可以使用public_method和public_instance_method来获取对象的公开方法。 &quot;o&quot;.method(:reverse) #&lt;Method: String#reverse&gt; String.instance_method(:reverse) #&lt;UnboundMethod: String#reverse&gt; 通常调用一个有名字的方法使用send方法: &quot;o&quot;.send :upcase #O Math.send(:sin, Math::PI / 2) #1 send在接收者对象上调用名为第一个参数的方法，后面的其他参数作为调用方法的参数。方法名send来自于面向对象编程的术语，调用一个方法，即向对象&quot;发送&quot;一个消息。 send方法可以调用一个对象的任意有名方法，也包括私有或保护方法。 同样的在Ruby 1.9中定义了一个以public开头的方法，使send只调用公开的方法 上面说到了如何调用一个方法，那么如何在一个类中添加、取消或者别名一个方法呢？ 如果想要定义一个新的实例方法，可以使用define_method方法，它是Module的实例方法，第一二参数是新方法的名字，方法体要使用Method对象或代码块作为第二个参数。define_method是一个私有方法，所以必须在类或模块中调用它。 def add_method(c, m, &amp;b) c.class_eval{ define_method(m, &amp;b) } end add_method(String, :greet) { &quot;Hello, &quot; + self } &quot;world&quot;.greet #hello world #define a class method def add_class_method(c, m, &amp;b) eigenclass = class &lt;&lt; c; self; end eigenclass.class_eval { define_method(m, &amp;b) } end add_class_method(String, :greet) { |name| &quot;hello &quot; + name } String.greet(&quot;world&quot;) #hello world 在Ruby 1.9中，可以直接使用define_singleton_method方法来定义一个类方法: String.define_singleton_method(:greet) { |name| &quot;hello &quot; + name } define_method的缺点是不能定义方法体使用代码块的方法。 如果想动态创建一个接受代码块的方法，需要联合使用def和class_eval方法。如果要创建的方法有足够的动态性，可能无法把一个代码块传给class_eval方法，这时则需要用一个字符串表示要定义的方法，然后对它进行求值。 如果需要对方法创建同义或别名方法，可以使用alias语句: alias plus + 在动态编程时，有时需要使用alias_method方法。alias_method经常用于创建别名链。 def backup(c, m, prefix=&quot;orig&quot;) n = :&quot;#{prefix}_#{m}&quot; c.class_eval { alias_method n, m } end backup(String, upcase) &quot;o&quot;.orig_upcase #O undef方法用于取消一个方法的定义，但是这仅适用于硬编码标识符表示名字的方法。如果需要动态删除一个方法，可以使用remove_method或undef_method。它们都是Module类的私有方法，remove_method用于删除当前类中的方法定义，如果在父类中包含该方法，那么该方法会被继续继承下来，而undef_method则会不允许再次在实例上调用该方法。 method_missing方法通常是在Ruby无法找到某个方法时所调用的方法，默认情况下method_missing只是抛出NoMethodError异常，如果不对异常进行捕获，那么整个程序就会退出。 class Hash def method_missing(key, *args) text = key.to_s if text[-1,1] == &quot;=&quot; #if key ends with = set a value self[text.chop.to_sym] = args[0] else self[key] end end end h = {} h.one = 1 #the same as h[:one] = 1 puts h.one #1 HooksModule、Class和Object类实现了若干回调方法，这些方法也被称为钩子方法。钩子方法并非默认定义的，在特定事件发生时会被调用。这样我们可以在定义子类、包含模块或定义方法时可以扩展Ruby的行为。它们通常以ed结尾。 在一个类被继承的时候，通常会回调它的inherited方法，当模块被包含时，会调用它的included方法： module Final def self.included(c) c.instance_eval do def inherited(sub) raise Exception, &quot;Attempt to create subclass #{sub} of Final class #{self}&quot; end end end end 如果一个模块定义了一个名为extended的类方法，那么它将在一个对象扩展该模块时被调用。 除了有跟踪包含类和模块的钩子方法，还有用于跟踪类和模块的方法的钩子方法，以及跟踪任意单键方法的钩子方法。如果为人以类或模块定义了一个名为method_added的方法，它将在该类或模块定义一个实例方法时被调用。 def String.method_added(name) puts &quot;New instance method #{name} added to String.&quot; end method_added方法会被子类所继承。但是因为这个钩子方法没有任何类信息的参数，所以在添加某个方法时，是无法直到是定义method_added方法所在的类添加的还是子类添加的。解决这个问题的方法是为定义method_added的类的同时定义inherited方法，然后在inherited方法为每个子类定义一个method_added方法。 class Strict def self.method_added(name) STDERR.puts &quot;Warning: #{name} method added&quot; remove_method name end end class Strict def a end end #Warning: a method added s = Strict.new s.a #NoMethodError: undefined method `a&apos; ObjectSpace和GCObjectSpace模块定义了一组方便的的低级方法，对调试和元编程有所帮助。最重要的方法为:each_object，它可以迭代解释器知道的每个对象。 ObjectSpace.each_object(Class) { |c| puts c } #in ruby 1.9 it will about 383 objects _id2ref是Object.object_id的反向方法，它的参数是一个对象ID，它返回相对应的对象；如果没有对应的对象，则抛出一个RangeError异常。 ObjectSpace.define_finalizer可以注册一个Proc对象或一个代码块，它们在给定对象被垃圾收集时调用。任何用于终结(finalize)对象的值必须能够被finalizer块获得，这样它们无需通过被终结对象而使用。它的反向方法为undefine_finalizer。 ObjectSpace.garbage_collect强制让Ruby运行垃圾收集器。垃圾收集功能也可以通过GC模块获得。GC.start是ObjectSpace.garbage_collect的同义方法，可以通过GC.disable方法临时关闭垃圾收集，用GC.enable使之再次生效。 class Object def trace(name=&quot;&quot;, stream=STDERR) TraceObject.new(self, name, stream) end end class TraceObject instance_methods.each do |m| m = m.to_sym next if m == :object_id || m == :__id__ || m == :__send__ undef_method m end def initialize(o, name, stream) @o = o @n = name @trace = stream end def method_missing(*args, &amp;block) m = args.shift #the method name begin arglist = args.map { |a| a.inspect }.join(&apos;, &apos;) @trace &lt;&lt; &quot;Invoking: #{@n}.#{m}(#{arglist}) at #{caller[0]}\n&quot; r = @o.send m, *args, &amp;block @trace &lt;&lt; &quot;Returning: #{r.inspect} from #{@n}.#{m} to #{caller[0]}\n&quot; r rescue Exception =&gt; e @trace &lt;&lt; &quot;Rasing: #{e.class}:#{e} from #{@n}.#{m}\n&quot; raise end end def __delegate @o end end 动态创建方法#Method 1: class_eval class Module private def readonly(*syms) return if syms.size == 0 code = &quot;&quot; syms.each do |s| code &lt;&lt; &quot;def #[s]; @#{s}; end\n&quot; end class_eval code end def readwrite(*syms) return if syms.size == 0 code = &quot;&quot; syms.each do |s| code &lt;&lt; &quot;def #{s}; @#{s}; end\n&quot; code &lt;&lt; &quot;def #{s}=(value); @#{s} = value; end\n&quot; end class_eval code end end #Method 2:define_method class Module def attributes(hash) hash.each_pair do |sym, default| getter = sym setter = :&quot;#{sym}&quot; variable = :&quot;@#{sym}&quot; define_method getter do if instance_variable_defined? variable instance_variable_get variable else default end end define_method setter do |value| instance_variable_set variable, value end end end def class_attrs(hash) eigenclass = class &lt;&lt; self; self; end eigenclass.class_eval { attributes(Hash) } end private :attributes, :class_attrs end Alias Chainingmodule ClassTrace T = [] if x = ARGV.index(&quot;--traceout&quot;) OUT = File.open(ARGV[x+1], &quot;w&quot;) ARGV[x+2] = nil else OUT = STDERR end end alias ori_load load alias ori_require require def require(file) ClassTrace::T &lt;&lt; [file, caller[0]] ori_require file end def load(*args) ClassTrace::T &lt;&lt; [args[0], caller[0]] ori_load(*args) end def Object.inherited(c) ClassTrace::T &lt;&lt; [c, caller[0]] end at_exit { o = ClassTrace::OUT o.puts &quot;=&quot;*60 o.puts &quot;Files loaded and Classes Defined:&quot; o.puts &quot;=&quot;*60 ClassTrace::T.each do |what, where| if what.is_a? Class o.puts &quot;Defined:#{what} at #{where}&quot; else o.puts &quot;Loaded:#{what} at #{where}&quot; end end } #Tracing Methods class Object def trace!(*methods) @_traced = @_traced || [] methods = public_methods(false) if methods.size == 0 methods.map! { |m| m.to_sym } methods -= @_traced return if methods.empty? @_traced |= methods SDTERR &lt;&lt; &quot;Tracing #{methods.join(&apos;, &apos;)} on #{object_id}\n&quot; eigenclass = class &lt;&lt; self; self; end methods.each do |m| eigenclass.class_eval %Q{ def #{m}(*args, &amp;block) begin STDERR &lt;&lt; &quot;Entering #{m}(\#{args.join(&apos;, &apos;)})\n&quot; result = super STDERR &lt;&lt; Exiting #{m} with \#{result}\n&quot; result rescue STDERR &lt;&lt; &quot;Aboring #{m}: \#{$!.class}, \#{$1.message}&quot; raise end } end end def untrace!(*methods) if methods.size == 0 methods = @_traced STDERR &lt;&lt; &quot;Untracing all methods on #{object_id}&quot; else methods.map! { |m| m.to_sym } methods &amp;= @_traced STDERR &lt;&lt; &quot;Untracing #{methods.join(&apos;, &apos;)} on #{object_id}\n&quot; end @_traced -= methods (class &lt;&lt; self; self; end).class_eval do methods.each do |m| remove_method m end end if @_traced.empty? remove_instance_variable @_traced end end end DSL(Domain-Specific Language)领域特定语言是对Ruby句法或API的扩展，可以用更自然的方式处理问题或表现数据。 class XML def initialize(out) @out = out end def context(text) @out &lt;&lt; text.to_s end def comment(text) @out &lt;&lt; &quot;&lt;!-- #{text} --&gt;&quot; nil end def tag(tagname, attributes={}) @out &lt;&lt; &quot;&lt;#{tagname}&quot; attributes.each {|attr,value| @out &lt;&lt; &quot; #{attr}=`#{value}`&quot;} if block_given? @out &lt;&lt; &apos;&gt;&apos; content = yield if content @out &lt;&lt; content.to_s end @out &lt;&lt; &quot;&lt;/#{tagname}&gt;&quot; else @out &lt;&lt; &apos;/&gt;&apos; end nil end alias method_missing tag def self.generate(out, &amp;block) XML.new(out).instance_eval(&amp;block) end end pagetitle = &quot;Test Page for XML.generate&quot; XML.generate(STDOUT) do html do head do title { pagetitle } comment &quot;This is a test&quot; end body do ul :type =&gt; &quot;sequare&quot; do li { Time.now } li { RUBY_VERSION } end end end end #Example 2 class XMLGrammar def initialize(out) @out = out end def self.generate(out, &amp;block) new(out).instance_eval(&amp;block) end def self.element(tagname, attributes={}) @allowed_attributes ||= {} @allowed_attributes[tagname] = attributes class_eval %Q{ def #{tagname}(attributes={}, &amp;block) tag(:#{tagname}, attributes, &amp;block) end } end OPT = :opt REQ = :req BOOL = :bool def self.allowed_attributes @allowed_attributes end def content(text) @out &lt;&lt; text.to_s nil end def comment(text) @out &lt;&lt; &quot;&lt;!--#{text}--&gt;&quot; nil end def tag(tagname, attributes={}) @out &lt;&lt; &quot;&lt;#{tagname}&quot; allowed = self.class.allowed_attributes[tagname] attributes.each_pair do |key, value| raise &quot;unknown attributes:#{key}&quot; unless allowed.include?(key) @out &lt;&lt; &quot; #{key}=&apos;#{value}&apos;&quot; end allowed.each_pair do |key, value| next if attributes.has_key? key if (value == REQ) raise &quot;required attributes &apos;#{key}&apos; missing in &lt;#{tagname}&gt;&quot; elsif value.is_a? String @out &lt;&lt; &quot; #{key}=&apos;#{value}&apos;&quot; end end if block_given? @out &lt;&lt; &apos;&gt;&apos; content = yield if content @out &lt;&lt; content.to_s end @out &lt;&lt; &quot;&lt;/#{tagname}&gt;&quot; else @out &lt;&lt; &apos;/&gt;&apos; end nil end end class HTMLForm &lt; XMLGrammar element :form, :action =&gt; REQ, :method =&gt; &quot;GET&quot;, :enctype =&gt; &quot;application/x-www-form-urlencoded&quot;, :name =&gt; OPT element :input, :type =&gt; &quot;text&quot;, :name =&gt; OPT, :value =&gt; OPT, :maxlength =&gt; OPT, :size =&gt; OPT, :src =&gt; OPT, :checked =&gt; BOOL, :disabled =&gt; BOOL, :readonly =&gt; BOOL element :textarea, :rows =&gt; REQ, :cols =&gt; REQ, :name =&gt; OPT, :disabled =&gt; BOOL, :readonly =&gt; BOOL element :button, :name =&gt; OPT, :value =&gt; OPT, :type =&gt; &quot;submit&quot;, :disabled =&gt; OPT end HTMLForm.generate(STDOUT) do comment &quot;This is a simple HTML form&quot; form :name =&gt; &quot;registration&quot;, :action =&gt; &quot;http://test.cig&quot; do content &quot;Name:&quot; input :name =&gt; &quot;name&quot; content &quot;Address:&quot; textarea :name =&gt; &quot;address&quot;, :rows =&gt; 6, :cols =&gt; 40 do &quot;Please enter your mailing address here&quot; end button { &quot;Submit&quot; } end end]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Metaprograming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby中的方法、过程、Lambda和闭包(学习笔记)]]></title>
    <url>%2F2012%2F06%2F23%2Fmethods-procs-lambdas-and-closures%2F</url>
    <content type="text"><![CDATA[Method 方法是一个有名代码块，与一个或多个对象相关联的参数化代码。调用方法时需要给出方法名、所在对象以及零个或多个与有名参数对应的参数值。方法中的最后一个表达式作为方法的返回值。 取消方法的定义取消方法的定义可以使用undef，但是如果想要取消单例方法，不能使用它。在方法或模块中可以使用undef_method。 12345def hello "hello world"endundef hello 定义方法的习惯 方法的名词一般都是以小写字母命名的，如果方法是多个名词，那么用下划线来分割。方法的定义有一个需要注意的地方： 如果方法名以?结尾，那么此类的方法称为&quot;断言式&quot;方法，通常情况下返回false,true或nil，但也不尽然。比如Numberic的nonzero?方法，如果为0则返回nil，否则返回原来的值。当然Ruby中以false和nil判断为False,除此之外的值都是认为是True的。 方法名以!结尾的方法，则提示该方法是比较危险的，会修改对象的实例变量的值。以!定义的方法通常是可变方法。也有一些方法不以!结尾，但是属于可变方法。 操作符方法Ruby本身是很对象化的编程语言，所以操作符其实也是一种方法。对于int,float这些类的操作符是不可继承的。 如何定义这些方法呢? 1234567def +(other) self.age + otherenddef [](index) self.ary[index]end 方法的重命名人有七名八姓，Ruby有方法重命名。方法重命名可以使用不同的方法名对某个方法进行调用。亦然以我们更加容易理解的名称来命名某些方法。比如Range类的include?和member？，Kernel类的raise和fail。方法重命名并不是进行方法的重载，仅仅是对方法名的重新命名。 123456789def hello "say hello"endalias say_hello hellodef hello "can u say hello?"end 我们常见的括号呢？先举个例子： 12puts "hello world"puts ("hello world") 上面的方法调用有区别吗？在形式上是有区别的，但是实质上是一样的。因为在Ruby中通常是忽略括号的，如果一个方法只有一个甚至没有参数时，括号可以省略；如果方法有多个参数时，原括号也是可以省略的，但是不能说很常见。 但是什么时候必须要括号呢？在有可能引起歧意的时候。比如&quot;f g x y&quot;，通常ruby会解释成&quot;f(g(x,y))&quot;。为了消除歧义性或为了方便人们的阅读，必要的括号还是很重要的。 看下面的例子: 12seq(2+2) * 2seq (2+2) * 2 上面的例子有区别吗？有。第一个括号表示方法的调用，2+2是方法的参数，而后者是用于分组，seq的参数为 （2+2）* 2。也就是说如果括号紧跟着一个方法名，那么括号里面的变量都是认为是方法的参数的，如果有空格之类的，那么连同括号，都是方法的参数。 12puts(sum 2,2)puts (sum 2,2) 同样的例子。上面的调用是有歧义的，与puts sum 2, 2是没有任何区别的。所以为了正确表达，需要用括号进行分组，在方法名后面用空格分隔。 方法的参数1.带默认参数的方法 123456def hello(name, family='Wei') "hello, #&#123;name&#125; family"endputs hello('david')puts hello('david','Green') 方法的默认参数不一定是常量，还可以是任意的表达式，也可以是实例变量的引用，还可以是对前面定义的参数的引用。参数的默认值是在运行时才进行求值，而不是在解析时。 在Ruby 1.9中放开了原来1.8中规定的默认参数必须在参数列表在最后面的限制，但是仍然要求默认参数必须连续，不能中间插入其它的变量。 2.任意个数的参数 任意个数的参数需要在参数名称前面加上*,它表示这部分传递的是一个数组。btw.数组的个数也有可能为0。 用*打头的参数不能超过一个,一般该参数是放在其它参数的后面，在1.9中稍微放开了些，可以放在其它普通参数的前面，但是必须放在默认参数的后面和含&amp;打头参数的前面。 如果传递的参数为Hash，且Hash为最后一个参数(可以有&amp;代码块)，那么Hash的大括号可以去掉。如果在传递Hash参数的时候是省略了方法的括号的，那么Hash的大括号也要去掉，因为Ruby会认为你给它传递的不是Hash，而是一个代码块，从而运行报错。 代码块参数 12345def seq(n,m,o) yield n * m + 0endseq(2,3,4)&#123; |x| puts x &#125; 上面就是一个比较简单的调用代码块参数的例子。只不过代码块参数不是明确写在方法的参数列表中，而是通过yield来进行调用代码块参数。代码块有一个特点:匿名性。它们没有名字，只是通过一个关键字对它进行调用。如果需要明确地方式来控制一个代码块，可以在方法的最后面加上一个参数，并使用&amp;作参数的前缀。这个参数的值有了些许变化，它的值(含&amp;)是Proc对象，在调用的时候不是简单的使用yield来调用，而是需要用Proc的call方法来调用。 12345def seq(n,m,o,&amp;b) b.call (n * m + o)endseq(2,3,4)&#123; |x| puts x &#125; 如果上面例子中的b本身是一个Proc对象，那么&amp;是不要的。其它的调用方法也是一样的。 1234567def seq(n,m,o,b) b.call (n * m + o)endproc = Proc.new &#123; |x| puts x &#125;seq(2,3,4,proc) 上面说到了，可以使用&amp;将一个代码块转换为proc对象，那么proc对象是否可以变为代码块呢？档案是可以。 1234a,b = [1,2,3],[4,5] #并行赋值表达式sum = a.inject(0) &#123; |total, x| total + x &#125;sum = b.inject(sum) &#123;|total, x| total + x&#125; 上面的代码块是相同的，在运行时需要解析2次，所以我们可以将之定义为一个一个Proc对象，调用它2次。 123456a,b = [1,2,3],[4,5]p = Proc.new &#123; |total, x| total + x &#125;sum = a.inject(0, &amp;p)sum = b.inject(sum, &amp;p) &amp;通常出现在一个Proc对象之前，它能支持所有支持to_proc方法的对象，像Method,Symbol都有这个方法，所以我们可以这样使用： 123words = ['i','love','ruby']uppercase = words.map &amp;:upcaseuppercase = words.map &#123;|c| c.upcase&#125; #this line is the same as the one above. Procs and Lambdas代码块是Ruby的一种句法结构，而不是对象，也不能像对象一样操作。不过，我们可以创建对象来表示代码块。创建对象的方式有proc和lambda，前者的行为与代码块类似，后者的行为则与方法类似。 前面我们举的例子里面就包含着创建Proc对象的方法，而且后面都是包含一个代码块的。实际上，如果不包含代码块，那么它默认指向所在方法所关联的代码块；如果在创建的时候包含着代码块，那么它指向它所关联的代码块。 另外一种创建Proc对象的方法是使用lambda方法，它是Kernel模块的方法，返回的Proc对象是一个lambda而非proc。lambda方法不带参数，但是在调用时必须关联一个代码块。 is_positive = lambda {|x| x &gt; 0} 第三种是Kernel模块的proc方法，它在1.8中和lambda是同义的，但是在1.9中它是Proc.new的同义词。 在Ruby 1.9中，Ruby支持了一种全新的方法，将lambda作为字面量。在1.8中定义lambda是这样的： is_positive = lambda {|x| x &gt; 0} 而在Ruby 1.9 中我们我们可以这样做： 把lambda方法名替换为 -&gt; 把大括号内的变量，移到{}的前面。 把参数列表的变量分隔符从||替换为() is_positive = -&gt; (x){ x &gt; 0 } 在新的定义语法中得到的好处是：我们可以定义默认参数了:zoom = -&gt;(x,y,factor=2){x*factor,y*factor}。另外它还很简洁，产生的代码块，如果要传递给一个需要Proc对象的方法时，需要添加&amp;。 data.sort {|a,b| a - b} #变化后: data.sort &amp;-&gt;(a,b){ a - b } 最小的lambda代码为-&gt;{}，它返回的是nil。 调用proc和lambda的方式除了使用call，还可以使用[]和.()Proc类定义了数组访问操作符，它的工作方式和call是相同的，所以可以使用[]来调用proc对象。还可以使用后面的.()的方式来调用。 is_positive[3] is_positive.(3) 如何知道一个Proc对象所需的参数个数呢？使用arity(来源于一元(unary),二元(binary),三元(ternary)) 如果参数中不包含*开头的参数，那么arity返回的是不小于0的参数个数。 如果参数中包含*的参数，那么arity返回的是-n-1的负数，负数说明该方法可以接受额外的参数。-n-1是n的互补数。那么有多少个参数是必须需要的呢？取反-1.即-(-n - 1) - 1=n Lambda和Proc的区别proc是代码块的对象形式，它的行为就像一个代码块；而lambda的行为略微不同，它的行为更像方法而非代码块。调用一个proc则像对代码块进行yield，而调用lambda则像调用了对象的方法。在Ruby 1.9中可以通过Proc的实例方法lambda?来判断某个实例是一个proc还是lambda。如果返回为真，则为lambda，否则为proc。 除了上面的一些区别，还有什么地方不一样呢？ 1 代码块、proc和lambda中的return语句 在一个代码块中的return语句不仅会使代码块返回,还会导致调用它的方法返回。 1234567def test puts "begin of the block" 10.times &#123; |x| return if x == 3 &#125; puts "end of the block"endtest #the result will not output the 'end of the block' proc与代码块类似，因此在proc中执行return，它也会尝试从代码块所在的方法中返回。 12345678def test puts "begin of the block" p = Proc.new &#123;|x| return if x == 3&#125; p.call puts "end of the block"endtest #it is the same result as the one above. proc经常在不同方法之间传递，而如果proc中使用return语句可能会达不到预期的目的，因为在调用proc时，在句法上包含该proc的方法已经返回。 123456789101112def procBuilder(msg) Proc.new &#123; puts "#&#123;msg&#125;"; return &#125;enddef test puts "begin of the block" p = procBuilder('hello') p.call #LocalJumpError: unexpected return puts "end of the block"endtest 除了去掉return语句，还可以使用lambda来修复这个问题。前面说到了lambda在调用时更像是一个方法，所以return语句只会从lambda中返回，而调用它的方法不会。 123456789101112def procBuilder(msg) -&gt;() &#123; puts "#&#123;msg&#125;"; return &#125;enddef test puts "begin of the block" p = procBuilder('msg') p.call puts "end of the block"endtest 顶级的break、redo和next也有相同的行为。在proc和lambda中，retry是禁止使用的:因为它会导致死循环的LocalJumpError异常。 另外在参数上，proc会自动处理传递的参数，少于规定个数的，会自动赋值为nil; 多余规定的参数会被丢弃掉；数组会自动拆开；多个也可以进行打包。 而lambda在处理上则没有如此大的灵活性，参数个数要严格遵守。 Closures闭包在Ruby中，proc和lambda都是闭包。那么神马是闭包呢? 闭包表示一个对象即是一个可以调用的函数，也是绑定在这个函数上的变量。(好晦涩Sigh).当创建一个proc或lambda时，得到的Proc对象不仅包含了可执行的代码块，还绑定了代码块中所使用的所有变量。 闭包的要素包括:对象、函数、绑定的变量。 首先它必须是一个对象，第二它还需要可以被调用，最后它的所有变量都是已经被绑定的。 123456def multiplier(n) -&gt;(data) &#123; data.collect &#123; |x| x * n &#125; &#125;endp = multiplier(2)p.call([1,2,3,4]) #[2, 4, 6, 8] multiplier方法返回一个lambda，它可以在方法返回后继续访问n,它被称为一个闭包。 闭包并不持有它引用的参数，但是持有它所使用的变量并延长了其生命周期。lambda或proc在创建时并不静态绑定所使用的变量，而是在运行时才回去查找变量的值。 1234567891011def test(initValue=nil) value = initValue getter = -&gt; &#123; value &#125; setter = -&gt;(x) &#123; value = x &#125; return getter,setterendgetX, setX = test(2)puts getX[] #the same as getX.callsetX[3]puts getX[] 下面让我们看一个比较晦涩些的代码: 1234567def test(*args) x = nil args.map &#123; |x| lambda &#123;|y| x * y&#125; &#125;enda, b=test(2,3)puts a.call(3) #what is the rest? yes, it is 6. 上面的代码返回的是一组lambda，所以a,b对应的lambda中的x分别为2和3。所以a在调用的时候就为2*3=6了。 Proc定义了一个binding方法，表示该闭包所使用的绑定，返回一个Binding对象。它作为eval的第二个参数，能为eval函数执行时的代码提供上下文环境。使用Binding对象和eval可以让我们获得闭包的后门，可以修改已经绑定的某些值。 123456789def multiplier(n) -&gt;(data) &#123; data.collect&#123; |x| x * n &#125; &#125;enddouble = multiplier(2)puts double([1,2,3])eval("n=3", double.binding)puts double([1,2,3]) #it will be 3,6,9 MethodsRuby的方法和代码块都是可执行的语言构件，但它们不是对象。proc和lambda是代码的对象版本，它们可以被执行。Ruby的方法也可以使用Method的实例来表示，但是通常比直接调用效率要低。Method对象比proc和lambda使用频繁度要低。 Method类不是Proc类的子类，但是它们在行为上很相似.Method对象使用call来表示调用，也有arity方法。Method对象的call方法在调用时使用的是invocation,这一点和lambda相同，而proc使用的是yield调用。 Method对象与Proc对象工作方式非常类似，因此常用来替代Proc对象。在需要Proc对象的地方，可以使用Method.to_proc把Method对象转换为Proc对象。所以我们可以在Method对象前面加&amp;，然后使用这个对象取代代码块作参数传递了。 12345def sequre(x) x ** 2endputs (1..10).map(&amp;method(:sequre)) Method和Proc的一个重要区别是：Method对象不是闭包。 Ruby的方法不会访问在其范围之外的局部变量，唯一绑定的值是self。在Ruby 1.9中添加了3个新方法:name、owner、receiver。name返回方法的名字。owner返回定义该方法的类。receiver返回该方法绑定的对象。 还有一种无绑定的方法。此类方法的获取方式有2种。一种是通过instance_method方法获取，一种是通过unbind获取。 123456myplus = Fixnum.instance_method("+")myplus.bind(3) #绑定对象result = myplus.call(4) #7other_plus = myplus.unbind.bind(3)result = other_plus.call(5) #8]]></content>
      <categories>
        <category>Tech</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Lambda</tag>
        <tag>Proc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改Rails默认生成的Gemfile的source]]></title>
    <url>%2F2012%2F06%2F04%2Fmodify-the-gemfile-template%2F</url>
    <content type="text"><![CDATA[由于大陆的“特殊情况”，rails默认生成的Gemfile的源 https://rubygems.org很慢甚至被重置，所以适应国情，要修改下Rails默认生成的Gemfile文件。 如何做呢？ 很简单，切换到Rails的默认模板路径下，修改Gemfile文件的source: 1.cd $rvm_path/gems/ruby-1.9.3-p194@rails32/gems/railties-3.2.5/lib/rails/generators/rails/app/templates/ 2.修改Gemfile文件，替换https://rubygems.org为`http://ruby.taobao.org` Over~~ 分割线 2016-02-01 更新： 现在只能使用 https 的源了。即: https://ruby.taobao.org]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Rails</tag>
        <tag>Gemfile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby Exception——1]]></title>
    <url>%2F2012%2F05%2F13%2Fruby-exception%2F</url>
    <content type="text"><![CDATA[异常处理真实世界充满了各种不确定性因素，我们的应对的时候都需要考虑到，有所应对。如果没有考虑到这些，后果有时候蛮严重的。我们的程序也是一样的，如果没有处理好异常，那么我们的程序会很失败，很难看。 传统方式学过C语言的筒子们，在操作文件的时候，函数通常会返回一个叫做句柄的东东，通过这个东东来判断我们操作的成功与否，如果出错了，错误的原因又是神马（通过返回代码）。 不同的函数，返回的错误代码是不一样的。而“异常”的出现将错误进行了一定程度上的统一——异常(Exception)类,实现了对象化，异常对象将错误信息进行自动打包，然后返回给能够处理它的Runtime Environment。 异常类继承图异常类的继承关系图： 定义异常如何定义一个异常呢？异常的父类是：Exception，只要自己的类继承自它或者它的子类就可以。 例如： class MyException &lt; RuntimeError attr :my_error def initialize(error) @my_error = error end end 在调用的时候： def read_data(file_stream) if file_stram.nil? raise MyException.new(true), &quot;The file stream is not assigned.&quot; end end 处理异常require &quot;open-uri&quot; page = &quot;podcasts&quot; file_name = &quot;#{page}.html&quot; web_page = open(&quot;http://pragprog.com/#{page}&quot;) output = File.open(file_name, &quot;w&quot;) begin while line = web_page.gets output.puts line end output.close rescue Exception STDERR.puts &quot;Failed to download the page content.&quot; output.close File.delete(file_name) raise end 在抛出异常和处理异常的时候，Ruby把异常对象放到一个叫做“$!”的全局变量中。上面代码中的raise将&quot;$!&quot;抛向上一层处理异常的代码。 在Ruby中，我们可以多次从异常中rescue，执行的顺序和case语句是雷同的。如果异常没有匹配rescue，那么异常会寻找调用者或调用者的调用者中的异常处理对象。 例如： begin expresion1 … rescue SystaxError, NameError =&gt; error_1 puts &quot;This is #{error_1}&quot; rescue StandardError =&gt; error_2 puts &quot;This is #{error_2}&quot; end 在其它语言（Java、Delphi等）有一个关键字“finally”,在遇到异常的时候，它里面的代码依然会执行。这部分的代码作用一般是执行一些清理操作，比如释放一些资源。在Ruby中也有类似的关键字：&quot;ensure&quot;。 例如： begin expression… rescue handle error… ensure clean up end 上面的rescue如果没有参数，默认为StandardError。在上面的代码中的ensure上面，还可以插入一段else代码，它的作用是：如果没有异常执行的操作。不过用途不大。 在rescue中，还可以执行retry方法，它的用途是：重新执行整个being/end语句块。一般在rescue中会有些修正的代码，以便程序可以再次执行。 例如： @eflag = true begin if @eflag then \#then可选 do_sth else do_sth2 end rescue StandardError if @eflag @eflag = false retry else raise end end 抛出异常raise raise &apos;hello world&apos; railse BadArgument, &quot;Arguments Error&quot;, caller 第一种形式只是简单地将当前的异常（如果没有异常，那么抛出的为RuntimeError），一般应用于在继续传递前，拦截某个异常。 第二种形式会新建一个RuntimeError异常，并将后面的信息放到异常信息中，异常会显示调用栈。 第三种形式是在第二种的基础上，添加了异常的类，和调用栈的trace。caller一般是Kernel.caller方法。caller可以跟一个数组，默认返回当前的调用栈信息。 如果想要调用caller的caller异常，可以这样操作： raise $!.class, $!.message, $!.backtrace[2..(-1)] Catch和Throw异常的raise和rescue在程序出错时终止执行，但是有时候使用catch和throw来从nested construct跳出会更适用。 例如： word_list = File.open(&quot;wordlist&quot;) word_in_error = catch(:done) do result = [] while line = word_list.gets word = line.chomp throw(:done, word) unless word =~ /^\w+$/ #word可选 result &lt;&lt; word end puts result.reverse end if word_in_error puts &quot;Failed: &apos;#{word_in_error}&apos; found, but a word was expected&quot; end 上述代码，如果在打开的文件中，如果内容有无效的单词，就会抛出一个Symble（字符串也是可以的）,并将这个单词返回。在后面进行输出。 另外catch不一定要放在throw的静态作用域之内。 例如： def prompt_and_get(prompt) print prompt res = readline.chomp throw :quit_requested if res == &quot;!&quot; res end catch :quit_requested do name = prompt_and_get(&quot;Name: &quot;) age = prompt_and_get(&quot;Age: &quot;) sex = prompt_and_get(&quot;Sex: &quot;) # ..]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习Markdown语法笔记]]></title>
    <url>%2F2012%2F05%2F08%2Flearn-to-markdown%2F</url>
    <content type="text"><![CDATA[Markdown简介Markdown是一种轻量级的标记语言，由John Gruber和Aaron Swartz创建。它的灵感来自于带标记的电子邮件文本。Markdown允许HTML语法，所以在markdown文件里面直接使用html表示也是可以的。 Markdown的优点Markdown能让文档更容易读、写和修改。HTML是一种发布式的格式，Markdown是一种书写的格式。Markdown只涵盖纯文本的范围。在博客中使用Markdown可以更多的关注于文章的内容，少量的地方来控制排版(Markdown的排版符号)。 Markdown编辑工具工具： Windows: MarkdownPad，需要安装.Net 4；Meditor Linux: ReText Mac: Mou或者Sublime Text 2 网页版: Dillinger Chrome扩展: Made,支持左右分屏，即时预览。 Vim插件: Vim+vimviki 区块元素段落和换行一个Markdown段落由一个或多个连续的文本行组成。它的前后要有一行以上的空行。这里的空行是指不包含除了制表符和空格外的字符。 如果想强制换行，那么可以在插入的地方连续输入2个以上的空格即可。 标题Markdown支持两种标题语法：类Setext和类atx形式。前者使用=来表示最高阶标题，-表示第二阶标题。注意这些符号是在标题的下方，个数是任意的（大于一个）例如： This is h1. =========== This is h2. ----------- 显示结果： This is h1.This is h2. 类atx形式则是平常见到比较多的使用1到6个#来不同的标题阶数。数量越多，字体越小。 # This is h1 ## This is h2 显示结果： This is h1.This is h2. 区块引用Markdown标记区块引用是使用类似email中用&gt;的引用方式。使用区块引用只需要在行首使用&gt;即可。如果只是在每个段落的第一行加上&gt;也是可以的。 例如: &gt;Do you know that you are so special. but in some way, I think you are a little too special. &gt; What do you think? 这样都是可以的。 显示结果： Do you know that you are so special. but in some way, I think you are a little too special. What do you think? 如果想要在引用中继续嵌套使用也是可以的，需要做的就是，继续使用&gt;就可以了。另外，引用中的markdown语法是可以正常使用的。 例如： &gt; ## this is a title. &gt; &gt; this is a nested markdown sentence. &gt; 1. item1 &gt; 1. item2 显示结果： this is a title. this is a nested markdown sentence. item1 item2 列表在上面的例子中，我们用到了列表。在markdown中，可以使用*、+、-来作为标记。另外，也可以使用数字+.的方式来作列表，这里的数字不一定要按照顺序来，只要是符合上述规则即可，markdown的最终显示会从1开始逐个显示。 例如: &gt;1.I Love China. &gt;3. I Love Ruby. &gt;1. Item1. &gt;3. Item2. &gt;10. Item3. 显示效果: I Love China. I Love Ruby. Item1. Item2. Item3. 这里需要注意下：如果在显示列表的时候，使用了数字+.和上面3种的混合形式。那么最终的显示效果，以第一行的列表为准。数字+.显示的为数字列表，而前三种显示的为实心点的列表形式。 如果想要在列表中使用引用，那么&gt;需要缩进。如果要放入代码区块的话，需要缩进2次，即8个空格或2个TAB。如果在段落中含有2012. what a fatancy year.,在为了避免被“翻译”成列表，那么需要使用\转义数字后面的那个.。 代码区块作为程序猿经常要使用代码贴在文章中，而这些代码，我们都要保持它的格式不被修改。在Markdown中，markdown会将代码块使用&lt;pre&gt;和&lt;code&gt;标签将之包起来。那么我们如何使用代码块呢?4个空格或者一个TAB。嗯，就是这样简单。例如： def say(gf) puts &quot;Hello, #{gf}.&quot; end 显示效果:如上。代码块会一直持续到没有缩进的行或者文件结束。 分割线什么？想使用分割线?嗯，这个也很简单：使用3个以上的星号、减号、底线就可以。不过这里的要求是：行内只能有以上3中，但不能包含除空格外的其它字符。 例如： * * * ---- - - - ____ __________ ___________ 显示效果： 区段元素链接Markdown支持两种形式的链接语法：行内式和参考式。它们的共同点是：都是使用[]来标记的。 行内式：在方括号后面使用圆括号，并在圆括号中写上链接地址和标题即可(可选)，title字段需要使用双引号包起来。 例如: This is a Link to my site. 显示结果：This is a Link to my site. 这里的链接地址不局限于http这种链接，也可以使用相对链接地址。 参考式： 这种方式指的是在第一个方括号后面要继续使用一个方括号，在后者中要输入链接的目标。这里的方括号不用跟得太”亲密“。XD This is the link to the Top Link. 我在文章上部定义了: top: # &quot;Top of the post.&quot; 显示效果：This is the link to the Top Link. 链接的网址也可以使用方括号&lt;&gt;包起来，定义ID的地方，后面在跟一个冒号后，需要加一个空格或制表符，Title可选，使用逗号隔开。 链接的标识标签可以使用字母、数字、空白和标点符号，不区分大小写。 隐式链接能够让我们省略制定的标记。在原来的方括号后面，添加一个空的方括号，默认会跳转到http:标识.com的链接上去。 例如： [Google][] [Goole]: http://google.com 结果: [Google][][Google]: http://google.com 链接的定义位置任意。下面我们就将本文的参考代码写在下面： 本文参考的链接包括wowubuntu和appinn [1]: http://wowubuntu.com &quot;WowUbuntu.com&quot; [2]: http://www.appinn.com &quot;Appinn.com&quot; 显示效果:本文参考的链接包括wowubuntu和appinn 强调我们可以使用*和_来强调某个词，单个的字符使用的标签为&lt;em&gt;,使用2个则为&lt;strong&gt;。不过在使用的时候，这两个标记在使用的时候不要都有空白，否则它就是普通”群众“了。 代码行内的一小段代码，可以使用反引号（在TAB上面的那位）来将其包起来 ``There is a back door here`.`` There is a back door here`. 图片最后我们说下图片。图片在一个文章中必不可少，有助于帮助读者更好的理解作者的意图。那么在Markdown中如何使用图片链接呢？ 不过Markdown没有办法来指定图片的宽高，所以如果图片太BIG，请选择&lt;img&gt;标签，因为Markdown是兼容这些标签滴。 下面我们贴一个指向ruby china社区Logo的图片： 显示结果： Others另外如果使用尖括号将网址、邮箱放在里面，你会发现，Markdown 已经为了做了很多事。 http://snail.github.com Contact Me: &lt;godhuyang@gmail.com&gt; 显示结果:http://snail.github.com Contact Me: &#103;&#111;&#100;&#104;&#x75;&#x79;&#x61;&#110;&#x67;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d; 好了，到此结束。收工，睡觉。Good Night.]]></content>
      <categories>
        <category>Tech</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ruby Platform]]></title>
    <url>%2F2012%2F02%2F14%2Fruby-platform%2F</url>
    <content type="text"><![CDATA[Strings123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105s = "hello"s.concat(" world") #the same as &lt;&lt;s.insert(5, " there") #s[5] = " there"s.slice(0,5) #the same as s[0,5]s.slice!(5,6) #same as s[5,6] = ""s.eql?("hello world") #true#the length of string s = "hello"s.length #5s.bytesize #5 中文为每字3byte,ASCII为1bytes.size # 5s.empty? #false"".empty? #trues = "hello"s.index('l') #2s.index(?l) #2s.index(/l+/) #2s.index('l',3) #the first position after position 3 of ls.index('Ruby') #nils.rindex('l') #3s.rindex('l',2) #2 index of rightmost l at or before position 2s.start_with? "hell" #trues.end_with? "bells" #falses.include?('ll') #trues.include?(?H) #falses =~ /[aeiou]&#123;2&#125;/ #nils.match(/[aeiou]/) &#123;|m| m.to_s&#125; #e return first"this is it".split #this is it "hello".split('l') #['he','','o']"1, 2,3".split(/,\s*/) #1,2,3"banana".partition("an") #["b", "an", "ana"] "banana".rpartition("an") #["ban", "an", "a"] "a123b".partition(/\d+/) #["a", "123", "b"] s = "hello"s.sub('l', 'L') #replace the first l to Ls.gsub("l", "L") #replace all the l to Ls.sub!(/(.)(.)/, '\2\1') #swap first characters.sub!(/(.)(.)/, '\\2\\1') #"ehllo" Double backslashes for double quotes"hello world".gsub(/\b./) &#123; |match| match.upcase &#125; #Hello Worlds = "hello"s.upcase #HELLOs.downcase #hellos.capitalize #Hellos.swapcase #HELLOs.casecmp("HELLO") #0 case insensitive comparasions = "hello\r\n"s.chomp #"hello"s.chomp("o") #hell $/ = ";" #set global separator $/ to semicolon"hello;".chomp #hellos = "hello\n"s.chop #hello remove line terminator removed, redo will be hell s = "\t hello \n"s.strip #hello s.lstrip #hello \ns.rstrip #\t hello s = "x"s.ljust(3) #"x "s.rjust(3) #" x"s.center(3) #" x "s.center(5, '-') #"--x--"s.center(7, '-=') #"-=-x-=-"s = "A\nB"s.each_byte &#123; |b| print b, " " &#125; #65 10 66s.each_line &#123; |l| l.chomp &#125; #ABs.each_char &#123; |c| print c, " " &#125; #A \n B 0.upto(s.length - 1) &#123;|n| print s[n,1], " "&#125;"a".succ #b"aaz".next #aba"a".upto("e") &#123;|c| print c&#125; #abcde"hello".reverse #olleh"hello\n".dump #escape special character "\"hello\\n\"" "hello\n".inspect #the same as dump"hello".tr("aeiou", "AEIOU") #hEllO capitalize vowels"head".tr_s("aeiou", "*") #h*d #remove duplicates"hello".sum #weak 16-bit checksum "hello".sum(8) #8 bit checksum "hello".crypt("ab") #crypt hello with salt ab。"abl0JrMf6tlhw" "hello".count('aeiou') #2"hello".delete('aeiou') #hll"hello".squeeze('a-z') #helo remove runs of letters. "hello".count('a-z', '^aeiou') #3 str.count([other_str]+) Each other_str parameter defines a set of characters to count. The intersection of these sets defines the characters to count in str. Any other_str that starts with a caret (^) is negated. The sequence c1–c2 means all characters between c1 and c2."hello".delete('a-z', '^aeiou') #eo str.delete([other_str]+) Returns a copy of str with all characters in the intersection of its arguments deleted. Uses the same rules for building the set of characters as String#count. 正则表达式Regexpression正则表达式修饰符i:匹配时忽略大小写m:跨行进行模式匹配，换行符被当做普通字符对待。x:扩展句法，允许在整个表达式中放入空白符和注释。u,s,e,n: 吧正则表达式解释为Unicode,SJIS,EUC或ASCII，如果没有这样的修饰符，对正则表达式使用源文件的编码方式。 在正则表达式中(),[],{},.,?,+,*,|,^和$具有特殊意义，如果在某个匹配模式中包含这些字符的字面量，要用反斜杠进行转义。 Ruby正则表达式中，字面量可以用#{}插入任意的Ruby表达式。 正则表达式工厂方法除了直接使用字面量，还可以使用Regexp.new或Regexp.compile来创建一个正则表达式。 12Regexp.new("Ruby?") #/Ruby?/Regexp.compile("Ruby", Regexp::IGNORECASE, "u") 在把一个字符串传递给Regexp的构造方法之前，可以使用Regexp.escape对字符串中的特殊字符进行转义。 12345pattern = "[a-z]+"suffix = Regexp.escape("()") #treat these characters literallyr = Regexp.new(pattern + suffix) #/[a-z]+\(\)//R(?i)uby/ #Ignore the case of 'uby' $~是一个特殊的线程局部和方法局部变量，它在两个并行运行的线程中的值是不同的;使用了=~操作符的方法不会修改调用者方法中的$~变量。 1234567891011"hello" =~ /e\w&#123;2&#125;/$~.string #hello$~.to_s #ell$~.pre_match #h$~.post_match #oif /(?&lt;lang&gt;\w+) (?&lt;ver&gt;\d+(\.\d)+) (?&lt;review&gt;\w+)/ =~ "Ruby 1.9.3 Pre" lang #Ruby ver #1.9.3 review #Preend 变量 等价于 $~ RegExp.last_match $&amp; RegExp.last_match[0] $` RegExp.last_match.pre_match $&#39; RegExp.last_match.post_match $1 RegExp.last_match[1] $2,etc RegExp.last_match[2] $+ RegExp.last_match[-1] 字符串进行模式匹配123"ruby123"[/\d+/] #123"ruby123"[/([a-z]+)(\d+)/, 1] #ruby "ruby123"[/([a-z]+)(\d+)/, 2] #123 slice方法是[]方法的同义词方法，不过slice!变体返回值与它相同，并且将从字符串中删除返回的匹配子字符串。 123456789101112r = "ruby123"r.slice!(/\d+/) #return 123 and r will be ruby pattern = /(['"])([^\1]*)\1/text = "He said: 'hello world'"text.gsub(pattern) do if $1 == '"' "'#$2'" else "\"#$2\"" endend]]></content>
      <categories>
        <category>Tech</category>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
      </tags>
  </entry>
</search>
