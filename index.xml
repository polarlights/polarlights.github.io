<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Polarlights</title>
    <link>https://polarlights.github.io/</link>
    <description>Recent content on Polarlights</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 03 Aug 2019 23:50:02 +0800</lastBuildDate>
    
        <atom:link href="https://polarlights.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>bean validation tutorial</title>
      <link>https://polarlights.github.io/post/bean-validation-tutorial/</link>
      <pubDate>Sat, 03 Aug 2019 23:50:02 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/bean-validation-tutorial/</guid>
      
        <description>&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_preface&#34;&gt;Preface&lt;/h2&gt;&lt;p&gt;在开发 Web 接口的时候，客户端给到的输入参数往往是不可控，亦不可信的；需要在 server 端做一些校验，以使处理数据符合业务预期；除了web 接口之外，我们写的方法、DAO 对象都有类似的需求。也就是校验的需求贯穿服务的各个层。&lt;/p&gt;
&lt;p&gt;简单粗暴一点的可以在每一层这样写：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre&gt;if (param.getName() == null) {
  throw BadRequestException(&#34;name can not be null&#34;);
}
if (param.getAge() &amp;lt; 1) {
  throw BadRequestException(&#34;age can not less than 1&#34;);
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果遇到错误，我想最后统一抛出，用户可以一次知道哪些输入是有问题。那么我们可以这样写:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre&gt;List&amp;lt;String&amp;gt; errorMessages = new ArraysList&amp;lt;&amp;gt;();

if (params.getName() == null) {
  errorMessages.add(&#34;name can not be null&#34;);
}

if (param.getAge() &amp;lt; 1) {
  errorMessages.add(&#34;age can not less than 1&#34;);
}

if (errorMessages.size() &amp;gt; 0) {
  ...
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样写会有什么样的问题呢？&lt;/p&gt;
&lt;p&gt;① 通用性不够 ② 重复代码很多&lt;/p&gt;
&lt;p&gt;那么如何解决这个问题呢？ Java 提供了 Bean Validation 的概念，先后经过了 &lt;a href=&#34;https://beanvalidation.org/1.0/spec/&#34;&gt;[JSR303, 2009]&lt;/a&gt;、https://beanvalidation.org/1.1/spec/[[JSR 349, 2013\]], &lt;a href=&#34;https://beanvalidation.org/2.0/spec/&#34;&gt;[JSR 380, 2017]&lt;/a&gt; 三个标准。 Bean Validation 的目的是解决程序从表现层到持久层的对象的重复校验逻辑。它使用注解、XML 对对象的属性进行约束。&lt;/p&gt;
&lt;p&gt;除了默认提供的校验注解，Bean Validation 还提供了自定义注解来实现自己的校验逻辑、本地化违反约定信息等能力。&lt;/p&gt;
&lt;p&gt;下文我们主要以 Bean Validation 2.0为例进行讲解。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_使用&#34;&gt;使用&lt;/h2&gt;&lt;p&gt;Bean Validation 2.0的官方认证实现为https://hibernate.org/validator/documentation/[Hibernate Validator]。spring boot 项目只要引入了 spring-boot-starter-web 依赖就自动引入了相关依赖。&lt;/p&gt;
&lt;p&gt;它需要的依赖有:&lt;/p&gt;
&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;javax.validation:validation-api&lt;/li&gt;&lt;li&gt;org.hibernate.validator:hibernate-validator&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;前者提供抽象描述和抽象接口，后者提供具体实现。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_常用约束&#34;&gt;常用约束&lt;/h2&gt;&lt;div class=&#34;table-block&#34;&gt;&lt;table class=&#34;frame-all grid-all stretch&#34;&gt;&lt;colgroup&gt;&lt;col style=&#34;width: 25%;&#34;&gt;&lt;col style=&#34;width: 25%;&#34;&gt;&lt;col style=&#34;width: 25%;&#34;&gt;&lt;col style=&#34;width: 25%;&#34;&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;halign-left valign-top&#34;&gt;注解&lt;/th&gt;&lt;th class=&#34;halign-left valign-top&#34;&gt;适用对象类型&lt;/th&gt;&lt;th class=&#34;halign-left valign-top&#34;&gt;说明&lt;/th&gt;&lt;th class=&#34;halign-left valign-top&#34;&gt;null 是否被视为有效&lt;/th&gt;&lt;/tr&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;AssertFalse&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;boolean&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素必须为 false；&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;AssertTrue&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;boolean&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素必须为 true；&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;DecimalMax&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;BigDecimal, BigInteger, CharSequence, byte/short/int/long 及包装类型&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素必须小于等于给定值；&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;DecimalMin&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;BigDecimal, BigInteger, CharSequence, byte/short/int/long 及包装类型&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素必须大于等于给定值；&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Digits&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;BigDecimal, BigInteger, CharSequence, byte/short/int/long 及包装类型&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素的整数与分数部分分别约束最大值；&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Email&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;String&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;字符串必须是有效的邮件地址&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;N&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Future&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Date/Calendar/Instant/LocalDate/LocalTime/LocalDateTime/MonthDay/OffsetDateTime/OffsetTime/Year/YearMonth/ZonedDateTime&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素必须大于当前时间&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;FutureOrPresent&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Date/Calendar/Instant/LocalDate/LocalTime/LocalDateTime/MonthDay/OffsetDateTime/OffsetTime/Year/YearMonth/ZonedDateTime&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素必须大于等于当前时间&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Max&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;BigDecimal/BigInteger/byte/short/int/long&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素小于等于给定值&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Min&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;BigDecimal/BigInteger/byte/short/int/long&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素大于等于给定值&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;NotEmpty&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;String/Collection/Map/Array&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素不能为 null 或者为空&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;N&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;NotNull&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;any&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素不能为 null&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;N&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Post&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Date/Calendar/Instant/LocalDate/LocalTime/LocalDateTime/MonthDay/OffsetDateTime/OffsetTime/Year/YearMonth/ZonedDateTime&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素必须小于当前时间&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Pattern&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;String&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;字符串必须符合给定的正则&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Size&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;String/Collection/Map/Array&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;元素的长度/元素数量在给定范围内&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;Y&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_简单使用&#34;&gt;简单使用&lt;/h2&gt;&lt;p&gt;在 Controller 参数前添加 @Valid 注解，即:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;// model
public class UserRequest {
  @NotEmpty
  private String name;
  @Range(min=1, max=125)
  private int age;
  @Valid
  private Address address;
}

# controller
@PostMapping(&#34;/users&#34;)
public String createUser(@Valid @RequestBody UserRequest user);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是：&lt;/strong&gt;① 如果对象嵌套了其它对象(即需要级联校验)，需要在里面使用 @Valid 注解 ② 如果 controller 使用继承实现，那么要符合里氏替换原则原则（即子类的约束被强化或者弱化;
父方法的约束会自然被子类方法继承)。&lt;/p&gt;
&lt;p&gt;另外 Spring 默认不提供方法级别的校验，如果需要校验，需要在类级别添加&lt;code&gt;@Validated&lt;/code&gt;注解。&lt;/p&gt;
&lt;p&gt;如果想全局处理 Bean Validation 异常，则可以再 ErrorAdvice 处理类中，添加对&lt;code&gt;MethodArgumentNotValidException&lt;/code&gt;异常处理即可。如果添加了对方法参数的校验，还需要再 ErrroAdvice 中添加 &lt;code&gt;ConstraintViolationException&lt;/code&gt;异常类的处理。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_更多用法&#34;&gt;更多用法&lt;/h2&gt;&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_自定义约束&#34;&gt;自定义约束&lt;/h3&gt;&lt;p&gt;如果默认的校验不能满足业务场景的需要，我们可以自定义约束。&lt;/p&gt;
&lt;p&gt;每个约束注解的定义包括但不限于：&lt;/p&gt;
&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;注解的校验类 [非必需]&lt;/li&gt;&lt;li&gt;校验不通过的 message 字符串 [必需]&lt;/li&gt;&lt;li&gt;注解所属的分组(Group) [必需]&lt;/li&gt;&lt;li&gt;注解所属的负载(Payload) [必需]&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;假如说现在有一个场景，某个字符串属性，只接受特定的几个值.&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;// 定义约束注解
@Documented
@Constraint(validatedBy = {StringRangeValidator.class})
@Target({METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE})
@Retention(RUNTIME)
public @interface StringRange {

    String[] values() default {};

    String message() default &#34;属性值只能在指定的范围内&#34;;

    Class&amp;lt;?&amp;gt;[] groups() default {};

    Class&amp;lt;? extends Payload&amp;gt;[] payload() default {};
}

// 定义校验实现类
public class StringRangeValidator implements ConstraintValidator&amp;lt;StringRange, String&amp;gt; {

    Set&amp;lt;String&amp;gt; valueSets = new HashSet&amp;lt;&amp;gt;();

    @Override
    public void initialize(StringRange constraintAnnotation) {
        for (String str : constraintAnnotation.values()) {
            if (Objects.nonNull(str)) {
                valueSets.add(str);
            }
        }
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        return valueSets.contains(value);
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就很方便地实现了一个自定义的校验类。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_分组校验&#34;&gt;分组校验&lt;/h3&gt;&lt;p&gt;分组校验主要用于同一个 Bean 对象的特定属性在不同场景下约束行为不同服务的。比如一个 User 对象，创建与更新的对象大部分是相同的，不同的是更新时 ID 不为空，而创建时必须为空。那么我们可以分别定义两个组(组名一般是接口;
默认分组是 javax.validation.groups.Default.class)：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;public interface CreatedGroup {}
public interface UpdatedGroup {}

// User.java

@NotNull(group = UpdatedGroup.class)
@Null(group = CreatedGroup.class)
private Long id;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在启用校验的地方:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@RequestMapping(&#34;/users&#34;)
public User createUser(@Validated(CreatedGroup.class) CreateUserRequest createUserRequest) { ... }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_其它&#34;&gt;其它&lt;/h2&gt;&lt;p&gt;我们没有处理的有 Payload(负载)的使用，它是附加在 Group 之外的一种元数据描述，一种用途是：描述校验的错误严重级别。因为使用较少，我们不多描述。有兴趣的朋友可以读一下Bean Validation 的 spec 文档。&lt;/p&gt;
&lt;p&gt;如果我们在没有 Spring 的条件下想使用 Bean Validation 怎么办？&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

validator.validate(instantce, constraintGroups);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关联 repo: &lt;a class=&#34;bare&#34; href=&#34;https://github.com/polarlights/bean_validation_tutorial&#34;&gt;https://github.com/polarlights/bean_validation_tutorial&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_参考资料&#34;&gt;参考资料&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/2a495bf5504e&#34;&gt;使用Bean Validation实现数据校验&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/index.html&#34;&gt;JSR 303 - Bean Validation 介绍及最佳实践&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://beanvalidation.org/2.0/spec/#introduction&#34;&gt;Bean validation specification&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://www.logicbig.com/how-to/code-snippets/jcode-bean-validation-javax-validation-payload.html&#34;&gt;Bean validation payload example&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&#34;bare&#34; href=&#34;https://www.logicbig.com/tutorials/java-ee-tutorial/bean-validation.html&#34;&gt;https://www.logicbig.com/tutorials/java-ee-tutorial/bean-validation.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://hibernate.org/validator/documentation/&#34;&gt;Hibernate Validator Documentation&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>hibernate-best-practice</title>
      <link>https://polarlights.github.io/post/hibernate-best-practice/hibernate-best-practice/</link>
      <pubDate>Thu, 06 Dec 2018 18:08:59 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/hibernate-best-practice/hibernate-best-practice/</guid>
      
        <description>&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_1_设置数据库存储时间的时区&#34;&gt;1. 设置数据库存储时间的时区&lt;/h2&gt;&lt;p&gt;如果某个应用考虑到国际化，服务会部署在多个时区，或者用户会和不同时区的人打交道；存储的时间建议使用 UTC 时间。比如美国有夏令时，会根据季节调整时间。使用 UTC 时间会更好地适应变化。&lt;/p&gt;
&lt;p&gt;Hibernate 在时间的存取的时候，会调用&lt;code&gt;PreparedStatement.setTimestamp()&lt;/code&gt;/&lt;code&gt;ResultSet.getTimestamp&lt;/code&gt;，默认情况下，会 fall back 为 JVM 所在的时区。为了能够存储 UTC 时间，将 JDBC 的链接时区设置为 UTC 即可。即&lt;code&gt;spring.jpa.properties.hibernate.jdbc.time_zone=UTC&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的是，对于 MySQL 数据库，在连接 URL 上要添加上&lt;code&gt;useLegacyDatetimeCode=false&lt;/code&gt;，否则会导致时间并不会被转换为 UTC 时间。&lt;/p&gt;
&lt;p&gt;当然，如果服务的时区是稳定的（比如固定在东八区），存储为服务当前时间服务也可以正常工作。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_2_检查生成的_sql_是否与预期中的一致&#34;&gt;2. 检查生成的 SQL 是否与预期中的一致&lt;/h2&gt;&lt;p&gt;在查询、更新、删除记录的时候，一并检查生成的 SQL 是否与预期一致，可以在早期发现并解决潜在的性能问题。&lt;/p&gt;
&lt;p&gt;JPA 开启打印日志的设置:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;spring.jpa.show-sql=true
spring.jpa.properties.hibernate.type=trace
spring.jpa.properties.hibernate.use_sql_comments=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.type.descriptor.sql=trace
logging.level.org.hibernate.SQL=trace&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印日志还可以比较早地发现 N+1查询问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：仅在非生产环境打印SQL。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_如何懒加载某个属性&#34;&gt;如何懒加载某个属性&lt;/h2&gt;&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_使用代码增强并在属性上添加相应的注解&#34;&gt;使用代码增强，并在属性上添加相应的注解：&lt;/h3&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Lob
@Basic(fetch = FetchType.LAZY)
public byte[] getPicture() {
    return picture;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;在使用的时候，会额外产生一条查询的 SQL&lt;/li&gt;&lt;li&gt;代码增强会修改原来的代码，做一些处理&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是：懒加载属性懒加载生效的前提是，没有 eager load 的关联；如果存在的话，注解失效。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_使用子类&#34;&gt;使用子类&lt;/h3&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@MappedSuperclass
public class BaseAttachment {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
}

@Entity
@Table(name = &#34;attachment&#34;)
public class AttachmentSummary extends BaseAttachment {}

@Entity
@Table(name = &#34;attachment&#34;)
public class Attachment extends BaseAttachment {
    @Lob
    private byte[] content;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;无侵入性代码，性能会更好&lt;/li&gt;&lt;li&gt;调用者需要对子类要有意识&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_实现_equalshashcodetostring_方法&#34;&gt;实现 equals/hashCode/toString 方法&lt;/h2&gt;&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_equalshashcode&#34;&gt;equals/hashCode&lt;/h3&gt;&lt;p&gt;equals 用于比较两个对象是否相等，重载时要遵守：&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;自反性：对于任何非null的引用值x, x.equals(x)必须返回true&lt;/li&gt;&lt;li&gt;对称性：对于任何非null的引用值x和y,当且仅当y.equals(x)返回true时，x.equals(y)必须返回true&lt;/li&gt;&lt;li&gt;传递性：对于任何非null的引用值x,y和z，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true&lt;/li&gt;&lt;li&gt;一致性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回 true，或者一致地返回false&lt;/li&gt;&lt;li&gt;非null 引用与 null 比较，永远返回false&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;hashCode 主要用于对象存储在 Hash 相关的存储模型，提供散列计算。&lt;/p&gt;
&lt;p&gt;如果两个对象 equals，那么 hashCode 必然要相等。不同对象 hashCode 最好不要相同，尤其在数据量较大的时候。&lt;/p&gt;
&lt;p&gt;考虑到实体的特性，实体一般都有标识符字段，它的来源有：&lt;/p&gt;
&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;分配的（比如 UUID/ISBN/ID number)等&lt;/li&gt;&lt;li&gt;DB生成&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;对于前者，可以直接使用分配的标识符作为 equals/hashCode 的关键要素:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (!(o instanceof Book)) return false;
    Book book = (Book) o;
    return Objects.equals(getIsbn(), book.getIsbn());
}

 @Override
 public int hashCode() {
     return Objects.hash(getIsbn());
 }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于后者，需要这样做：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Override
public boolean equals(Object o) {
     if (this == o) return true;
     if (!(o instanceof Book)) return false;
    Book book = (Book) o;
        return id != null &amp;amp;&amp;amp; id.equals(book.id);
}

@Override
public int hashCode() {
        return 31;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家会发现 hashCode 永远返回&lt;strong&gt;31&lt;/strong&gt;，使用固定值的原因是： 如果使用下面的代码:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Override
public boolean equals(Object o) {
     if (this == o) return true;
     if (!(o instanceof Book)) return false;
    Book book = (Book) o;
        return id != null &amp;amp;&amp;amp; id.equals(book.id);
}

@Override
public int hashCode() {
        return Objects.hash(getId());
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为 ID 是在持久化之后，由数据库分配的；如果在持久化之前，他们是存储在一个 HashSet 中，入库之前，它的 hashCode 是 &lt;strong&gt;0&lt;/strong&gt;；持久化之后，它的值发生了改变，HashSet 就不会包含当前的实体了。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_tostring&#34;&gt;toString&lt;/h3&gt;&lt;p&gt;toString 不建议包含关联实体。&lt;/p&gt;
&lt;p&gt;如果关联是 Eager 加载的，容易引起性能问题（子实体关联的子实体，形成链式的查询)；如果关联是 Lazy加载的，会抛出：LazyInitializationException 异常。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_如果主键是_uuid&#34;&gt;如果主键是 UUID&lt;/h2&gt;&lt;p&gt;将id的类型设置为 UUID 即可,另外需要确保 GeneratedType 为AUTO:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Entity(name = &#34;Post&#34;)
@Table(name = &#34;post&#34;)
public class Post {
    @Id
    // @GeneratedValue 默认策略为 GenerationType.AUTO
    @GeneratedValue
    private UUID id;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想自定义其它 ID 生成策略，可以参考 hibernate 的 UserGuide，里面有简单的例子可以参考。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_自增主键的生成策略&#34;&gt;自增主键的生成策略&lt;/h2&gt;&lt;p&gt;Hibernate 5之前，可以使用:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Entity(name = &#34;Post&#34;)
@Table(name = &#34;post&#34;)
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;自 Hibernate 5之后，MySQL需要调整为&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Entity(name = &#34;Post&#34;)
@Table(name = &#34;post&#34;)
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AUTO 会 fall back 为性能差的 TABLE 生成器，需要显式声明为 IDENTITY。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_检查生成的_sql_是否与预期中的一致&#34;&gt;检查生成的 SQL 是否与预期中的一致&lt;/h2&gt;&lt;p&gt;在查询、更新、删除记录的时候，一并检查生成的 SQL 是否与预期一致，可以在早期发现并解决潜在的性能问题。&lt;/p&gt;
&lt;p&gt;JPA 开启打印日志的设置:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;spring.jpa.show-sql=true
spring.jpa.properties.hibernate.type=trace
spring.jpa.properties.hibernate.use_sql_comments=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.type.descriptor.sql=trace
logging.level.org.hibernate.SQL=trace&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印日志还可以比较早地发现 N+1查询问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：仅在非生产环境打印SQL。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_eager_加载是一种_code_smell&#34;&gt;EAGER 加载是一种 code Smell&lt;/h2&gt;&lt;p&gt;加载策略不应该是实体关联的责任，简单地将在实体上将关联设置为 EAGER加载，会造成性能问题。在不同的业务场景下，需要加载不同的关联实体,所以要根据业务场景，在查询的时候，将关联实体一并查出来。&lt;/p&gt;
&lt;p&gt;在实体上写的关联关系，加载策略要全部设置为 LAZY。默认情况下，不同关联关系的加载策略为:&lt;/p&gt;
&lt;div class=&#34;table-block&#34;&gt;&lt;table class=&#34;frame-all grid-all stretch&#34;&gt;&lt;colgroup&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;halign-left valign-top&#34;&gt;关联关系&lt;/th&gt;&lt;th class=&#34;halign-left valign-top&#34;&gt;默认加载策略&lt;/th&gt;&lt;/tr&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;OneToOne&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;EAGER&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;ManyToOne&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;EAGER&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;OneToMany&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;LAZY&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;ManyToMany&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;LAZY&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_subselect_是一种_code_smell&#34;&gt;subselect 是一种 code smell&lt;/h2&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_transaction_open_in_view_是一种_code_smell&#34;&gt;transaction open-in-view 是一种 code smell&lt;/h2&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_jpa_读取数据的时候也显示地声明只读事务&#34;&gt;JPA 读取数据的时候也显示地声明只读事务&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://stackoverflow.com/questions/26327274/do-you-need-a-database-transaction-for-reading-data/26327536#26327536&#34;&gt;Do you need a database transaction for reading data?&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;All database statements are executed within the context of a physical transaction, even when we don&amp;#8217;t explicitly declare transaction boundaries (BEGIN/COMMIT/ROLLBACK).&lt;/p&gt;
&lt;p&gt;If you don&amp;#8217;t declare transaction boundaries, then each statement will have to be executed in a separate transaction (autocommit mode).
This may even lead to opening and closing one connection per statement unless your environment can deal with connection-per-thread binding.&lt;/p&gt;
&lt;p&gt;Declaring a service as @Transactional will give you one connection for the whole transaction duration, and all statements will use that single isolation connection.
This is way better than not using explicit transactions in the first place.&lt;/p&gt;
&lt;p&gt;On large applications, you may have many concurrent requests, and reducing database connection acquisition request rate will definitely improve your overall application performance.&lt;/p&gt;
&lt;p&gt;JPA doesn&amp;#8217;t enforce transactions on read operations.
Only writes end up throwing a transaction required exception in case you forget to start a transactional context.
Nevertheless, it&amp;#8217;s always better to declare transaction boundaries even for read-only transactions (in Spring @Transactional allows you to mark read-only transactions, which has a great performance benefit).&lt;/p&gt;
&lt;p&gt;Now, if you use declarative transaction boundaries (e.g.
@Transactional), you need to make sure that the database connection acquisition is delayed until there is a JDBC statement to be executed.
In JTA, this is the default behavior.
When using RESOURCE_LOCAL, you need to set the hibernate.connection.provider_disables_autocommit configuration property and make sure that the underlying connection pool is set to disable the auto-commit mode.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_casecase_要按需使用&#34;&gt;Casecase 要按需使用&lt;/h2&gt;&lt;p&gt;级联处理是 ORM 的 feature，在使用的时候首先要按照业务需求设置，不能简单地在父实体上设置为 &lt;code&gt;CascadeType.ALL&lt;/code&gt;；而且级联处理要放在父实体上，而不是子实体，不滥用。&lt;/p&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_casecade_最佳实践&#34;&gt;Casecade 最佳实践&lt;/h3&gt;&lt;section class=&#34;doc-section level-3&#34;&gt;&lt;h4 id=&#34;_onttoone&#34;&gt;OntToOne&lt;/h4&gt;&lt;section class=&#34;doc-section level-4&#34;&gt;&lt;h5 id=&#34;_双向_onetoone_关联&#34;&gt;双向 OneToOne 关联：&lt;/h5&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;双向关联需要在父子两边都更新变动，父实体应该包含 addChild 和 removeChild 方法组合，以保证变动的一致性。&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Entity
public class Post {
    @OneToOne(mappedBy = &#34;post&#34;, cascade = CascadeType.ALL, orphanRemoval = true)
    private PostDetails details;

    public void addDetails(PostDetails details) {
        this.details = details;
        details.setPost(this);
    }

    public void removeDetails(PostDetails details) {
        if (details != null) {
            details.setPost(null);
        }
        this.details = null;
    }
}

@Entity
public class PostDetails {
    @OneToOne
    @MapsId
    private Post post;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-4&#34;&gt;&lt;h5 id=&#34;_单向_onetoone_关联&#34;&gt;单向 OneToOne 关联：&lt;/h5&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Entity
public class Commit {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String comment;
    @OneToOne(cascade = CascadeType.ALL)
    @JoinTable(
        name = &#34;Branch_Merge_Commit&#34;,
        joinColumns = @JoinColumn(
            name = &#34;commit_id&#34;,
            referencedColumnName = &#34;id&#34;),
        inverseJoinColumns = @JoinColumn(
            name = &#34;branch_merge_id&#34;,
            referencedColumnName = &#34;id&#34;)
    )
    public void addBranchMerge(
        String fromBranch, String toBranch) {
        this.branchMerge = new BranchMerge(
             fromBranch, toBranch);
    }

    public void removeBranchMerge() {
        this.branchMerge = null;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-3&#34;&gt;&lt;h4 id=&#34;_onetomany&#34;&gt;OneToMany&lt;/h4&gt;&lt;p&gt;OneToMany关联的对象不宜太多，如果太多，同样也会在更新子实体的时候，加载很多无用的实体。&lt;/p&gt;
&lt;section class=&#34;doc-section level-4&#34;&gt;&lt;h5 id=&#34;_双向&#34;&gt;双向&lt;/h5&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Entity
public class Post {
   @OneToMany(cascade = CascadeType.ALL,
        mappedBy = &#34;post&#34;, orphanRemoval = true)
    private List&amp;lt;Comment&amp;gt; comments = new ArrayList&amp;lt;&amp;gt;();

    public void addComment(Comment comment) {
        comments.add(comment);
        comment.setPost(this);
    }

    public void removeComment(Comment comment) {
        comment.setPost(null);
        this.comments.remove(comment);
    }
}

@Entity
public class Comment {
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &#34;post_id&#34;)
    private Post post;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-4&#34;&gt;&lt;h5 id=&#34;_单向&#34;&gt;单向&lt;/h5&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Entity(name = &#34;Post&#34;)
@Table(name = &#34;post&#34;)
public class Post {
    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)
    @JoinColumn(name = &#34;post_id&#34;)
    private List&amp;lt;PostComment&amp;gt; comments = new ArrayList&amp;lt;&amp;gt;();
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-3&#34;&gt;&lt;h4 id=&#34;_manytomany&#34;&gt;ManyToMany&lt;/h4&gt;&lt;p&gt;可以使用 ManyToMany 注解，也可以将其拆分为两个 &lt;code&gt;OneToMany&lt;/code&gt; 关联。 前者比较自然；后者可以更好地控制数据的粒度。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Entity(name = &#34;Post&#34;)
@Table(name = &#34;post&#34;)
public class Post {
    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE })
    @JoinTable(name = &#34;post_tag&#34;,
        joinColumns = @JoinColumn(name = &#34;post_id&#34;),
        inverseJoinColumns = @JoinColumn(name = &#34;tag_id&#34;))
    private Set&amp;lt;Tag&amp;gt; tags = new HashSet&amp;lt;&amp;gt;();

    public void addTag(Tag tag) {
        tags.add(tag);
        tag.getPosts().add(this);
    }

    public void removeTag(Tag tag) {
        tags.remove(tag);
        tag.getPosts().remove(this);
    }

    // equals &amp;amp;&amp;amp; hashCode
}

@Entity(name = &#34;Tag&#34;)
@Table(name = &#34;tag&#34;)
public class Tag {
    @ManyToMany(mappedBy = &#34;tags&#34;)
    private Set&amp;lt;Post&amp;gt; posts = new HashSet&amp;lt;&amp;gt;();

    // equals &amp;amp;&amp;amp; hashCode
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于有额外字段的多对多关联，可以参考 &lt;a href=&#34;https://vladmihalcea.com/the-best-way-to-map-a-many-to-many-association-with-extra-columns-when-using-jpa-and-hibernate/&#34;&gt;The best way to map a many-to-many association with extra columns when using JPA and Hibernate&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15440817804559.png&#34; alt=&#34;15440817804559&#34;&gt;&lt;/div&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_只读查询添加上只读事务&#34;&gt;只读查询添加上只读事务&lt;/h2&gt;&lt;p&gt;使用只读事务， detach 状态的记录不再被 Persistence Context保存，可以减少内存的使用和 GC 消耗的时间。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_适当设置_db_连接池的大小&#34;&gt;适当设置 DB 连接池的大小&lt;/h2&gt;&lt;p&gt;数据库连接池太大或者太小都会影响性能。太小，会等待连接的获取消耗太多时间；太大，时间消耗在线程的上下文切换上。默认情况下，JPA 的数据库连接池大小为10（够用)，各位可以根据自身应用的情况，设置比较合适的大小。&lt;/p&gt;
&lt;p&gt;另外连接池的大小设置，要考虑到死锁的情况。之前我们遇到过这样的问题：我们使用了一个框架，除了在 Spring Boot 业务中使用了连接，在连接没有关闭的时候，框架又去申请了新的数据库连接。在框架处理完之后，两个连接会全部释放。假设现在，连接池有2个连接，在并发的时候，请求 A 和请求 B 同时获取了一个连接，这是 A 要调用框架，框架去连接池获取一个新的连接。这时数据库连接池的连接已经在使用了，请求 A 的处理线程只能等待；同样请求 B 的处理线程也只能等待。等待最终超时，程序报错。&lt;/p&gt;
&lt;p&gt;那么如何避免连接池出现死锁的情况呢?&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;pool_size = Tn x (Cm - 1) + 1&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;T 指得是程序的进程数；C 指的是每个进程执行的线程数。重点在于后面要有一个空余的连接。&lt;/p&gt;
&lt;p&gt;如何找到合适的连接池大小，请参考另外一篇文章: &amp;lt;&amp;lt;,TBD&amp;gt;&amp;gt;&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_附录&#34;&gt;附录&lt;/h2&gt;&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_从源码层面实现代码增强&#34;&gt;从源码层面实现代码增强:&lt;/h3&gt;&lt;p&gt;在build.gradle 文件中，添加代码增强的插件:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-properties&#34; data-lang=&#34;properties&#34;&gt;# build.gradle
buildscript {
	ext {
		hibernateVersion = &#39;5.2.17.Final&#39;	}
	dependencies {
	    classpath(&#34;org.hibernate:hibernate-gradle-plugin:${hibernateVersion}&#34;)
	}
}

apply plugin: &#39;org.hibernate.orm&#39;

hibernate {
	enhance {
		// Whether enhancement for lazy attribute loading should be done.
		enableLazyInitialization = true
		// Whether enhancement for self-dirty tracking should be done.
		enableDirtyTracking = true
		// Whether enhancement for bi-directional association management should be done
		enableAssociationManagement = true
		enableExtendedEnhancement = false
	}
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在需要懒加载的关联关系(OneToOne/ManyToOne)上添加: &lt;code&gt;@LazyToOne(LazyToOneOption.NO_PROXY)&lt;/code&gt;.
需要注意的是，IDEA 并不支持该插件，需要在设置中，将 gradle 的 Runner 设置为代理到 gradle。  &lt;img src=&#34;../15440677845389.jpg&#34; alt=&#34;15440677845389&#34;&gt;&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_参考链接&#34;&gt;参考链接：&lt;/h3&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://vladmihalcea.com/the-best-way-to-lazy-load-entity-attributes-using-jpa-and-hibernate/&#34;&gt;The best way to lazy load entity attributes using JPA and Hibernate&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://vladmihalcea.com/the-best-way-to-implement-equals-hashcode-and-tostring-with-jpa-and-hibernate/&#34;&gt;The best way to implement equals, hashCode, and toString with JPA and Hibernate&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://vladmihalcea.com/hibernate-facts-equals-and-hashcode/&#34;&gt;How to implement Equals and HashCode for JPA entities&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&#34;bare&#34; href=&#34;https://vladmihalcea.com/uuid-identifier-jpa-hibernate/&#34;&gt;https://vladmihalcea.com/uuid-identifier-jpa-hibernate/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://vladmihalcea.com/the-open-session-in-view-anti-pattern/&#34;&gt;The Open Session In View Anti-Pattern&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://vladmihalcea.com/how-to-store-date-time-and-timestamps-in-utc-time-zone-with-jdbc-and-hibernate/&#34;&gt;How to store date, time, and timestamps in UTC time zone with JDBC and Hibernate&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing&#34;&gt;About Pool Sizing&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://vladmihalcea.com/the-open-session-in-view-anti-pattern/&#34;&gt;The Open Session In View Anti-Pattern&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/section&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>Add release to sentry</title>
      <link>https://polarlights.github.io/post/add-release-to-sentry/add-release-to-sentry/</link>
      <pubDate>Mon, 12 Nov 2018 21:24:39 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/add-release-to-sentry/add-release-to-sentry/</guid>
      
        <description>&lt;p&gt;&lt;a href=&#34;https://sentry.io&#34;&gt;Sentry&lt;/a&gt; 是一个开源的，用来帮助开发监控异常和跟进错误修复的服务。&lt;/p&gt;
&lt;p&gt;Java 集成 Sentry 十分地方便，很方便地就可以实现异常的监控。如果我们想更加精细化地区分某个错误是在哪个版本中出现的，需要我们额外将 release 信息告知 Sentry。具体怎么操作呢？&lt;/p&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_1_添加sentryconfig配置类将相关信息注入到_sentry&#34;&gt;1. 添加&lt;code&gt;SentryConfig&lt;/code&gt;配置类，将相关信息注入到 Sentry&lt;/h2&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@Configration
public class SentryConfig implements InitializingBean {

    @Value(&#34;${application.host.name:localhost}&#34;)
    private String hostName;

    @Value(&#34;${application.module.name}&#34;)
    private String serviceName;

    @Value(&#34;${spring.profiles.active}&#34;)
    private String activeProfile;

    @Value(&#34;${release.version:local}&#34;)
    private String releaseVersion;

    // 将 sentry 的配置放到 application.properties 中，
    // 可以根据环境配置到不同 sentry 服务地址
    @Value(&#34;${sentry.dsn}&#34;)
    private String sentryDsn;

    @Value(&#34;${sentry.timeout}&#34;)
    private String sentryTimeout;

    @Override
    public void afterPropertiesSet() throws Exception {
        MDC.put(&#34;Host&#34;, hostName);
        MDC.put(&#34;Module&#34;, serviceName);
        MDC.put(&#34;Profile&#34;, activeProfile);

        System.setProperty(&#34;sentry.environment&#34;, activeProfile);
        System.setProperty(&#34;sentry.release&#34;, releaseVersion);

        if (StringUtils.isNotBlank(sentryDsn)) {
            System.setProperty(&#34;sentry.dsn&#34;, sentryDsn);
            System.setProperty(&#34;sentry.timeout&#34;, sentryTimeout);
        }
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要解决 &lt;code&gt;release.version&lt;/code&gt; 从哪里获取，简单一些可以把 &lt;code&gt;project.version&lt;/code&gt;在 build 的时候，写入到&lt;code&gt;application.properties&lt;/code&gt;中。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;task createProperties(dependsOn: processResources) {
    doLast {
        def releaseVersion = &#39;release.version=&#39; + project.version.toString()
        def file = new File(&#34;$buildDir/resources/main/application.properties&#34;)
        if (file.exists()) {
            file.append(releaseVersion)
        }

        file = new File(&#34;$projectDir/resources/main/application.properties&#34;)
        if (file.exists()) {
            file.append(releaseVersion)
        }
    }
}

classes {
    dependsOn createProperties
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以继续完善：在版本信息的基础上把 Git 的 Commit ID 也加上，可以这样做：&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_方法_1_添加httpsgithub_compalantirgradle_git_versiongradle_git_version&#34;&gt;方法 1. 添加https://github.com/palantir/gradle-git-version[gradle-git-version]&lt;/h2&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;buildscript {
    dependencies {
        classpath(&#39;gradle.plugin.com.palantir.gradle.gitversion:gradle-git-version:0.11.0&#39;)
    }
}

apply plugin: &#39;com.palantir.git-version&#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加这个插件后，我们可以调用&lt;code&gt;versionDetails()&lt;/code&gt;获取当前项目的一些信息：&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;def details = versionDetails()
details.lastTag
details.commitDistance
details.gitHash
details.gitHashFull // full 40-character Git commit hash
details.branchName // is null if the repository in detached HEAD mode
details.isCleanTag&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;里面有我们需要的&lt;code&gt;gitHash&lt;/code&gt;，所以我们上面的脚本就可以修改为:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;task createProperties(dependsOn: processResources) {
    doLast {
        def releaseVersion = &#39;release.version=&#39; + project.version.toString() = &#39;-&#39; + versionDetails().gitHash
        def file = new File(&#34;$buildDir/resources/main/application.properties&#34;)
        if (file.exists()) {
            file.append(releaseVersion)
        }

        file = new File(&#34;$projectDir/resources/main/application.properties&#34;)
        if (file.exists()) {
            file.append(releaseVersion)
        }
    }
}

classes {
    dependsOn createProperties
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的实现需要添加较多地配置，我们可以使用另外一个 gradle 插件https://github.com/n0mer/gradle-git-properties[gradle-git-properties] 达到类似的效果：&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_方法_2使用_gradle_git_properties_插件&#34;&gt;方法 2：使用 gradle-git-properties 插件&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;添加依赖：&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-groovy&#34; data-lang=&#34;groovy&#34;&gt;buildscript {
    dependencies {
        classpath(&#34;gradle.plugin.com.gorylenko.gradle-git-properties:gradle-git-properties:1.5.1&#34;)
    }
}

apply plugin: &#39;com.gorylenko.gradle-git-properties&#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;gradle-git-properties 会添加一个&lt;strong&gt;generateGitProperties&lt;/strong&gt;的任务，执行之后生成&lt;code&gt;git.properties&lt;/code&gt;；它相较于 git-version 提供的内容更多：&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;git.branch
git.build.host
git.build.time
git.build.user.email
git.build.user.name
git.build.version
git.closest.tag.commit.count
git.closest.tag.name
git.commit.id
git.commit.id.abbrev
git.commit.id.describe
git.commit.message.full
git.commit.message.short
git.commit.time
git.commit.user.email
git.commit.user.name
git.dirty
git.remote.origin.url
git.tags
git.total.commit.count&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要的是&lt;code&gt;git.commit.id.abbrev&lt;/code&gt;，为了输出&lt;code&gt;release.version&lt;/code&gt;我们需要添加一行配置：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;// build.gradle
gitProperties {
    customProperty &#39;release.version&#39;, { project.version + &#34;-&#34; + it.head().abbreviatedId }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为它生成的 properties 文件默认不会加载，需要在&lt;code&gt;SentryConfig&lt;/code&gt;上添加&lt;code&gt;@PropertySource&lt;/code&gt;注解，加载它:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;@PropertySource(value = &#34;classpath:git.properties&#34;, ignoreResourceNotFound = true)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在程序抛出异常后，我们就可以在 Sentry 中看到异常信息已经包含了应用的版本及 commitId 信息了： image::15420289952643.jpg[]&lt;/p&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>JPA stream query with java8</title>
      <link>https://polarlights.github.io/post/jpa-stream-query/jpa-stream-query/</link>
      <pubDate>Sun, 11 Nov 2018 16:00:00 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/jpa-stream-query/jpa-stream-query/</guid>
      
        <description>&lt;p&gt;最近有小伙伴在做批量导出数据的功能，原来是这样写的： image::15417517310823.jpg[]&lt;/p&gt;
&lt;p&gt;后来在看其他代码的时候，有个类似功能，突然意识到那个代码在数据量很大的时候，会存在性能问题（最坏会OOM，导致不可用)。后面在交流过程中，小伙伴突然想到上面那个代码也会有类似问题。&lt;/p&gt;
&lt;p&gt;在 Rails 的 ActiveRecord 中有&lt;code&gt;find_in_batches&lt;/code&gt;功能，它会生成&lt;code&gt;select ...
from XX where id &amp;gt; ?
limit N offset M&lt;/code&gt;类似的 SQL，实现批量查询。&lt;/p&gt;
&lt;p&gt;在 Java 中，首先想到的是使用 Pagable 翻页查找，但是这个不是很优雅，要自己去处理总页数、当前页等数据。&lt;/p&gt;
&lt;p&gt;有没有更优雅一些的做法呢？搜索之后，发现了两篇文章：&lt;/p&gt;
&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;a href=&#34;http://knes1.github.io/blog/2015/2015-10-19-streaming-mysql-results-using-java8-streams-and-spring-data.html&#34;&gt;Streaming MySQL Results Using Java 8 Streams and Spring Data JPA&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://vladmihalcea.com/whats-new-in-jpa-2-2-stream-the-result-of-a-query-execution/&#34;&gt;What&amp;#8217;s new in JPA 2.2&amp;#8201;&amp;#8211;&amp;#8201;Stream the result of a Query execution&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;原来 JPA 早就支持了 Java 8 的 stream。使用 Pageable 翻页方法，与 stream 的相比，多了 DB offset 的操作；后者实质上使用的是数据库的游标。&lt;/p&gt;
&lt;p&gt;第一篇文章的内容结合自己业务数据，对文章内容作了一次验证：&lt;/p&gt;
&lt;p&gt;测试数据库的 Post 表有 56W 条数据。 测试机器信息：&lt;/p&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;CPU: i7 2.3GHz Memory: 8GBx2 1600MHz DDR3&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;测试代码:&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;case 1:&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;# PostRepository.java
@Query(&#34;select p from Post p&#34;)
Stream&amp;lt;Post&amp;gt; streamAll();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;case 2:&lt;/p&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;# PostRepository.java case 1:
@QueryHints(value = @QueryHint(name = HINT_FETCH_SIZE, value = &#34;&#34; + Integer.MINI_VALUE))
@Query(&#34;select p from Post p&#34;)
Stream&amp;lt;Post&amp;gt; streamAll();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;case 3:&lt;/p&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;# PostRepository.java case 1:
@QueryHints(value = @QueryHint(name = HINT_FETCH_SIZE, value = &#34;200&#34;)
@Query(&#34;select p from Post p&#34;)
Stream&amp;lt;Post&amp;gt; streamAll();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是，在调用 Repository 的地方，要显示声明为只读事务，否则会抛出异常。&lt;/p&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_没有堆heap大小限制的情况下&#34;&gt;没有堆(Heap)大小限制的情况下：&lt;/h2&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;case 1:&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;正常工作&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15417527402090.jpg&#34; alt=&#34;15417527402090&#34;&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;case 2:&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;正常工作&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15417527637481.jpg&#34; alt=&#34;15417527637481&#34;&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;case 3:&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;正常工作&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15417527764295.jpg&#34; alt=&#34;15417527764295&#34;&gt;&lt;/div&gt;
&lt;p&gt;以上3个时间相差不大。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_将堆大小做了限制&#34;&gt;将堆大小做了限制&lt;/h2&gt;&lt;p&gt;参数：&lt;code&gt;-XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -XX:MaxRAMFraction=1 -Xmx1080m -Xms512m&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在几个测试案例中，只有case 2可以正常工作，且比前面的速度快了1/3。其它两种 case 全部不能正正常工作，最终 OOM，而且 GC 时间非常多。&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;case 1:&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15417529616240.jpg&#34; alt=&#34;15417529616240&#34;&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;case 2:&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15417529776586.jpg&#34; alt=&#34;15417529776586&#34;&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;case 3:&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15417529893759.jpg&#34; alt=&#34;15417529893759&#34;&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_结论&#34;&gt;结论&lt;/h2&gt;&lt;p&gt;使用 stream 查询大量数据的时候，务必要添加&lt;code&gt;@QueryHints(value = @QueryHint(name = HINT_FETCH_SIZE, value = &#34;&#34; + Integer.MIN_VALUE))&lt;/code&gt;注解，它可以在保证速度的同时，内存可以得到很好的控制。&lt;/p&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>Mac mail app tricks</title>
      <link>https://polarlights.github.io/post/mac-mail-tricks/mac-mail-tricks/</link>
      <pubDate>Fri, 09 Nov 2018 10:05:12 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/mac-mail-tricks/mac-mail-tricks/</guid>
      
        <description>&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_常用设置&#34;&gt;常用设置&lt;/h2&gt;&lt;p&gt;1.修改邮件的一些默认设置&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;# Disable send and reply animations in Mail.app
defaults write com.apple.mail DisableReplyAnimations -bool true
defaults write com.apple.mail DisableSendAnimations -bool true

# Copy email addresses as `foo@example.com` instead of `Foo Bar &amp;lt;foo@example.com&amp;gt;` in Mail.app
defaults write com.apple.mail AddressesIncludeNameOnPasteboard -bool false

# Add the keyboard shortcut ⌘ + Enter to send an email in Mail.app
defaults write com.apple.mail NSUserKeyEquivalents -dict-add &#34;Send&#34; &#34;@\U21a9&#34;

# Display emails in threaded mode, sorted by date (oldest at the top)
defaults write com.apple.mail DraftsViewerAttributes -dict-add &#34;DisplayInThreadedMode&#34; -string &#34;yes&#34;
defaults write com.apple.mail DraftsViewerAttributes -dict-add &#34;SortedDescending&#34; -string &#34;yes&#34;
defaults write com.apple.mail DraftsViewerAttributes -dict-add &#34;SortOrder&#34; -string &#34;received-date&#34;

# Disable inline attachments (just show the icons)
defaults write com.apple.mail DisableInlineAttachmentViewing -bool true

# Disable automatic spell checking
defaults write com.apple.mail SpellCheckingBehavior -string &#34;NoSpellCheckingEnabled&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_邮件分类放在不同目录下&#34;&gt;邮件分类放在不同目录下&lt;/h2&gt;&lt;p&gt;邮件全部放在收件箱里面，不做分类的话，随着邮件越积越多，邮件非常杂乱。我们可以在邮件中添加目录(mail.app 中叫 mailbox)，然后在&#34;`Preferences&#34; -&amp;gt; &#34;Rules&#34;，添加新的邮件规则。&lt;/p&gt;
&lt;p&gt;过滤规则中，还可以设置发送通知，以便于我们不错过重要的邮件。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_smart_mailbox&#34;&gt;Smart Mailbox&lt;/h2&gt;&lt;p&gt;邮件放在不同目录下会比较有序，但是它只是比较粗的分类，有时我们需要更加定制化的从另外一个层面去透视邮件。比如筛选某些特定发件人、邮件主题、旗标、某个发件日期等邮件。&lt;/p&gt;
&lt;p&gt;在邮箱左侧&#34;`Smart Mailboxes&#34;，选择添加，&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15417270316426.jpg&#34; alt=&#34;15417270316426&#34;&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_vip&#34;&gt;VIP&lt;/h2&gt;&lt;p&gt;对于某些 Very Import Person 发送的邮件，可以很方便地将其加入到 VIP 列表：在发件人邮箱上点击右键，选择添加到 VIP 即可。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_旗标&#34;&gt;旗标&lt;/h2&gt;&lt;p&gt;默认旗标只有一些颜色名称，而没有其它语义。给颜色添加一种语义，以方便我们理解。&lt;/p&gt;
&lt;p&gt;先给邮件添加某个旗标，然后在左侧可以看到对应旗标出现；右键选择重命名(或者单击某个旗标，再次点击)，即可对其重命名。如果没有对应旗标的邮件，改旗标不会出现在左侧，也无法对其更名。&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15417288936047.jpg&#34; alt=&#34;15417288936047&#34;&gt;&lt;/div&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>idea popular plugins</title>
      <link>https://polarlights.github.io/post/idea-popular-plugins/idea-popular-plugins/</link>
      <pubDate>Wed, 19 Sep 2018 23:20:49 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/idea-popular-plugins/idea-popular-plugins/</guid>
      
        <description>&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_基本&#34;&gt;基本&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/6317-lombok-plugin&#34;&gt;lombok plugin&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/185-generateserialversionuid&#34;&gt;GenerateSerialVersionUID&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Adds a new action &#39;SerialVersionUID&#39; in the generate menu (alt + ins).
The action adds an serialVersionUID field in the current class or updates it if it already exists, and assigns it the same value the standard &#39;serialver&#39; JDK tool would return.
The action is only visible when IDEA is not rebuilding its indexes, the class is serializable and either no serialVersionUID field exists or its value is different from the one the &#39;serialver&#39; tool would return.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_效率篇&#34;&gt;效率篇&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/4441-jrebel-for-intellij&#34;&gt;Jrebel for IDEA&lt;/a&gt;&lt;/p&gt;&lt;p&gt;JRebel is a productivity tool that allows developers to reload code changes instantly.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7642-save-actions&#34;&gt;save actions&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Supports configurable, Eclipse like, save actions, including &#34;optimize imports&#34;, &#34;reformat code&#34;, &#34;rearrange code&#34;, &#34;compile file&#34; and some quick fixes for Java like &#34;add / remove &#39;this&#39; qualifier&#34;, etc.
The plugin executes the configured actions when the file is synchronised (or saved) on disk.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7086-acejump&#34;&gt;ace-jump&lt;/a&gt;&lt;/p&gt;&lt;p&gt;AceJump allows you to quickly navigate the caret to any position visible in the editor.&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15373699756710.jpg&#34; alt=&#34;15373699756710&#34;&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_代码质量&#34;&gt;代码质量&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/1065-checkstyle-idea&#34;&gt;checkstyle&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/3847-findbugs-idea&#34;&gt;Find bugs&lt;/a&gt;&lt;/p&gt;&lt;p&gt;The FindBugs plugin for IntelliJ IDEA.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7973-sonarlint&#34;&gt;SonarLint&lt;/a&gt;&lt;/p&gt;&lt;p&gt;SonarLint is an IDE extension that helps you detect and fix quality issues as you write code.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines&#34;&gt;alibaba-coding-guideline&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Alibaba Java Coding Guidelines plugin support.&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../alibaba.gif&#34; alt=&#34;alibaba&#34;&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_语法高亮&#34;&gt;语法高亮&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7495&amp;#8211;ignore&#34;&gt;ignore&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;.ignore&lt;/strong&gt; is a plugin for .gitignore (Git), .hgignore (Mercurial), .npmignore (NPM), .dockerignore (Docker), .chefignore (Chef), .cvsignore (CVS), .bzrignore (Bazaar), .boringignore (Darcs), .mtn-ignore (Monotone), ignore-glob (Fossil), .jshintignore (JSHint), .tfignore (Team Foundation), .p4ignore (Perforce), .prettierignore (Prettier), .flooignore (Floobits), .eslintignore (ESLint), .cfignore (Cloud Foundry), .jpmignore (Jetpack), .stylelintignore (StyleLint), .stylintignore (Stylint), .swagger-codegen-ignore (Swagger Codegen), .helmignore (Kubernetes Helm), .upignore (Up), .prettierignore (Prettier), .ebignore (ElasticBeanstalk) files in your project.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7793-markdown-support&#34;&gt;markdown-support&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Provides the capability to edit markdown files within the IDE and see the rendered HTML in a live preview.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7391-asciidoc&#34;&gt;asciidoc&lt;/a&gt;&lt;/p&gt;&lt;p&gt;AsciiDoc language support for IntelliJ platform.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_其它&#34;&gt;其它&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/164-ideavim&#34;&gt;ideavim&lt;/a&gt;&lt;/p&gt;&lt;p&gt;IdeaVim supports many Vim features including normal/insert/visual modes, motion keys, deletion/changing, marks, registers, some Ex commands, Vim regexps, configuration via ~/.ideavimrc, macros, window commands, etc.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/7125-grep-console&#34;&gt;grep-console&lt;/a&gt;&lt;/p&gt;&lt;ol class=&#34;loweralpha&#34; type=&#34;a&#34;&gt;&lt;li&gt;Change colors of matching text.&lt;/li&gt;&lt;li&gt;Grep output into a new console tab.&lt;/li&gt;&lt;li&gt;Change output or execute any action using custom groovy scripts or plugins.&lt;/li&gt;&lt;li&gt;Filter out unwanted lines.&lt;/li&gt;&lt;li&gt;Fold output.&lt;/li&gt;&lt;li&gt;Play sounds on matches.&lt;/li&gt;&lt;li&gt;Clear Console on matches.&lt;/li&gt;&lt;li&gt;Tail files*.&lt;/li&gt;&lt;/ol&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15373698266180.jpg&#34; alt=&#34;] image::15373698363530.jpg[&#34;&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://plugins.jetbrains.com/plugin/9792-key-promoter-x&#34;&gt;key-promoter-x&lt;/a&gt;&lt;/p&gt;&lt;p&gt;Shows the user the keyboard short-cuts when a button is pressed with the mouse.
This provides an easy way to learn how to replace tedious mouse work with keyboard keys and helps to transition to a faster, mouse free development.
Currently, it supports toolbar buttons, menu buttons, and tool windows and the actions therein.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>idea productive tips</title>
      <link>https://polarlights.github.io/post/idea-productive-tips/</link>
      <pubDate>Wed, 19 Sep 2018 23:20:49 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/idea-productive-tips/</guid>
      
        <description>&lt;p&gt;This article is wroten according to a youtube video: &lt;a class=&#34;bare&#34; href=&#34;https://www.youtube.com/watch?v=eq3KiAH4IBI&#34;&gt;https://www.youtube.com/watch?v=eq3KiAH4IBI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We use Idea programming everyday.
How can we use it effectively, now let&amp;#8217;s reading it below:&lt;/p&gt;
&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;p&gt;Close the tab list of IDE&lt;/p&gt;&lt;p&gt;Preferences → Editor → Editor Tabs;
Change Tab Placement from default &lt;strong&gt;Top&lt;/strong&gt; to &lt;strong&gt;None&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Tab is annoying when many files are opened.
It&amp;#8217;s hard to find file when opening to many files, which it&amp;#8217;s inevitable.
Use recent files window or search everywhere (Double Shift).
We can use &lt;strong&gt;⌘+E&lt;/strong&gt; to explore recent files instead.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Auto scroll to source&lt;/p&gt;&lt;p&gt;When we select a file, we want to explore the file content, other than just the file name.
If we want to see the source, we have to double click the file in project window, by default.
While Idea provides us a feature that when we select a file, Idea will open the source automatically:  In the project window, right top of the window, click the config icon, check the &#34;scroll to source&#34; in the dropdown list.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Create directory or file effectivelly&lt;/p&gt;&lt;p&gt;If I want to create a nested directory or package, I will select the parent directory and press &lt;code&gt;⌘+N&lt;/code&gt;, then input the directory name, before.
There&amp;#8217;s more effective way: Just input the relative directory path, Idea will create the sub directory for us, if it doesn&amp;#8217;t exist.&lt;/p&gt;
&lt;p&gt;We can create file or directory through the navigation bar.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Search file or class by search&lt;/p&gt;&lt;p&gt;Double shift(press shift double times) is our friend, it pops up a search window which we can search file, class.
It will list the more recent used files at the file lists.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Scratch file feature&lt;/p&gt;&lt;p&gt;It is a very common scenario that we want test a piece of code outside of the project context.
We can press &lt;strong&gt;⌘+⇧+N&lt;/strong&gt; to create a scratch file which will be removed after we finish test.
See more details, please visit &lt;a class=&#34;bare&#34; href=&#34;https://www.jetbrains.com/help/idea/scratches.html&#34;&gt;https://www.jetbrains.com/help/idea/scratches.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Shrink Selection:&lt;/p&gt;&lt;p&gt;Increase selection: &lt;strong&gt;⌥ + ↑&lt;/strong&gt;  Shrink selection: &lt;strong&gt;⌥ + ↓&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Move code block&lt;/p&gt;&lt;p&gt;move code block up: &lt;strong&gt;⌥ + ⇧ + ↑&lt;/strong&gt;  move code block down: &lt;strong&gt;⌥ + ⇧ + ↓&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Rename (Refectory)&lt;/p&gt;&lt;p&gt;Shift + F6&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Auto comple&lt;/p&gt;&lt;p&gt;Please follow both steps:&lt;/p&gt;
&lt;ol class=&#34;loweralpha&#34; type=&#34;a&#34;&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;Enable Automake from the compiler  Press: ctrl + shift + A (For Mac ⌘ + shift + A)  Type: make project automatically  Hit: Enter  Enable Make Project automatically feature&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;ul&gt;&lt;li&gt;Enable Automake when the application is running  Press: ctrl + shift + A (For Mac ⌘ + shift + A)  Type: Registry  Find the key compiler.automake.allow.when.app.running and enable it or click the checkbox next to it&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Auto wrap code&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;When editing code:&lt;/p&gt;&lt;p&gt;File → Editor → Code Style → Java → Wrappings And Brackets&lt;/p&gt;
&lt;p&gt;Change: Wrap On Typing → true&lt;/p&gt;&lt;/li&gt;&lt;li&gt;When viewing code:&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;bare&#34; href=&#34;https://stackoverflow.com/questions/23004520/code-wrap-intellij&#34;&gt;https://stackoverflow.com/questions/23004520/code-wrap-intellij&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Insert Language Template&lt;/p&gt;&lt;p&gt;&lt;a class=&#34;bare&#34; href=&#34;https://www.jetbrains.com/help/idea/using-language-injections.html&#34;&gt;https://www.jetbrains.com/help/idea/using-language-injections.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Navigation Bar&lt;/p&gt;&lt;p&gt;Command + ↑&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
</description>
      
    </item>
    
    <item>
      <title>那些好用的工具之 Tmux 篇</title>
      <link>https://polarlights.github.io/post/tmux-tutorial/tmux-tutorial/</link>
      <pubDate>Tue, 18 Sep 2018 20:03:32 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/tmux-tutorial/tmux-tutorial/</guid>
      
        <description>&lt;p&gt;工欲善其事，必先利其器。突然来了兴致，想利用一下睡觉前的时间，整理一下自己用过的，感觉很棒的命令行工具，作为一个系列。其中有的工具会比较复杂，有的会比较简单。复杂的，多写一些。简单的，拼盘拼成一篇。&lt;/p&gt;
&lt;p&gt;今天的主题是 Tmux。&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15152533520178.jpg&#34; alt=&#34;15152533520178&#34;&gt;&lt;/div&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_一_tmux_是什么&#34;&gt;一. Tmux 是什么？&lt;/h2&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/tmux/tmux&#34;&gt;Tmux&lt;/a&gt; 是一个终端复用工具。它可以允许在一个窗口创建、访问以及控制的多个终端。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_二_tmux_解决了什么问题&#34;&gt;二. Tmux 解决了什么问题？&lt;/h2&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;Alice SSH 登录到远程机器，对机器进行维护。她要跑一个任务耗时很久。程序已经开始跑了。但是&amp;#8230;&amp;#8203;&amp;#8230;&amp;#8203;中间发生了一个小插曲：Alice 因为自己电脑的故障，断开了远程机器的连接。结果因为执行任务的父进程被杀掉，导致程序跑了一半，被杀掉了。Alice 又需要从头开始执行。Poor Alice&amp;#8230;&amp;#8203;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Bob 平时使用 Vim 开发自己的项目。他一边要编辑代码，一边要做 Debug，一边需要一个交互式 Shell 查询数据库的数据情况。于是 Bob 开了3个 Tab 窗口来回切换。他发现，这样操作太麻烦了，需要来回手动切换 Tab 才可以看到自己想看的内容。&lt;/p&gt;&lt;p&gt;有小伙伴给他推荐了 iTerm2，它可以支持分割窗口。Bob 使用了一阵子后，依然觉得不爽：a.
不够灵活 b.
不小心关掉后窗口或 Tab 后，在执行的命令同样会中断。c.
切出来的窗口，停留在 Home 目录，需要手动执行&lt;code&gt;cd&lt;/code&gt;命令，才能跳转到工作目录。 image::15152542845524.jpg[]&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;有了 Tmux 上面的问题，都迎刃而解。它可以：&lt;/p&gt;
&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;在目标机器上运行，可以后台运行，即使网络连接断开也不受影响。&lt;/li&gt;&lt;li&gt;很方便的切换窗口，而且还可以自动切换到工作目录。&lt;/li&gt;&lt;li&gt;支持配置，通过配置文件管理初始化会话时的窗口及执行的命令。&lt;/li&gt;&lt;li&gt;支持 Pair Programming。&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_三_一些概念&#34;&gt;三. 一些概念&lt;/h2&gt;&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15154155956817.jpg&#34; alt=&#34;15154155956817&#34;&gt;&lt;/div&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_1_server&#34;&gt;1. Server&lt;/h3&gt;&lt;p&gt;Tmux 能够让用户断连后，重新登录回来，可以保留工作现场的原因是，它本身是 C/S 架构的。Server 和 各个客户端之间通过在&lt;code&gt;/tmp/&lt;/code&gt;的 socket 来进行通信。&lt;/p&gt;
&lt;p&gt;Tmux 启动的时候，默认会创建一个Session（会话）。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_2_session&#34;&gt;2. Session&lt;/h3&gt;&lt;p&gt;Session 是在 tmux 管理下的虚拟终端的集合。每个 Session 下面会有很多窗口(Window)&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_3_window&#34;&gt;3. Window&lt;/h3&gt;&lt;p&gt;Window 是单个可见的窗口，它有自己的编号，默认从0开始。Window 可以被分割成很多的 Pane（窗格)。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_4_pane&#34;&gt;4. Pane&lt;/h3&gt;&lt;p&gt;就像一个大窗户会有很多小窗格一样，tmux 可以很方便的将窗口分割成一个个的小格子，每个格子可以称之为：Pane。&lt;/p&gt;
&lt;p&gt;他们之间的关系可以很形象地用一张图来标明：&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15154180277103.jpg&#34; alt=&#34;15154180277103&#34;&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_5_prefix_key&#34;&gt;5. Prefix Key&lt;/h3&gt;&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15154156612162.jpg&#34; alt=&#34;15154156612162&#34;&gt;&lt;/div&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_四_安装&#34;&gt;四. 安装&lt;/h2&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;Ubuntu&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;sudo apt-get install tmux&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;macOSX&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;brew install tmux&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_五_常用操作及配置&#34;&gt;五. 常用操作及配置&lt;/h2&gt;&lt;h4 id=&#34;_1_操作会话&#34; class=&#34;discrete&#34;&gt;1. 操作会话&lt;/h4&gt;
&lt;p&gt;tmux 创建会话很简单，只需要在终端输入 &lt;code&gt;tmux&lt;/code&gt; 就可以，个人不推荐在日常使用中这样做。因为人比较擅长记忆有语义性的东西，建议在启动的时候指定 session 的名字: &lt;code&gt;tmux new -s sessionA&lt;/code&gt;。界面启动后是这样的：&lt;/p&gt;
&lt;p&gt;如何查看现在正在运行的 session 列表呢？&lt;code&gt;tmux ls&lt;/code&gt;，它就会列出所有的 session 列表。&lt;/p&gt;
&lt;p&gt;如果我们想 attatch 到特定的 session，我们可以执行&lt;code&gt;tmux at -t [sessionName]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;有些 session 在创建了之后，我们不想再看到它。处女座的盆友们不能忍。执行&lt;code&gt;tmux kill -t [sessionName]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那如果想干掉整个 tmux 服务呢？ &lt;code&gt;tmux kill-server&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;# 切换session
bind -r ( switch-client -p
bind -r  ) switch-client -n&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;普遍用户对之不太习惯。我们可以对它做一下设置，使之符合我们的日常使用习惯。&lt;/p&gt;
&lt;h4 id=&#34;_2_通用配置&#34; class=&#34;discrete&#34;&gt;2. 通用配置&lt;/h4&gt;
&lt;p&gt;我们先看一张键盘图：&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../15154208245016.jpg&#34; alt=&#34;ADM-3A keyboard&#34;&gt;&lt;/div&gt;
&lt;p&gt;是不是觉得很怪异？上图是 ADM-3A 的键盘图，实际上也是 vi 编辑器的默认的按键绑定的图。tmux 的按键同样也是用了 vi 的键盘布局。 tmux 的 Prefix 按键是&lt;code&gt;C-b&lt;/code&gt;，所以为了方便使用，建议将按键改为 &lt;code&gt;C-a&lt;/code&gt;，当然，建议小伙伴们将 Capslock 按键映射成 Ctrl。&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;# 取消默认绑定的按键，改为 Ctrl-a
unbind C-b
set -g prefix C-a

# 设置 prefix,防止 tmux 按键和程序按键冲突。比如c-a 在 vim 配置为全选,在运行 tmux 时，需要先按 c-a,然后再按 vim 中的 c-a
bind C-a send-prefix

# 修改默认延迟时间
set -g escape-time 0

# 设置终端颜色，有时 vim 的 colortheme 有问题，设置它可以解决
set -g default-terminal &#34;screen-256color&#34;

# 重新加载配置文件
bind r source ~/.tmux.conf \; display &#34;Configuration reloaded!&#34;

# 设置历史大小
set -g history-limit 10000&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;_3_切换窗口&#34; class=&#34;discrete&#34;&gt;3. 切换窗口&lt;/h4&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;#设置 window 窗口 index 默认开始值
set -g base-index 1
#设置 pane 的 index 默认起始值
set -g pane-base-index 1
#分割窗口
unbind &#39;&#34;&#39;
bind | split-window -h
bind-key v split-window -h -p 50 -c &#34;#{pane_current_path}&#34;
unbind %
bind - split-window -v
bind-key s split-window -p 50 -c &#34;#{pane_current_path}&#34;
#Disable rename window name of shell command
set-option -g allow-rename off
# Renumber the windows of current session
set -g renumber-windows on
#Unbind Space. Not use layout change
unbind Space&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;_4_操作_pane&#34; class=&#34;discrete&#34;&gt;4. 操作 Pane&lt;/h4&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;#在 pane 中移动
bind h select-pane -L
bind j select-pane -D
bind k select-pane -U
bind l select-pane -R
#调整 pane大小
bind H resize-pane -L 5
bind J resize-pane -D 5
bind K resize-pane -U 5
bind L resize-pane -R 5
#pane 转为 window
unbind Up
bind Up new-window -d -n tmp \; swap-pane -s tmp.1 \; select-window -t tmp
unbind Down
bind Down last-window \; swap-pane -s tmp.1 \; kill-window -t tmp&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&#34;_5_复制粘贴&#34; class=&#34;discrete&#34;&gt;5. 复制粘贴&lt;/h4&gt;
&lt;h4 id=&#34;_6_鼠标模式&#34; class=&#34;discrete&#34;&gt;6. 鼠标模式&lt;/h4&gt;
&lt;h4 id=&#34;_7_定制样式&#34; class=&#34;discrete&#34;&gt;7. 定制样式&lt;/h4&gt;
&lt;h4 id=&#34;_8_管理会话&#34; class=&#34;discrete&#34;&gt;8. 管理会话&lt;/h4&gt;
&lt;h4 id=&#34;_9_结对编程&#34; class=&#34;discrete&#34;&gt;9. 结对编程&lt;/h4&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_六_推荐资料&#34;&gt;六. 推荐资料&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;a href=&#34;https://pragprog.com/book/bhtmux2/tmux-2&#34;&gt;Productive Mouse-Free Development By Brian P.Hogan&lt;/a&gt;&lt;/li&gt;&lt;li&gt;tmux man page.&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/ADM-3A&#34;&gt;ADM-3A&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/tmux-plugins&#34;&gt;Tmux 插件&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/tmuxinator/tmuxinator&#34;&gt;Tmuxinator 管理复杂的 tmux 会话&lt;/a&gt;&lt;/li&gt;&lt;li&gt;Google :)&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>Enable reload chagned java and template files In IntelliJ</title>
      <link>https://polarlights.github.io/post/enable-intellij-template-reload/enable-intellij-template-reload/</link>
      <pubDate>Sat, 06 Jan 2018 17:12:09 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/enable-intellij-template-reload/enable-intellij-template-reload/</guid>
      
        <description>&lt;p&gt;最近在学习 Spring Boot 的时候发现真心不如 Ruby on Rails 爽，其中一点是：RoR 在 开发模式下默认可以自动 reload 相关路径下的文件：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ bin/rails r &#39;puts ActiveSupport::Dependencies.autoload_paths&#39;
.../app/assets
.../app/controllers
.../app/helpers
.../app/mailers
.../app/models
.../app/controllers/concerns
.../app/models/concerns
.../test/mailers/previews&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 `app/views`下的文件在修改后也会立即产生效果。&lt;/p&gt;
&lt;p&gt;但是在 Java 世界里，就没有全家桶了。开始的时候很不习惯，需要各种重启，每次重启8-10秒，几乎时时刻刻在和重启打交道。&lt;/p&gt;
&lt;p&gt;还好在 Java 世界里是有解决方法的。&lt;/p&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_java&#34;&gt;*.java&lt;/h2&gt;&lt;p&gt;java 文件可以使用 &lt;code&gt;spring-boot-devtools&lt;/code&gt;，但是，但是，任何在&lt;code&gt;classpath&lt;/code&gt;中的文件的变动，都会引起整个程序重启。是的，没看错，是重启。233。好消息是：静态文件和模板文件的变动不会引起程序重启。&lt;/p&gt;
&lt;p&gt;它不会提高太多效率，因为我们需要的是重新加载，而不是重启。&lt;/p&gt;
&lt;p&gt;还好我们有`JRebel`，在 IntelliJ 的 &#34;Perferences&#34; → &#34;Plugins&#34; → &#34;`Browse Repositories&#34;，搜索`JRebel`，安装插件后重启。安装成功后，在`Run`菜单下，会多出两个子菜单：a.
使用 JRebel 启动程序。 b.
使用 JRebel 调试程序。&lt;/p&gt;
&lt;p&gt;使用 JRebel 启动程序后，修改源文件，保存后，可以在标准输出看到&lt;code&gt;JRebel: Reloading class &#39;io.polarlights.web.HomeController&#39;.&lt;/code&gt;这样的字样，说明它在正常工作了。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_templates&#34;&gt;templates&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;启用自动构建项目&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;File -&amp;#8594; Setting -&amp;#8594; Build, Execution, Deployment -&amp;#8594; Compiler -&amp;#8594; check &lt;strong&gt;Build project automatically&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;启用执行时自动编译&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;打开 Action 窗口:&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;Linux : CTRL+SHIFT+A
Mac OSX : SHIFT+COMMAND+A
Windows : CTRL+ALT+SHIFT+/&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入&#34;Registry&amp;#8230;&amp;#8203;&#34;，启用&lt;code&gt;compiler.automake.allow.when.app.running&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_附录&#34;&gt;附录&lt;/h2&gt;&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_激活_jrebel&#34;&gt;激活 JRebel&lt;/h3&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;打开 &lt;code&gt;https://my.jrebel.com/&lt;/code&gt;，使用 twitter/facebook 账号，填写相关的信息。注意：邮箱请一定不要乱填。就可以收到官方发来的激活码。&lt;/li&gt;&lt;li&gt;image::15152289327942.jpg[]&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;输入邮箱收到的相关数据就 OK。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_references&#34;&gt;References:&lt;/h2&gt;&lt;div class=&#34;olist arabic&#34;&gt;&lt;ol class=&#34;arabic&#34;&gt;&lt;li&gt;&lt;a class=&#34;bare&#34; href=&#34;https://www.mkyong.com/spring-boot/intellij-idea-spring-boot-template-reload-is-not-working/&#34;&gt;https://www.mkyong.com/spring-boot/intellij-idea-spring-boot-template-reload-is-not-working/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&#34;bare&#34; href=&#34;http://www.jhipster.tech/configuring-ide-idea/&#34;&gt;http://www.jhipster.tech/configuring-ide-idea/&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&#34;bare&#34; href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html&#34;&gt;https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-devtools.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&#34;bare&#34; href=&#34;https://www.jetbrains.com/help/idea/navigating-to-action.html&#34;&gt;https://www.jetbrains.com/help/idea/navigating-to-action.html&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a class=&#34;bare&#34; href=&#34;http://guides.rubyonrails.org/autoloading_and_reloading_constants.html&#34;&gt;http://guides.rubyonrails.org/autoloading_and_reloading_constants.html&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>how_to_test_class_and_module</title>
      <link>https://polarlights.github.io/post/how-to-test-a-class/</link>
      <pubDate>Thu, 24 Mar 2016 06:32:49 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/how-to-test-a-class/</guid>
      
        <description>&lt;p&gt;前面我们简要介绍了Minitest的运行原理。知其然而知其所以然，如果了解了 别人好的代码是如何设计的，对于自己编码技术的提升会有促进作用。&lt;/p&gt;
&lt;p&gt;好了，我们接下来继续了解如何使用Minitest测试我们的类、模块、model及钩子、控制器和试图。 后面还会涉及mock和使用种子数据、定制minitest等内容。&lt;/p&gt;
&lt;p&gt;本文主要讲如何测试我们写的类。&lt;/p&gt;
&lt;p&gt;Ruby是一种面向对象语言非常高的语言，因为即使像数字、纯字符串等都是对象，都有属于它的方法。 现实是复杂的，为了方便理解和处理我们遇到的事物、问题、概念，我们会把它抽象为对象，再高级一些 就是类。对象是具体的某个事物，类，泛指一类事物。&lt;/p&gt;
&lt;p&gt;假定我们有下面的一个类：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class MyString &amp;lt; String
  def palindrome?
    self.reverse.eql? self
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何测试它呢？&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;require &#39;minitest/autorun&#39;

class MyStringTest &amp;lt; Minitest::Test
  def test_should_be_palindrome
    ms = MyString.new(&#39;&#39;)
    assert ms.palindrome?
    ms = MyString.new(&#39;mom&#39;)
    assert ms.palindrome?
  end

  def test_should_not_be_palindrome
    ms = MyString.new(&#39;name&#39;)
    refute ms.palindrome?
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要requre Minitest的autorun文件，测试类一般带有&lt;code&gt;Test&lt;/code&gt;字样，而且必须继承自Minitest::Test 类。具体原因我们在前面分析Minitest的原理时，有谈到。里面的测试方法需要以&lt;code&gt;test_&lt;/code&gt;开头，否则 不会执行该方法。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Class</title>
      <link>https://polarlights.github.io/post/class-and-modules/</link>
      <pubDate>Wed, 23 Mar 2016 20:22:28 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/class-and-modules/</guid>
      
        <description>&lt;p&gt;一个类的实例可以使用&lt;code&gt;类名.new&lt;/code&gt;来初始化，&lt;code&gt;new&lt;/code&gt;方法会自动调用该类的&lt;code&gt;initialize&lt;/code&gt;方法，但是由于&lt;code&gt;initialize&lt;/code&gt;方法是类的私有方法，所以不能显式的调用它。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  def  initialize(x, y)
    @x = x
    @y = y
  end
end

p = Point.new(2, 4)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的实例&lt;code&gt;p&lt;/code&gt;并不能直接访问里面的实例变量@x,@y，因为Ruby是面向对象的语言，所以访问这些实例变量实际上是访问与实例变量的方法而已。如果直接使用&lt;code&gt;p.x&lt;/code&gt;，Ruby会告诉你:&#34;NoMethodError: undefined method &lt;code&gt;x&lt;/code&gt; for #&amp;lt;Point:0x007fc7c40b1ee8 @x=2, @y=4&amp;gt;&#34;。为了能够访问里面的实例变量，我们可以定义对应的访问方法。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  def  initialize(x, y)
    @x = x
    @y = y
  end

  def x
    @x
  end

  def x=(x)
    @x = x
  end

end

p = Point.new(2, 4)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面我们定义了Point对实例变量x的&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法，现在我们就可以正常访问x了。如果调用&lt;code&gt;p.x = 4&lt;/code&gt;,那么这里实际调用的是&lt;code&gt;p.x=(4)&lt;/code&gt;，即调用的为&lt;code&gt;x=&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;在Java语言中，getter和setter方法在Bean中是如此的常见，每次写都挺麻烦。那么在Ruby中有没有更好简略方法呢？有。在Ruby中有访问控制器，&lt;code&gt;attr_reader&lt;/code&gt;方法定义了那些实例变量可以被外部所使用，&lt;code&gt;attr_accessor&lt;/code&gt;方法定义了哪些实例变量可以被外部获取也定义了&lt;code&gt;setter&lt;/code&gt;相似的功能，即它是&lt;code&gt;getter&lt;/code&gt;和&lt;code&gt;setter&lt;/code&gt;方法的合集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;attr_reader和attr_accessor方法后面可以直接跟变量的名称，也可以使用Symbol，也可以使用字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ruby使用了常见的数学符号来当做方法，比如；&lt;code&gt;+&lt;/code&gt;,&lt;code&gt;-&lt;/code&gt;,&lt;code&gt;*&lt;/code&gt;，注意，它们不是简单的符号，在Ruby中，它们其实是方法。对于减号操作&lt;code&gt;-&lt;/code&gt;，有一元和二元两种形式，一元减的定义要使用&lt;code&gt;-@&lt;/code&gt;，在调用的时候为&lt;code&gt;-对象.变量&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  def  initialize(x, y)
    @x = x
    @y = y
  end

  def +(other)
    return Point.new(@x+other.x, @y+other.y)
  end

  def -@
    return Point.new(-@x,-@y)
  end

  def -(other)
    return Point.new(@x-other.x, @y-other.y)
  end

end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Duck Typing&lt;/strong&gt;：它的含义是：如果它走路像一只鸭子并且也像鸭子一样嘎嘎叫，那它就是一只鸭子。&lt;/p&gt;
&lt;p&gt;对于这句话怎么理解呢？以我们上面的代码为例，在定义&lt;code&gt;+&lt;/code&gt;方法时，我们并没有对other作类型的校验，只要other有x,y这两个方法且返回一个数值就可以。如果把Point类当做一只鸭子，而other又像Point一样拥有x,y方法，我们不管它是否真的是Point对象，那么other就是一个&#34;鸭子&#34;。那么如果万一other并没有x或者y方法呢？没有就报异常咯。&lt;/p&gt;
&lt;p&gt;如果我们要添加类型的检查，可以这样做：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def +(other)
  Point.new(@x + other.x, @y + other.y)
rescue
  raise TypeError, &#34;Point addtion is not like a Point Duck Way&#34;
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;俗语有言：条条大道通罗马。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def +(other)
  raise TypeError, &#34;Point addtion is not like a Point Duck Way&#34; unless
  other.respond_to? :x and other.respond_to? :y

  Point.new(@x + other.x, @y + other.y)
end

def +(other)
  raise TypeError, &#34;Point addtion is not like a Point Duck Way&#34; unless other.is_a? Point

  Point.new(@x + other.x, @y + other.y)
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于Point的实例变量我们可以使用&lt;code&gt;[]&lt;/code&gt;方法来访问：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def [](index)
  case index
  when 0, -2: @x
  when 1, -1: @y
  when :x,&#34;x&#34;: @x
  when :y,&#34;y&#34;: @y
  else
    nil
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于Point类我们也可以定义&lt;code&gt;each&lt;/code&gt;方法，来遍历实例变量。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def each
  yield @x
  yield @y
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Point中的实例变量是有限的，我们只需要yield两次就可以了。调用的时候是需要&lt;code&gt;p.each {|x| puts x}&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;如果类实现了each方法，那么就可以混入Enumerable模块的一些方法，这些方法都是基于each定义的，&lt;code&gt;include Enumerable&lt;/code&gt;。混入了Enumerable模块，可以写出以下的代码:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;p.all? {|x| x &amp;gt; 0} #return true if all of the elements of Point larger than zero.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Java中，如果要判断两个实例是否&#34;相等&#34;需要覆写&lt;code&gt;equals&lt;/code&gt;方法的。那么在Ruby中如何判断两个实例是否相等呢？我们可以定义&lt;code&gt;==&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def ==(other)
  if other.is_a? Point
     @x == other.x and @y == other.y
  elsif
    false
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Ruby中&lt;code&gt;eql?&lt;/code&gt;也可以用来比较对象是否相等，但是它不会自动进行类型的转换，而&lt;code&gt;==&lt;/code&gt;是会对类型进行自动转换的。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;puts 1 == (1.0)  #true FixNum will be converted to Float
puts 1.eql?(1.0)  #false FixNum is not the same as Float&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想让两个操作在一个类中看起来是一样的，我们可以使用前面学到的&lt;code&gt;alias&lt;/code&gt;来对方法进行重命名。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;alias eql? ==&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果对Point有两种比较方式，一种不严格的坐标相等，一种严格的坐标相等。那么第一种就是&lt;code&gt;==&lt;/code&gt;方法了。第二种我们可以定义 &lt;code&gt;eal?&lt;/code&gt;方法来实现。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def eql?(other)
  if other.instance_of? Point #sub-class instance is not allowed
     @x.eql?(other.x) and @y.eql?(other.y)  #type convert is not allowed
  elsif
    false
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;对于Hash值的相等性判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hash类的eql?使用主键进行比较，如果没有定义eql?方法，哈希表会用对象标志对对象进行比较，这意味着如果有一个哈希元素的主键是p，那么只能使用p来访问这个元素，而不能使用q,即使p==q。可变对象不适合做哈希表的主键，让eql?方法保持未定义可以绕过这个问题。&lt;/p&gt;
&lt;p&gt;eql?方法用于Hash对象，不能单独定义它，类似于Java，它还需要定义如何计算它的hash值。有一个简单的方法来做到：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def hash
  @x.hash + @y.hash
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一个比较通用的hash生成方法，适合于大部分的Ruby类:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def hash
  code = 17
  code = 37 * code + @x.hash
  code = 37 * code + @y.hash
  #the 17 and 37 is from the &#34;Effective Java&#34;
  code
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;如何比较两个Point的大小呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要比较两个对象的大小，一般要混入Comparable模块，实现&lt;code&gt;&amp;lt;==&amp;gt;&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def &amp;lt;==&amp;gt;(other)
  return nil unless other.instance_of Point
  @x ** 2 + @y ** 2 &amp;lt;==&amp;gt; other.x ** 2 + other.y ** 2
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Comparable使用&lt;code&gt;&amp;lt;==&amp;gt;&lt;/code&gt;来定义&lt;code&gt;==&lt;/code&gt;方法，但是由于Point显式定义了&lt;code&gt;==&lt;/code&gt;方法，所以Comparable中定义的&lt;code&gt;==&lt;/code&gt;不会被调用到。&lt;/p&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;Enumerable模块定义的若干方法，比如sort, min和max等包含比较的方法只有在被枚举的对象定义了&lt;code&gt;&amp;lt;==&amp;gt;&lt;/code&gt;才能够正常工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;在定义一些可变方法的时候，如果会修改原来对象的值，一般对象方法后会有&lt;code&gt;!&lt;/code&gt;来标志，如果不修改原有对象，一般会返回对象的一个副本。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def add!(other)
  @x += other.x
  @y += other.y
  self
end

def add(other)
  q = self.dup
  q.add!(other)
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;可变类Mutable Class&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用Struct类来定义可变的类，Struct类是Ruby的内核类，可以用于生成其它的类。在生成的类中定义的实例变量自动具有访问器方法。使用Struct来定义一个新类有两种方式:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;Struct.new(&#34;Point&#34;, :x, :y)
Point = Struct.new(:x, :y)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;在上面例子中，第二行代码使用了&#34;命名匿名类&#34;，如果把一个未命名的类对象赋值给一个变量的时候，这个变量名就自动称为该类的名称。上面的类就自动成为了&#34;Point&#34;&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;使用Struct定义的新类会自动定义getter、setter、[]、[]=、each、each_pair、==、to_s方法。如果需要继续在Point类中添加新的方法，可以直接这样定义:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  def my
    puts &#34;I am a add-handed method&#34;
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这不仅仅限于我们定义的新类，还包括任何其它的类。如果想要取消某些方法，可以使用前面学到的&lt;code&gt;undef&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  undef []=, x=, y=
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BTW：所谓的可变与不变是指实例能否被外界的值所改变内部的实例变量。变与不变只是相对的，不变可以变为变的，变的可以变为不变的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类方法Class Method&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类方法就是传说中的单例方法，它可以单独调用，也可以使用对象.方法名来调用。定义它的方式有很多种：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  #method one
  def Point.sum(*points)
    x, y = 0, 0
    points.each {|p| x += p.x, y += p.y}
    Point.new(x, y)
  end

  #method two
  def self.sum(*points)
    x, y = 0, 0
    points.each {|p| x += p.x, y += p.y}
    Point.new(x, y)
  end

  #method three
  class &amp;lt;&amp;lt; self
    def sum(*points)
      x, y = 0, 0
      points.each {|p| x += p.x, y += p.y}
      Point.new(x, y)
    end
  end

end

#method four
class &amp;lt;&amp;lt; Point
  def sum(*points)
    x, y = 0, 0
    points.each {|p| x += p.x, y += p.y}
    Point.new(x, y)
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;定义类常量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常量一般都是使用全大写的单词，常量既可以从类中定义，也可以在类外自己动态添加(oh my god, it is so powerful weapon！)&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def Point
  ORIGINAL_POINT = [0,0]
end

Point::DYNAMIC = [100, 100]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要访问这些常量一般要加类的限定词，而在类内部对此没有任何要求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类变量 Class Variables&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类变量在不同实例之间共享，使用&lt;code&gt;@@&lt;/code&gt;开头，只在内部可以引用，但是在外部是无法访问到的。类变量可以在类方法中可以被访问，类实例变量却是不可以的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类实例变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类实例变量是在类方法外定义的变量，但是这些变量是不能被实例方法所访问。不过类实例变量可能会让我们与普通的实例变量所混淆。类实例变量的优于类常量的一个重要特性是在继承现有类时，类实例变量的行为不像类变量那样让人混淆。&lt;/p&gt;
&lt;p&gt;下面是分别用类变量和类实例变量写的用于统计Point的代码；&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;#class variable
class Point
  @@n = 0
  @@totalX = 0
  @@totalY = 0

  def initialize(x,y)
    @x,@y = x,y

    @@n += 1
    @@totalX += x
    @@totalY += y
  end

  def self.report
    puts &#34;Number of points created: #@@n&#34;
    puts &#34;Average X coordinate: #{@@totalX.to_f / @@n}&#34;
    puts &#34;Average Y coordinate: #{@@totalY.to_f / @@n}&#34;
  end
end

#class instance variable
#Because the class instance variable can&#39;t be used in the instance method, so define it in the class method
class Point
  @n = 0
  @totalX = 0
  @totalY = 0

  def initialize(x,y)
    @x,@y = x,y
  end

  def self.new(x,y)
    @n += 1
    @totalX += x
    @totalY += y

    super
  end

  def self.report
    puts &#34;Number of points created: #@@n&#34;
    puts &#34;Average X coordinate: #{@@totalX.to_f / @@n}&#34;
    puts &#34;Average Y coordinate: #{@@totalY.to_f / @@n}&#34;
  end
    end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为类实例变量是类对象的实例变量，我们可以使用attr_reader和attr_accessor为它们创建访问器方法。我们可以这样做:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class &amp;lt;&amp;lt; self
  attr_accessor :n, :totalX, :totalY
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_方法的可见性&#34;&gt;方法的可见性&lt;/h2&gt;&lt;p&gt;Ruby像其它大部分面向对象一样使用public、private和protected来分别表示公开、私有和受保护的。&lt;/p&gt;
&lt;p&gt;在ruby中定义的方法默认为public的，但是initialize方法不是，它是私有的。在类外定义的全局方法也是被定义为类的私有方法。&lt;/p&gt;
&lt;p&gt;标准的定义类的顺序是这样的；&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  #public methods
  #...

  #protected methods
  protected

  #private methods
  private

end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了常量外，Ruby的变量自动都是私有的，所以我们不能在外面直接访问它，除非有定义访问器方法设定的变量。&lt;/p&gt;
&lt;p&gt;也可以在定义了方法后，在类的半部分同义定义某些方法的访问性: &lt;code&gt;private :x, :y&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果想要定义工厂类，那么我们一般不让直接使用&lt;code&gt;类.new&lt;/code&gt;来获取新实例的，所以需要定义new的可访问性，但是由于new是类方法，所以这里需要特殊处理下，即使用&lt;code&gt;private_class_method&lt;/code&gt;方法。当然如果想要将某个方法变为public的，那么可以使用&lt;code&gt;public_class_method&lt;/code&gt;方法。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_继承&#34;&gt;继承&lt;/h2&gt;&lt;p&gt;类在继承的时候不会继承父类的实例变量，这些变量是在方法调用的时候自动生成的，这一点与Java等语言是不一样的。&lt;/p&gt;
&lt;p&gt;##对象创建和初始化&lt;/p&gt;
&lt;p&gt;Ruby一个new方法&lt;strong&gt;看起来&lt;/strong&gt;像这样的:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt; def new(*args)
   o = self.allocate #创建类的新对象
   o.initialize(*args) #调用对象的初始化方法，使用传入的参数进行初始化
   o  #返回对象
 end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;allocate是Class类的实例方法，被所有的类所继承，它的作用是创建类的一个实例。此方法不能被覆盖，因为Ruby只会调用它的原始版本，所以不会被真的覆盖掉。&lt;/p&gt;
&lt;p&gt;initialize方法是一个实例方法，它的作用是为类的实例变量作初始化并赋初值。由于它是一个私有方法，所以我们不能显式地调用它。&lt;/p&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;Class类定义了两个名为new的方法，一个是Class#new，它是一个实例方法，另外一个是Class::new，它是一个类方法。Class#new用于创建一个类的新对象，而CLass::new用于创建一个新类。&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;###创建一个工厂方法&lt;/p&gt;
&lt;p&gt;创建工厂方法方法必须不能让外界直接使用new方法，如何做到呢？这就用到了我们上面提到的方法可见性控制的内容了。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  def initialize(x,y)
    @x,@y = x,y
  end

  private_class_method :new

  def Point.cartes(x,y)
    new(x,y)
  end

  def Point.polar(r, theta)
    new(r * Math.cos(theta), r * Math.sin(theta))
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_dupclone和initialize_copy&#34;&gt;dup、clone和initialize_copy&lt;/h3&gt;&lt;p&gt;使用dup和clone方法也可以返回一个新对象，它分配一个调用者所属类的实例，然后把调用者的所有实例变量和修改都拷贝到新创建的对象中。clone方法比dup方法拷贝的更彻底，包括对象的单例方法和冻结状态。&lt;/p&gt;
&lt;p&gt;如果类定义了一个名为initialize_copy的方法，那么clone和dup方法在拷贝完实例变量后，会执行这个方法，这个方法也是私有方法。&lt;/p&gt;
&lt;p&gt;clone和dup方法把实例变量从原始对象拷贝到拷贝对象中时，它们拷贝的是引用而非实际值。也就是说，它们用的是浅拷贝，在修改拷贝对象时，它会修改被拷贝对象的值，所以一般我们在定义一个类时都要定制这两个方法的原因。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def Point
  attr_accessor :x,:y

  def initialize(x,y)
    @x,@y = x,y
  end
end

def Test
  attr_accessor :p

  def initialize(p)
    @p = p
  end
end

p = Point.new(0,0)  #x=0,y=0
t = Test.new(p)   #t.p.x=0, t.p.y=0
t1 = t.clone
t2 = t.dup   #the same as the above

t1.p.x = 1 #p.x=1, t.p.x=1, t2.p.x=1

t2.p.y = 4 #p.y = 4, t.p.y=4, t1.p.y=4

t1.p = nil #t.p = p
t2.p = nil #it have no affect on t&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了防止拷贝对象，我们可以使用&lt;code&gt;def&lt;/code&gt;；来删除clone和dup方法，也可以将之定义为私有的方法，暴扣new,allocate。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_marshal_dump和marshal_load&#34;&gt;marshal_dump和marshal_load&lt;/h3&gt;&lt;p&gt;创建对象的第三种方式是调用Marshal.load方法来重新生成前面使用Marshal.dump序列化的对象。Marshal.dump方法保存一个对象的类，并递归序列化其中每个实例变量的值。绝大多数对象都可以使用这两个方法进行存储和序列化。&lt;/p&gt;
&lt;p&gt;那么什么是序列化呢？序列化是我们将对象的一些状态保存成其它形式，或变量或文件，在需要重新恢复它的状态时，我们可以从序列化的结果进行反向操作，将对象的状态恢复过来。&lt;/p&gt;
&lt;p&gt;有些类要修改实现序列化的方式，这样做的原因是为对象状态提供更加紧凑的方式，不去序列化那些缓存易变的数据。修改的方法就是重新定义marshal_dump来定制序列化方式，以及marshal_load来定制反序列化的方式。marshal_load方法被一个使用allocate方法新分配但是未初始化的的对象所调用，它需要一个由marshal_dump返回的可再生的对象拷贝作为参数，然后根据参数对象的状态初始化接收者对象。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  def initialize(*coords)
    @coords = coords
  end

  def marshal_dump
    @coords.pack(&#39;w*&#39;)
  end

  def marshal_load(s)
    @coords = s.unpack(&#39;w*&#39;)
  end
end

p = Point.new(1,2,3,4)
s = p.marshal_dump
t = Point.allocate
t.marshal_load(s) #t will be the same instance variables as the instance of p&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的例子展示了如何将对象序列化到文件，并从文件反序列化对象的实例。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Logfile
  def initialize(filename)
    @filename = filename
    @io = File.open(@filename,&#39;w&#39;)
  end

  def marshal_dump
    log &#34;Begin marshal...&#34;
    @filename  #just dump the filename, and leave the io object alone
  end

  def marshal_load(filename)
    @filename = filename
    @io = File.open(@filename, &#39;a&#39;)
    ``log &#34;Begin ummarshal...&#34;
  end

  def log(msg)
    @io.puts &#34;#{Time.now}: #{msg}&#34;
  end
end

logfile = if File.exists?(&#39;logfile&#39;)
            File.open(&#39;logfile&#39;) do |file|
              Marshal.load(file)
            end
          else
            Logfile.new(&#39;log.txt&#39;)
          end

ARGV.each do |msg|
  logfile.log msg
end

File.open(&#39;logfile&#39;, &#39;w&#39;) do |file|
  Marshal.dump(logfile, file)
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果对一个类禁用了clone和dup方法，我们可能需要定制序列化方法，通过序列化和反序列化可以很容易实现对象的拷贝，我们就不可以不使用marshal_dump和marshal_load方法，让Marshal.load方法返回对象&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_单例类&#34;&gt;单例类&lt;/h2&gt;&lt;p&gt;如果需要设定某个类是单例的，可以将new设置为私有，并且要阻止dup和clone方法不返回新的拷贝。也可以包含&lt;code&gt;singleton&lt;/code&gt;模块，并在类中include Singleton就可以。这样会定义一个名为instance的方法来返回该类的一个实例。不过需要注意的是，这样定义的类是不能使用带参数的initialize方法。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;require &#34;singleton&#34;

class PointStats
  include Singleton

  def initialize
    @n, @totalX, @totalY = 0, 0, 0
  end

  def record(point)
    @n +=1
    @totalX += point.x
    @totalY += point.y
  end

  def report
    puts &#34;Number of points are: #@n&#34;
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Point类中可以这样定义initialize方法:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def initialize(x,y)
  @x,@y = x,y
  PointStats.instance.record(self)
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;想要获取返回的值，可以这样做:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;PointStats.instance.report&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_模块modules&#34;&gt;模块Modules&lt;/h2&gt;&lt;p&gt;模块与类是很相似的，是方法、常量和变量的命名组，它使用关键字&lt;code&gt;module&lt;/code&gt;。与类不同的地方是模块不能被实例化，也不能被继承，只能作为命名空间和混入(Mixin)使用。&lt;/p&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_模块用于命名空间&#34;&gt;模块用于命名空间&lt;/h3&gt;&lt;p&gt;一个模块内部是可以相互嵌套的，这样会产生嵌套的命名空间。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;module  Base64
  DIGITS = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;

  class Encoder
    def encoder
    end
  end

  class Decode
    def decoder
    end
  end

  def Base.help #or self.help
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在外部使用常量需要Base64::DIGITS，使用某个方法可以使用Base64.help, encoder = Base64::Encoder.new&lt;/p&gt;
&lt;p&gt;##Module用于混入&lt;/p&gt;
&lt;p&gt;模块的第二个作用是用于混入，Enumerable和Comparable是两个比较常见的模块，前者在混入的类中，如果定义了each方法，那么这个类就会有很多强大的迭代器,如each_with_index,each_with_object。如果Comparable模块被混入，且类定义了&lt;code&gt;&amp;lt;==&amp;gt;&lt;/code&gt;方法，那么这个类的&amp;gt;、&amp;lt;、=方法就会自动拥有。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;class Point
  include Comparable
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的include看起来是一个关键字，但实际上它是Module类的一个私有方法,隐式地被self调用。&lt;code&gt;self.include(Comparable)&lt;/code&gt;。但是在代码中这样书写是错误的，它必须以函数的形式被调用。include方法可以接受多个Module对象进行混入，所以如果一个类定义了each和&amp;lt;==&amp;gt;方法的类可以加入&lt;code&gt;include Enumerable, Comparable&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;虽然class也是模块，但是类不允许include在另一个类中，include的参数必须是以module进行声明的模块。但是将模块包含在另一个模块中是合法的。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre&gt;module Iterable
  include Enumerable

  def each
    loop { yield self.next }
  end
end&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;混入一个模块的方式除了使用include外，还可以使用Object.extend方法，它可以将指定模块的实例方法变成接收对象的单键方法。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre&gt;countdown = Object.new
def countdown.each
  yield 1
  yield 3
  yield 2
end

countdown.extend(Enumerable) #now the each method becomes a singleton method of Object and have the mothods in Enumerable
print countdown.sort&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_可包含的命名空间模块&#34;&gt;可包含的命名空间模块&lt;/h3&gt;&lt;p&gt;前面我们定义的module中的方法都是以混入类的实例方法来调用的，我们可以将混入的方法以类的私有方法来进行调用。在就爱那个方法定义为了实例方法之后，使用&lt;code&gt;module_function&lt;/code&gt;将这些方法定义为&#34;`模块函数`&#34;。module_function与public、private等类似，它的主要作用是对给定方法创建类方法的拷贝和将实例方法变为私有的。module_function可以不跟参数，类似与private、public这样的效果，所以如果不想让某些方法成为非模块函数时需要将它定义在module_function的前面。&lt;/p&gt;
&lt;p&gt;使用module_function不是出于访问控制的需要，真实目的是让这些方法必须用无接受者的函数风格的调用方式。强制被包含模块的方法以无接收者的方式调用，减少了与真正的实例方法混淆的可能。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;module My
  def test
    puts &#34;hello world&#34;
  end

  module_function :test
end

class Point
  def my
    test
  end
end

p = Point.new
p.test #Wrong
p.my #hello world
My.test #hello world&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_加载和请求模块&#34;&gt;加载和请求模块&lt;/h3&gt;&lt;p&gt;Ruby程序被分散在多个文件的时候，我们需要将它们&#34;`组装`&#34;起来，组装的方法就是&lt;code&gt;require&lt;/code&gt;和 &lt;code&gt;load&lt;/code&gt;。require和load的作用类似，但是require更加常用，require还可以用于从标准库中加载文件。require还可以加载二进制扩展，如so和dll。load方法要求加载的为包含文件扩展名的完整文件名称，而require只需要传入文件的名字，而不需要后缀。如果一个目录下同时拥有同名的不同后缀的文件，那么require优先加载文件格式的文件，而不是二进制文件。load方法会加载一个路径多次，而require由于会将文件路径展开，所以不会重复，且它把已经加载过的文件名方在全局数组&lt;code&gt;$&#34;&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;Ruby的加载路径可以使用&lt;code&gt;$LOAD_PATH&lt;/code&gt;或&lt;code&gt;$:&lt;/code&gt;来获取。越是靠前的路径优先被搜索。在ruby 1.9中，load_path数组的元素可以是字符串，也可以是任何实现了&lt;code&gt;to_path&lt;/code&gt;的类对象。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_执行加载的代码&#34;&gt;执行加载的代码&lt;/h3&gt;&lt;p&gt;load和require会立刻执行制定文件的代码，但是这种执行方式与直接调用文件中的代码并不是等价的。&lt;/p&gt;
&lt;p&gt;用load和require加载的文件在顶级范围中被执行，而不是在load或require被调用的层级中执行。被夹在的文件可以访问那些加载时已定义的所有全局变量和常量，但是实例变量是不能在文件外被访问到。另外self的值永远是主对象，load和require不会把接收者对象传递给所加载的文件。&lt;/p&gt;
&lt;p&gt;load方法在调用时，如果第二个参数值不是nil或false，它会wrap给定的文件到一个匿名模块中，这意味着加载的文件不会影响全局命名空间，它命名的所有常量被放入到这个匿名模块中。这种包裹加载方式作为一种安全措施而存在。&lt;/p&gt;
&lt;p&gt;当一个文件被加载到匿名模块中，它亦然可以设置全局变量，而且这些变量也可被加载的代码所使用。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_autoloading_modules&#34;&gt;autoloading Modules&lt;/h3&gt;&lt;p&gt;Kernel和Module的autoload方法支持按需惰性加载的机制，它允许使用一个未定义的常量和定义了该常量的包名。在这个常量在第一次被引用的时候，那个注册的包就使用require进行加载。&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;auload :TCPSocket, &#34;socket&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用autoload?或Module.autoload?方法可以测试一个常量是否加载一个文件，它们带有一个符号参数。如果这个符号参数加载了一个文件，autoload?方法返回文件名，否则返回nil。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>How Minitest Works Part 2</title>
      <link>https://polarlights.github.io/post/how_minitest_works_part_2/</link>
      <pubDate>Sun, 21 Feb 2016 18:40:42 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/how_minitest_works_part_2/</guid>
      
        <description>&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;注：本文以 minitest 的最新master 分支 &lt;a href=&#34;https://github.com/seattlerb/minitest/tree/baf6010053279f75f561f6a599d8837151327588&#34;&gt;baf6010&lt;/a&gt; ，版本为&lt;code&gt;5.8.4&lt;/code&gt;为基础。 所有代码可以在https://github.com/minitest_source[minitest_source] 找到.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;在上一节我们留下了以下几个问题，本节我们透过对Minitest源码的分析来一探究竟:&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;minitest/autorun&lt;/code&gt; 到底做了什么？&lt;/li&gt;&lt;li&gt;继承&lt;code&gt;Minitest::Test&lt;/code&gt;的目的何在，它内部有什么特殊方法？&lt;/li&gt;&lt;li&gt;为什么以&lt;code&gt;test_&lt;/code&gt; 开头的方法执行了，而普通的方法没有执行？里面肯定有一个&#34;惊天的阴谋&#34;&lt;/li&gt;&lt;li&gt;Minitest 的结果是何时，如何打出来的？&lt;/li&gt;&lt;li&gt;Minitest有哪些钩子，调用顺序几何？&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;我们首先看&lt;code&gt;minitest/autorun&lt;/code&gt;文件，里面只有简单几行：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;begin
  require &#34;rubygems&#34;
  gem &#34;minitest&#34;
rescue Gem::LoadError
  # do nothing
end

require &#34;minitest&#34;
require &#34;minitest/spec&#34;
require &#34;minitest/mock&#34;

Minitest.autorun&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_minitest_autorun&#34;&gt;Minitest.autorun&lt;/h2&gt;&lt;p&gt;它做了什么事情呢？加载 minitest 相关文件，最后调用&lt;code&gt;Minitest.autorun&lt;/code&gt;方法，即Minitest的module方法&lt;code&gt;autorun&lt;/code&gt;。 让我们继续顺藤摸瓜。它在哪里定义的呢？在 &lt;a href=&#34;https://github.com/seattlerb/minitest/blob/baf6010053279f75f561f6a599d8837151327588/lib/minitest.rb#L45&#34;&gt;minitest.rb#L45&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def self.autorun
  at_exit {
    next if $! and not ($!.kind_of? SystemExit and $!.success?)

    exit_code = nil

    at_exit {
      @@after_run.reverse_each(&amp;amp;:call)
      exit exit_code || false
    }

    exit_code = Minitest.run ARGV
  } unless @@installed_at_exit
  @@installed_at_exit = true
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的主要作用是在程序进程结束前注入Minitest，并执行。&lt;/p&gt;
&lt;p&gt;咦，&lt;code&gt;at_exit&lt;/code&gt;是什么鬼？相信很多人很少见到它甚至是在阅读&lt;code&gt;Minitest&lt;/code&gt;源码时第一次见到它。查询Ruby的文档，有下面这样的描述：&lt;/p&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;Converts block to a Proc object (and therefore binds it at the point of call) and registers it for execution when the program exits.
If multiple handlers are registered, they are executed in reverse order of registration.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;它将代码块转为&lt;code&gt;Proc&lt;/code&gt;对象，在程序退出时call这个Proc对象；如果注册了多个&lt;code&gt;at_exit&lt;/code&gt;代码块，它会逆序执行。&lt;/p&gt;
&lt;p&gt;我们写一个测试代码:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;# at_exit.rb
puts &#34;Into program.&#34;

at_exit do
  puts &#34;I&#39;m executed at the end. start...&#34;
  at_exit { puts &#34;I&#39;m executed at last.&#34; }
  puts &#34;I&#39;m executed at the end. end...&#34;
end

at_exit { puts &#34;I&#39;m executed after the &#39;Exit program&#39;.&#34; }

puts &#34;Exit program.&#34;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ruby at_exit.rb
Into program.
Exit program.
I&#39;m executed after the &#39;Exit program&#39;.
I&#39;m executed at the end. start...
I&#39;m executed at the end. end...
I&#39;m executed at last.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上面测试代码的执行结果，我们知道，&lt;code&gt;Minitest.autorun&lt;/code&gt;会先后调用&lt;code&gt;Minitest.run&lt;/code&gt;和Module变量&lt;code&gt;@@after_run&lt;/code&gt;里的Proc对象。&lt;/p&gt;
&lt;p&gt;它们又分别做了什么呢？&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_minitest_run&#34;&gt;Minitest.run&lt;/h2&gt;&lt;p&gt;&lt;code&gt;@@after_run&lt;/code&gt;保存的是在所有test执行结束后执行的代码块, 我们可以调用通知程序将测试完成通知给其他程序 或者发送邮件等等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Minitest.run&lt;/code&gt;加载Minitest的插件；初始化reporter；执行测试，输出结果；最后返回test的执行结果给上面的&lt;code&gt;exit_code&lt;/code&gt;&lt;/p&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_minitest_load_plugins&#34;&gt;Minitest.load_plugins&lt;/h3&gt;&lt;p&gt;Minitest的插件都是以&lt;code&gt;&lt;em&gt;plugin.rb&lt;/code&gt;结尾，放在&lt;code&gt;minitest&lt;/code&gt;目录下。比如在Minitest中就有&lt;code&gt;pride_plugin.rb&lt;/code&gt;，它就是Minitest默认的 插件。每个Minitest的插件都可以有(不是必须有)一个以该插件名命名的初始化方法&lt;code&gt;plugin&lt;/em&gt;[插件名]_init&lt;/code&gt;。 比如&lt;code&gt;pride_plugin.rb&lt;/code&gt;的插件初始化方法为&lt;code&gt;plugin_pride_init&lt;/code&gt;。Minitest的参数是用&lt;code&gt;optparse&lt;/code&gt;解析的，它的插件也有一个支持&lt;code&gt;optparse&lt;/code&gt;的方法: &lt;code&gt;plugin_pride_options&lt;/code&gt;来做一些扩展。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_reporter&#34;&gt;Reporter&lt;/h3&gt;&lt;p&gt;这期间还会初始化CompositeReporter、SummaryReporter和ProgressReporter 3 个reporter，并赋值给Minitest的reporter属性，它用来展示测试的结果；它只在&lt;code&gt;init_plugins&lt;/code&gt;中可用，在初始化完plugin后就被置为空了。所以如果想要在测试结束后调用reporter相关的操作，可以自己编写plugin（后续文章我们会涉及）。&lt;/p&gt;
&lt;p&gt;上面说了3中Reporter。那么这三者有什么区别和联系呢？&lt;/p&gt;
&lt;p&gt;Reporter的继承结构是这样的:&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;AbstractReporter
|__Reporter
|   |__ProgressReporter
|   |__StatisticsReporter
|      |__SummaryReporter
|__CompositeReporter&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有的Reporter都是&lt;code&gt;AbstractReporter&lt;/code&gt;子类，&lt;code&gt;AbstractReporter&lt;/code&gt;定义了作为一个reporter应该有的方法，它们是&lt;code&gt;start&lt;/code&gt;(在启动后开始记录测试结果),&lt;code&gt;record&lt;/code&gt;(输出测试的结果；如果测试没有通过，会记录单个测试的结果),&lt;code&gt;report&lt;/code&gt;(输出测试的概况),&lt;code&gt;passed?&lt;/code&gt;(测试是否通过)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Reporter&lt;/code&gt;默认将标准输出作为默认的输出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ProgressReporter&lt;/code&gt;是一个很简单的reporter，他将测试用&lt;strong&gt;点&lt;/strong&gt;打出.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StatisticsReporter&lt;/code&gt;收集单个测试的统计信息，并没有任何IO相关的操作。如果想定制输出类型（比如CI，HTML等等），可以通过修改这个类的一些方法来做到。该类因为是统计测试结果的，所以它里面包含了测试的数量、assert的数量、开始时间、总时间、失败的测试、报错的测试和跳过的测试数量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SummaryReporter&lt;/code&gt;是&lt;code&gt;StatisticsReporter&lt;/code&gt;的子类，分别在测试开始时和测试结束的时候打印参数信息和标题、概况、失败的细节信息,类似：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;# At the beginning
Run options: --seed 13908

# Running:

# At the end
Finished in 0.003004s, 665.8359 runs/s, 665.8359 assertions/s.

2 runs, 2 assertions, 0 failures, 0 errors, 1 skips

You have skipped tests. Run with --verbose for details.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一句只有test中有&lt;code&gt;skip&lt;/code&gt;的结果才会输出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CompositeReporter&lt;/code&gt;可以调度多个repoter,将调用&lt;code&gt;passed?&lt;/code&gt;、&lt;code&gt;start&lt;/code&gt;、&lt;code&gt;record&lt;/code&gt;、&lt;code&gt;report&lt;/code&gt;的方法代理给所有的reporter。可以认为它是所有reporter的顶级代理类。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_minitest_run_2&#34;&gt;Minitest.__run&lt;/h2&gt;&lt;p&gt;在初始化完reporter和plugin后，开始跑测试。具体执行每个继承了&lt;code&gt;Mintest::Test&lt;/code&gt;/&lt;code&gt;Minitest::Spec&lt;/code&gt;/&lt;code&gt;Minitest::Benchmark&lt;/code&gt;的子类。比如之前距离代码中的&amp;#8217;DogTest&#39;。&lt;/p&gt;
&lt;p&gt;但是我们发现继承了&lt;code&gt;Minitest::Test&lt;/code&gt;的子类只有以&lt;code&gt;test_&lt;/code&gt;开头的方法执行了，魔法在哪里？我们继续往下看。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_runnable&#34;&gt;Runnable&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Runnable&lt;/code&gt;是什么鬼？它表示任何&lt;code&gt;runnable&lt;/code&gt;的父类，任何它的子类都会自动注册到&lt;code&gt;Runnable.runnables&lt;/code&gt;。为甚么它会&lt;strong&gt;自动&lt;/strong&gt;注册呢？因为它有一个Ruby的钩子：&lt;code&gt;inherited&lt;/code&gt;,它会在任何继承了该类的时候调用，让我们来看看它的代码：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def self.inherited klass
  self.runnables &amp;lt;&amp;lt; klass
  super
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Runnable的run方法&lt;/p&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_runnable_run&#34;&gt;runnable.run&lt;/h3&gt;&lt;p&gt;它可以按照用户输入的&lt;code&gt;--name&lt;/code&gt;参数只跑符合对应正则的方法。里面定义了一个&lt;code&gt;runnable_methods&lt;/code&gt;，它里面就会只保留满足子类定义的正则（不是用户输入的）的方法来一个个执行。比如&lt;code&gt;Minitest::Test&lt;/code&gt;是&lt;code&gt;Runnable&lt;/code&gt;的子类，它要求可执行方法是以&lt;code&gt;test_&lt;/code&gt;开头；同样的&lt;code&gt;Minitest::Benchmark&lt;/code&gt;要求方法以&lt;code&gt;bench_&lt;/code&gt;开头.&lt;/p&gt;
&lt;p&gt;保留的测试方法，会逐个执行，调用&lt;code&gt;Minitest.run_one_method klass, method_name, reporter&lt;/code&gt;。 它将调用Runnable的&lt;code&gt;initialize&lt;/code&gt;方法，将&lt;code&gt;method_name&lt;/code&gt;作为参数，作为要调用的方法名。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_runnable_new_run&#34;&gt;runnable.new.run&lt;/h3&gt;&lt;p&gt;以&lt;code&gt;Minitest::Test&lt;/code&gt;为例，执行前它会先后调用&lt;code&gt;before_setup&lt;/code&gt;、&lt;code&gt;setup&lt;/code&gt;、&lt;code&gt;after_setup&lt;/code&gt;几个钩子方法，然后调用上面作为参数传入的&lt;code&gt;method_name&lt;/code&gt;。以实例代码为例，就是调用了&lt;code&gt;DogTest.new.
test_dog_should_spark&lt;/code&gt;，它里面就执行了具体的assert_方法，同样asert的数量就是在此时增加的。方法执行结束后，会调用&lt;code&gt;before_teardown&lt;/code&gt;、&lt;code&gt;teardown&lt;/code&gt;和&lt;code&gt;after_teardown&lt;/code&gt;这几个钩子，你可以做一些你想在测试结束后想做的事情。&lt;/p&gt;
&lt;p&gt;这里衍生出个问题：它是如何判断我是Skip还是报错的？&lt;/p&gt;
&lt;p&gt;如果正常执行，它会根据&lt;code&gt;test_&lt;/code&gt;方法实际的&lt;code&gt;assert_&lt;/code&gt;方法的数量增加asserts属性的值。那么如果报错了呢？比如抛了一个异常，如何保证程序不终止，而是继续执行其他的方法呢？&lt;/p&gt;
&lt;p&gt;答案是&lt;code&gt;rescue&lt;/code&gt;，是的，对代码做保护,详见&lt;code&gt;lib/minitest/test.rb:L204&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;def capture_exceptions # :nodoc:
  yield
rescue *PASSTHROUGH_EXCEPTIONS
  raise
rescue Assertion =&amp;gt; e
  self.failures &amp;lt;&amp;lt; e
rescue Exception =&amp;gt; e
  self.failures &amp;lt;&amp;lt; UnexpectedError.new(e)
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Asesrtion的继承关系如下图:&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;Exception
|__Assertion
   |__Skip
   |__UnexpectedError&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果某个方法是被&lt;code&gt;skip&lt;/code&gt;了，那么它会抛出Skip异常，由Assertion捕获；如果方法执行代码错误，则被Exception捕获，并用UnexceptedError包一下。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_总结&#34;&gt;总结&lt;/h2&gt;&lt;p&gt;通过以上的分析，我们现在可以把整个的调用层级重新整理下：&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;Minitest.autorun
  Minitest.run(args)
    Minitest.__run(reporter, options)
      Runnable.runnables.each
        runnable.run(reporter, options)
          self.runnable_methods.each
            self.run_one_method(self, runnable_method, reporter)
              Minitest.run_one_method(klass, runnable_method)
                klass.new(runnable_method).run&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用我们案例代码，表示为:&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;Minitest.autorun
  Minitest.run(args)
    Minitest.__run(reporter, options)
      Runnable.runnables.each
        DogTest.run(reporter, options)
          [test_dog_should_spark].each
            DogTest.run_one_method(DogTest, test_dog_should_spark, reporter)
              Minitest.run_one_method(DogTest, test_dog_should_spark)
                DogTest.new(test_dog_should_spark).run&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考文献:&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/seattlerb/minitest&#34;&gt;Minitest github repository&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;http://mednoter.com/minitest-part-I-autorun.html&#34;&gt;How minitest works&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;http://chriskottom.com/minitestcookbook&#34;&gt;The Minitest Cookbook&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>How Minitest Works Part 1</title>
      <link>https://polarlights.github.io/post/how_minitest_works_part_1/</link>
      <pubDate>Sun, 21 Feb 2016 03:02:42 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/how_minitest_works_part_1/</guid>
      
        <description>&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;注：本文以 minitest 的最新master 分支 &lt;a href=&#34;https://github.com/seattlerb/minitest/tree/baf6010053279f75f561f6a599d8837151327588&#34;&gt;baf6010&lt;/a&gt; ，版本为&lt;code&gt;5.8.4&lt;/code&gt;为基础。 所有代码可以在https://github.com/minitest_source[minitest_source] 找到.&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_一个简单的测试&#34;&gt;一个简单的测试&lt;/h2&gt;&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;# 代码 1.1
# dog.rb
class Dog
  def spark
    &#39;Spark!&#39;
  end
end

# dog_test.rb
require &#39;minitest/autorun&#39;
require_relative &#39;./dog&#39;

class DogTest &amp;lt; Minitest::Test
  def setup
    @dog = Dog.new
  end

  def test_dog_should_spark
    assert_respond_to @dog, :spark
    assert_equal &#39;Spark!&#39;, @dog.spark
  end

  def ordiary_method
    assert true
  end
end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何执行测试呢？&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ruby dog_test.rb
Run options: --seed 24057

# Running:
.

Finished in 0.001039s, 962.5723 runs/s, 1925.1446 assertions/s.

1 runs, 2 assertions, 0 failures, 0 errors, 0 skips&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果我们把&lt;code&gt;require &#39;minitest/autorun&#39;&lt;/code&gt; 这一行注释掉，然后再执行&lt;code&gt;ruby dog_test.rb&lt;/code&gt;，程序是否还 正常执行呢？让我们执行下：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ ruby dog_test.rb&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这一次什么都没有输出。Why?&lt;/p&gt;
&lt;p&gt;这一行有什么魔法呢？为什么有了它之后，可以执行测试代码，  还可以输出测试结果？&lt;/p&gt;
&lt;p&gt;那我们看一下&lt;code&gt;Minitest&lt;/code&gt; 的代码，就可以了然了。&lt;/p&gt;
&lt;p&gt;如果列位有兴趣，可以继续往下看。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_minitest_的工作原理&#34;&gt;Minitest  的工作原理&lt;/h2&gt;&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_minitest_主要代码的结构&#34;&gt;Minitest 主要代码的结构&lt;/h3&gt;&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;minitest
│   ├── assertions.rb   # 定义 assert_*方法
│   ├── autorun.rb      # 自动执行测试
│   ├── benchmark.rb    # Benchmark 相关方法
│   ├── expectations.rb # 使用`must` 代替`assert`
│   ├── hell.rb         # 并行执行测试
│   ├── mock.rb         # Mock 的 expect 相关实现
│   ├── parallel.rb     # 多线程执行测试
│   ├── pride.rb        # Report 的一种，以颜色展示结果
│   ├── pride_plugin.rb # Pride plugin 的具体实现
│   ├── spec.rb         # spec 实现，本质上是一种语法糖
│   ├── test.rb         # Minitest 具体执行部分
│   └── unit.rb         # test/unit 的 Minitest 实现
└── minitest.rb         # Minitest 的抽象层实现&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Minitest 的代码行数统计数据:&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
Ruby                            13            646           1061           1593
-------------------------------------------------------------------------------
SUM:                            13            646           1061           1593
-------------------------------------------------------------------------------&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;以上是使用http://cloc.sourceforge.net/[cloc] 统计得出。&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;Minitest 用了不到1600行的代码，集扩展性强、兼容性好、可读性强于一身。&lt;/p&gt;
&lt;p&gt;从上面的代码，我们可以得到以下结论：&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;测试文件需要加载&lt;code&gt;minitest/autorun&lt;/code&gt; 文件&lt;/li&gt;&lt;li&gt;测试类要继承自&lt;code&gt;Minitest::Test&lt;/code&gt; 或者其子类&lt;/li&gt;&lt;li&gt;测试方法需要以&lt;code&gt;test_&lt;/code&gt; 开头。(可以看到上面只有2个 assert 执行了，里面其实有3个 assert 语句)&lt;/li&gt;&lt;li&gt;测试结束会输出执行的结果（是否通过、失败、跳过以及执行时间和速度）&lt;/li&gt;&lt;li&gt;Minitest 有钩子的存在(比如setup)&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;那么我们会有以下疑问：&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;minitest/autorun&lt;/code&gt; 到底做了什么？&lt;/li&gt;&lt;li&gt;继承&lt;code&gt;Minitest::Test&lt;/code&gt;的目的何在，它内部有什么特殊方法？&lt;/li&gt;&lt;li&gt;为什么以&lt;code&gt;test_&lt;/code&gt; 开头的方法执行了，而普通的方法没有执行？里面肯定有一个&#34;惊天的阴谋&#34;&lt;/li&gt;&lt;li&gt;Minitest 的结果是何时，如何打出来的？&lt;/li&gt;&lt;li&gt;Minitest有哪些钩子，调用顺序几何？&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;以上问题，我们在下一节讨论。&lt;/p&gt;
&lt;p&gt;参考文献:&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&#34;https://github.com/seattlerb/minitest&#34;&gt;Minitest github repository&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;http://mednoter.com/minitest-part-I-autorun.html&#34;&gt;How minitest works&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&#34;http://chriskottom.com/minitestcookbook&#34;&gt;The Minitest Cookbook&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/section&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>写在前面</title>
      <link>https://polarlights.github.io/post/introduction_to_minitest/introduction_to_minitest/</link>
      <pubDate>Sat, 20 Feb 2016 03:19:33 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/introduction_to_minitest/introduction_to_minitest/</guid>
      
        <description>&lt;p&gt;之前几乎不写测试，嗯，我属于那一类人。很多时候是自己先写一个功能，然后输入一些简单案例跑一跑，如果过了，那么就&amp;#8230;&amp;#8203;&amp;#8230;&amp;#8203;过了，可以&lt;code&gt;放心&lt;/code&gt;继续下面的工作了。直到维护一个个前辈们的项目，而且功能不断添加，添加。问题接着出现了：按下葫芦浮起瓢，改了一个 Bug，引出了其它的 Bug。代码在修改过程中，越来越心里没底。更别说重构了。。。。&lt;/p&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_为什么要写测试&#34;&gt;为什么要写测试？&lt;/h2&gt;&lt;p&gt;现在的 Coder 应该都有这样的共识：写测试总比不写要好。为什么呢？因为它可以给我们带来以下好处：&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;便于整理编码思路&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;我们写代码，实际上使用计算机的语言来解决我们现实中的问题，方便我们的生活和工作。事实上，很不幸，现实比书本上描述地复杂得多。不是每个人都可以很快在头脑里对现实问题迅速抽象出来而且恰到好处的。&lt;/p&gt;
&lt;p&gt;在写具体写代码之前，如果先按接口写测试，可以保证接口的稳定性（设计好接口，也可以方便其它人并行开发），还可以发现设计的一些缺陷（比如设计不合理、复杂度高）。&lt;/p&gt;
&lt;p&gt;思路清晰了，那么我们代码的结构也会清晰。不仅自己看着舒服，别人维护也容易。&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;减少隐藏的 Bug，提高代码质量&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;其实这个本质上是一个覆盖率的问题。如果测试案例覆盖了几乎所有的情况（即使这个做到是有些难度的），在开发时期，很多 Bug 就会被早早地发现了。总比被别人报告 Bug 要好很多。&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;减少重复机械操作&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;在开发一个功能时，如果功能是非常简单的，类似输入abc，输出 ABC 这样大小写转换的操作，写完功能之后，简单测试下还可以。如果某个功能写好后，需要一系列的输入和操作，重复起来，那就是一个灾难。&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;方便重构&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;在看项目中别人写的代码的时候，有时会不自主的叹气：写得什么破代码；在看大牛的代码的时候，会惊叹：写得这么如此巧妙！妙哉！妙哉！不管代码写得如何，很多已经经历过很多次的迭代、重构。好的东西总是建立在巨人的肩膀上的。&lt;/p&gt;
&lt;p&gt;重构时，如果面对的是没有任何测试案例的代码，我们肯定在重构的过程中会战战兢兢，唯恐踩到某个雷，甚至会不知何时给自己埋下一个雷。地雷，有一天会爆的。&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;增加对项目的理解&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;测试需要开发对业务逻辑有相当的理解。代码建立在你对要实现什么的基础上，其次是如何实现。整个数据的流程在伴随着测试案例的增加过程中，对系统的 来龙去脉也会更加熟悉。 所谓专家，不止是技术上的牛，在业务上也是牛。如何成为大牛？千里之行始于足下。&lt;/p&gt;
&lt;div class=&#34;image-block&#34;&gt;&lt;img src=&#34;../throne_game.jpg&#34; alt=&#34;权力的游戏&#34;&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;center&gt;兰尼斯特有债必还&lt;/center&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_写测试是必要的吗&#34;&gt;写测试是必要的吗？&lt;/h2&gt;&lt;p&gt;如果某个项目只有个人开发，这个项目只是个一锤子买卖或者功能十分简单，可以不写测试。现实中的项目很多都是多人合作才能完成的，曾经工作的公司一个完整的开发流程是这样的：&lt;/p&gt;
&lt;div class=&#34;listing-block&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code class=&#34;language-flow&#34; data-lang=&#34;flow&#34;&gt;design=&amp;gt;start: 概要设计/详细设计
deliver=&amp;gt;end: 交付
dev=&amp;gt;operation: 开发
test=&amp;gt;operation: 测试
integrate=&amp;gt;operation: 集成
deploy=&amp;gt;operation： 上线

degign-&amp;gt;dev-&amp;gt;integrate-&amp;gt;test-&amp;gt;deliver-&amp;gt;deploy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果在测试阶段发现问题，需要开发确认，再找集成。如果线上有问题，需要反馈给交付，再由交付找产品经理，再由产品经理 反馈给开发；之后流程再从开发开始走。不仅耗费了大量的时间，也消耗了好多 Money。&lt;/p&gt;
&lt;p&gt;现在越来越多的开源项目在 Github 上被开放出来，如果某个项目没有单元测试的话，几乎没人用他/她的代码。为何？代码不是我写的，万一出了问题，解决 Bug 又是一堆坑。与其填别人的坑，不如自己搞。&lt;/p&gt;
&lt;p&gt;如果你是一个勤奋的人，那么你可以不写任何测试。如果你是或者想成为聪明的懒人，那么写测试吧。 写测试可以在别人问你这次代码靠谱吗？我们可以比较有底气地回答：是的！&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_为什么很多_coder_不写测试&#34;&gt;为什么很多 Coder 不写测试？&lt;/h2&gt;&lt;p&gt;是啊，为什么不写测试呢？ 任务重，时间紧？不想写？我对自己的代码很有信心，完美无 Bug？&lt;/p&gt;
&lt;p&gt;任务重，时间紧：在评估项目开发周期时，把测试时间一并考虑。为了速度，牺牲效率得不偿失。&lt;/p&gt;
&lt;p&gt;不想写：嗯。继续不靠谱下去？&lt;/p&gt;
&lt;p&gt;完美无Bug：是人就会犯错。写测试会让用户更加相信，说这句话不是自负，而是自信。&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_本系列是关于什么的&#34;&gt;本系列是关于什么的&lt;/h2&gt;&lt;p&gt;测试的内容有很多：单元测试、性能测试、集成测试等等。本系列是使用&lt;code&gt;Minitest&lt;/code&gt; 执行测试的 CookBook。 每篇文章着力于某一方面， 一是为了自我总结，二是希望可以给其它人一些帮助。&lt;/p&gt;
&lt;p&gt;初次写，难免有很多不足之处，望不吝指出。&lt;/p&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>The Difference Of XX-like Methods In Ruby</title>
      <link>https://polarlights.github.io/post/what-is-the-difference-in-to_s-to_str_inspect/</link>
      <pubDate>Fri, 23 Oct 2015 21:23:20 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/what-is-the-difference-in-to_s-to_str_inspect/</guid>
      
        <description>&lt;p&gt;今日打开ruby-china发现Hooopo分享的一篇文章，感觉非常好，故记录之。&lt;/p&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_to_s和inspect的区别&#34;&gt;to_s和inspect的区别&lt;/h2&gt;&lt;p&gt;class David   def to_s     &#34;to_s&#34;   end&lt;/p&gt;
&lt;p&gt;def inspect     &#34;inspect&#34;   end end&lt;/p&gt;
&lt;p&gt;david = David.new  #inspect puts david #to_s print david #to_s p david #inspect&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.
puts obj =&amp;gt; puts obj.to_s&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.
p obj =&amp;gt; puts obj.inspect&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_to_s和to_str的区别&#34;&gt;to_s和to_str的区别&lt;/h2&gt;&lt;p&gt;to_s和to_str在大部分时候是相同的，几乎每个对象都有to_s方法，(why?因为所有对象都继承自Object类)，但是不是每个对象都有to_str方法，这个方法只有在对象有string-like的行为时才定义。&lt;/p&gt;
&lt;p&gt;但是并不是所有和字符串相关的方法都会调用to_str：&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;class David
  def to_str
     &#34;to_str&#34;
  end

   def to_s
     &#34;to_s&#34;
   end
end

david = David.new #to_s
&#34;hello, #{david}&#34; #hello,to_s
[&#39;hello&#39;, david].join(&#34; &#34;) #heloo to_str
&#34;hello &#34; + david #hello to_str
File.join(&#34;hello&#34;, david) #hello/to_str&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;根据上面的结果得出：在字符串内插和inspect的时候会调用to_s，而在Array#join,File#join,String#+的时候优先调用to_str&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其它类XX-like的方法还有to_i vs to_int;
to_a vs to_ary&lt;/p&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>当前 App 切换窗口</title>
      <link>https://polarlights.github.io/post/mac-shortcut/</link>
      <pubDate>Tue, 01 Sep 2015 04:00:00 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/mac-shortcut/</guid>
      
        <description>&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;向后切换窗口： Ctrl + Tab；Cmd + Shift + ]
向前切换窗口： Ctrl + Shift + Tab；Cmd + Shift + [&lt;/pre&gt;&lt;/div&gt;
</description>
      
    </item>
    
    <item>
      <title>Ctrl-C, Ctrl-D, Ctrl-Z 的区别</title>
      <link>https://polarlights.github.io/post/linux-fg-bg-jobs/</link>
      <pubDate>Mon, 31 Aug 2015 04:00:00 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/linux-fg-bg-jobs/</guid>
      
        <description>&lt;p&gt;在 Linux 的日常使用中，&lt;code&gt;Ctrl+C&lt;/code&gt; 应该是用的最多的，他的用途是终止当前进程。那么&lt;code&gt;Ctrl+Z&lt;/code&gt; 和&lt;code&gt;Ctrl+D&lt;/code&gt; 又有什么用途么？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ctrl+Z&lt;/code&gt; 表示暂停一个进程，&lt;code&gt;Ctrl+D&lt;/code&gt; 表示文件结束符(EOF)。&lt;/p&gt;
&lt;p&gt;假如我们有一个会长期执行的程序，如果它原来就是在前台运行的话(&lt;code&gt;bundle exec sidekiq&lt;/code&gt;)， 如果使用&lt;code&gt;Ctrl+Z&lt;/code&gt;，会在终端输出&lt;code&gt;susppended bundle exec sidekiq&lt;/code&gt;。当然 Ctrl+D 是不起作用的，因为它的 应用场景不是这样的。被暂停的进程可以使用&lt;code&gt;ps -ef | grep [进程名]&lt;/code&gt;看到。Ctrl+D 更多地 在文件操作上，每个文件都有对应的标志(EOF)表示文件的结束。&lt;/p&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_fgbg_和_jobs&#34;&gt;fg、bg 和 jobs&lt;/h2&gt;&lt;p&gt;&lt;code&gt;fg %[job num]&lt;/code&gt;把一个任务从后台拿到前台来处理.foreground &lt;code&gt;bg %[job num]&lt;/code&gt; 把一个任务从前台拿到后台去执行。background&lt;/p&gt;
&lt;p&gt;那么 &lt;code&gt;job num&lt;/code&gt; 怎么看呢？ 使用&lt;code&gt;jobs -l&lt;/code&gt;, 最左侧的数字即是。比如有一个后台进程job id 为2，那么执行&lt;code&gt;fg %2&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;如何将暂停的进程在后台继续执行呢？执行&lt;code&gt;bg %[job num]&lt;/code&gt; 就可以了。如果有多个的话，使用&lt;code&gt;bg&lt;/code&gt;(没有 job num)。&lt;/p&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>du 的基本含义和参数</title>
      <link>https://polarlights.github.io/post/linux-du/</link>
      <pubDate>Mon, 31 Aug 2015 04:00:00 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/linux-du/</guid>
      
        <description>&lt;section id=&#34;preamble&#34; aria-label=&#34;Preamble&#34;&gt;&lt;p&gt;&lt;code&gt;du&lt;/code&gt; 用来显示文件的磁盘使用情况。&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;-a 根据目录层级显示所有的文件。
-c 显示总的大小
-d [depth] 特定深度的所有文件大小
-h 以 Human 可读的格式输出，自动带 B/KB/MB/GB/TB/PB
-I mask 根据执行的权限忽略(Ignore) 文件和目录。
-gkm 分别按 GB、KB 和 MB 为单位显示文件大小。
-s 只显示每个特定文件的总和`-d 0`等效。&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_举个栗子&#34;&gt;举个栗子&lt;/h2&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;显示总的文件大小&lt;/p&gt;&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;du -s&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;显示2层的文件大小&lt;/p&gt;&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;du -h -d 2&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;显示/var/demo 文件的统计信息&lt;/p&gt;&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;du -ah /var/demo&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_du_和_df_的区别&#34;&gt;du 和 df 的区别&lt;/h2&gt;&lt;p&gt;&lt;code&gt;du&lt;/code&gt; 和&lt;code&gt;df&lt;/code&gt; 只有一个字母之差。du是面向文件的命令，只计算被文件占用的空间。 不计算文件系统metadata 占用的空间。df则是基于文件系统总体来计算，通过文件系统中未分配空间来确定系统中已经分配空间的大小。 df命令可以获取硬盘占用了多少空间，还剩下多少空间，它也可以显示所有文件系统对节点和磁盘块的使用情况。&lt;/p&gt;
&lt;p&gt;df 的参数列表：&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;-a 全部文件系统列表
-h 以 Human 友好的方式显示
-H 和-h 相似，但是大小进制为1000，而不是1024（很多 ISP、磁盘供应商都这么来）
-l 只显示 local 的文件系统
-t 列出文件系统类型(文件、目录，块等), Linux上为 T。&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>Find</title>
      <link>https://polarlights.github.io/post/linux-find/</link>
      <pubDate>Mon, 31 Aug 2015 04:00:00 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/linux-find/</guid>
      
        <description>&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_find的基本用法&#34;&gt;Find的基本用法：&lt;/h2&gt;&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;find [path] -option [-print] [-exec -ok command {} \;]&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;-print&lt;/code&gt;将匹配的文件输出到标准输出。&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;-name   filename             #查找名为filename的文件
-perm                        #按执行权限来查找
-user    username             #按文件属主来查找
-group groupname            #按组来查找
-mtime   -n +n                #按文件更改时间来查找文件，-n指n天以内，+n指n天以前
-atime    -n +n               #按文件访问时间来查GIN: 0px&#34;&amp;gt;

-ctime    -n +n              #按文件创建时间来查找文件，-n指n天以内，+n指n天以前

-nogroup                     #查无有效属组的文件，即文件的属组在/etc/groups中不存在
-nouser                     #查无有效属主的文件，即文件的属主在/etc/passwd中不存
-newer   f1 !f2              找文件，-n指n天以内，+n指n天以前
-ctime    -n +n               #按文件创建时间来查找文件，-n指n天以内，+n指n天以前
-nogroup                     #查无有效属组的文件，即文件的属组在/etc/groups中不存在
-nouser                      #查无有效属主的文件，即文件的属主在/etc/passwd中不存
-newer   f1 !f2               #查更改时间比f1新但比f2旧的文件
-type    b/d/c/p/l/f         #查是块设备、目录、字符设备、管道、符号链接、普通文件
-size      n[c]               #查长度为n块[或n字节]的文件
-depth                       #使查找在进入子目录前先行查找完本目录
-fstype                     #查更改时间比f1新但比f2旧的文件
-type    b/d/c/p/l/f         #查是块设备、目录、字符设备、管道、符号链接、普通文件
-size      n[c]               #查长度为n块[或n字节]的文件
-depth                       #使查找在进入子目录前先行查找完本目录
-fstype                      #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到
-mount                       #查文件时不跨越文件系统mount点
-follow                      #如果遇到符号链接文件，就跟踪链接所指的文件
-cpio                %;      #查位于某一类型文件系统中的文件，这些文件系统类型通常可 在/etc/fstab中找到
-mount                       #查文件时不跨越文件系统mount点
-follow                      #如果遇到符号链接文件，就跟踪链接所指的文件
-cpio                        #对匹配的文件使用cpio命令，将他们备份到磁带设备中
-prune                       #忽略某个目录&#34;&lt;/pre&gt;&lt;/div&gt;
&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_demo&#34;&gt;Demo&lt;/h3&gt;&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;  find   -name april*                     在当前目录下查找以april开始的文件
  find   -name   april*   fprint file        在当前目录下查找以april开始的文件，并把结果输出到file中
  find   -name ap* -o -name may*   查找以ap或may开头的文件
  find   /mnt   -name tom.txt   -ftype vfat   在/mnt下查找名称为tom.txt且文件系统类型为vfat的文件
  find   /mnt   -name t.txt ! -ftype vfat   在/mnt下查找名称为tom.txt且文件系统类型不为vfat的文件
  find   /tmp   -name wa* -type l            在/tmp下查找名为wa开头且类型为符号链接的文件
  find   /home   -mtime   -2                 在/home下查最近两天内改动过的文件
  find /home    -atime -1                  查1天之内被存取过的文件
  find /home -mmin    +60                  在/home下查60分钟前改动过的文件
  find /home   -amin   +30                  查最近30分钟前被存取过的文件
  find /home   -newer   tmp.txt             在/home下查更新时间比tmp.txt近的文件或目录
  find /home   -anewer   tmp.txt            在/home下查存取时间比tmp.txt近的文件或目录
  find   /home   -used   -2                  列出文件或目录被改动过之后，在2日内被存取过的文件或目录
  find   /home   -user cnscn                列出/home目录内属于用户cnscn的文件或目录
  find   /home   -uid   +501                  列出/home目录内用户的识别码大于501的文件或目录
  find   /home   -group   cnscn              列出/home内组为cnscn的文件或目录
  find   /home   -gid 501                   列出/home内组id为501的文件或目录
  find   /home   -nouser                    列出/home内不属于本地用户的文件或目录
  find   /home   -nogroup                   列出/home内不属于本地组的文件或目录
  find   /home    -name tmp.txt    -maxdepth   4   列出/home内的tmp.txt 查时深度最多为3层
  find   /home   -name tmp.txt   -mindepth   3   从第2层开始查
  find   /home   -empty                     查找大小为0的文件或空目录
  find   /home   -size   +512k                查大于512k的文件
  find   /home   -size   -512k               查小于512k的文件
  find   /home   -links   +2                查硬连接数大于2的文件或目录
  find   /home   -perm   0700                查权限为700的文件或目录
  find   /tmp   -name tmp.txt   -exec cat {} \;
  find   /tmp   -name   tmp.txt   -ok   rm {} \;

  find    /   -amin    -10     # 查找在系统中最后10分钟访问的文件
  find    /   -atime   -2        # 查找在系统中最后48小时访问的文件
  find    /   -empty             # 查找在系统中为空的文件或者文件夹
  find    /   -group   cat        # 查找在系统中属于 groupcat的文件
  find    /   -mmin   -5         # 查找在系统中最后5分钟里修改过的文件
  find    /   -mtime   -1       #查找在系统中最后24小时里修改过的文件
  find    /   -nouser           #查找在系统中属于作废用户的文件
  find    /   -user    fred     #查找在系统中属于FRED这个用户的文件&lt;/pre&gt;&lt;/div&gt;&lt;/section&gt;&lt;/section&gt;
</description>
      
    </item>
    
    <item>
      <title>netstat</title>
      <link>https://polarlights.github.io/post/linux-netstat-lsof/</link>
      <pubDate>Mon, 31 Aug 2015 04:00:00 +0800</pubDate>
      
      <guid>https://polarlights.github.io/post/linux-netstat-lsof/</guid>
      
        <description>&lt;p&gt;Netstat 命令用于显示各种网络相关信息，如网络连接，路由表，接口状态 (Interface Statistics)，masquerade 连接，多播成员 (Multicast Memberships) 等等。&lt;/p&gt;
&lt;div class=&#34;literal-block&#34;&gt;&lt;pre&gt;    -a (all)显示所有选项，默认不显示LISTEN相关
    -t (tcp)仅显示tcp相关选项
    -u (udp)仅显示udp相关选项
    -n 拒绝显示别名，能显示数字的全部转化成数字。
    -l 仅列出有在 Listen (监听) 的服務状态

    -p 显示建立相关链接的程序名
    -r 显示路由信息，路由表
    -e 显示扩展信息，例如uid等
    -s 按各个协议进行统计
    -c 每隔一个固定时间，执行该netstat命令。&lt;/pre&gt;&lt;/div&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_举个例子&#34;&gt;举个例子&lt;/h2&gt;&lt;section class=&#34;doc-section level-2&#34;&gt;&lt;h3 id=&#34;_lsof&#34;&gt;lsof&lt;/h3&gt;&lt;p&gt;lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在， 通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。&lt;/p&gt;
&lt;p&gt;不过 lsof 一般是以 Root 权限运行的。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
&lt;section class=&#34;doc-section level-1&#34;&gt;&lt;h2 id=&#34;_举个例子_2&#34;&gt;举个例子&lt;/h2&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;查看某个进程打开文件数量&lt;/p&gt;&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;table-block&#34;&gt;&lt;table class=&#34;frame-all grid-all stretch&#34;&gt;&lt;colgroup&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;ls -l /proc/[pid]/fd&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;wc -l [Linux]&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;table-block&#34;&gt;&lt;table class=&#34;frame-all grid-all stretch&#34;&gt;&lt;colgroup&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;lsof -p [pid]&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;wc -l [Mac]&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查看谁在使用某个文件&lt;/p&gt;&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof /var/demo.txt&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;恢复已删除文件&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;当Linux计算机受到入侵时，常见的情况是日志文件被删除，以掩盖攻击者的踪迹。管理错误也可能导致意外删除重要的文件，比如在清理旧日志时，意外地删除了数据库的活动事务日志。有时可以通过lsof来恢复这些文件。&lt;/p&gt;
&lt;p&gt;当进程打开了某个文件时，只要该进程保持打开该文件，即使将其删除，它依然存在于磁盘中。这意味着，进程并不知道文件已经被删除，它仍然可以向打开该文件时提供给它的文件描述符进行读取和写入。除了该进程之外，这个文件是不可见的，因为已经删除了其相应的目录索引节点。&lt;/p&gt;
&lt;p&gt;在/proc 目录下，其中包含了反映内核和进程树的各种文件。/proc目录挂载的是在内存中所映射的一块区域，所以这些文件和目录并不存在于磁盘中，因此当我们对这些文件进行读取和写入时，实际上是在从内存中获取相关信息。大多数与 lsof 相关的信息都存储于以进程的 PID 命名的目录中，即 /proc/1234 中包含的是 PID 为 1234 的进程的信息。每个进程目录中存在着各种文件，它们可以使得应用程序简单地了解进程的内存空间、文件描述符列表、指向磁盘上的文件的符号链接和其他系统信息。lsof 程序使用该信息和其他关于内核内部状态的信息来产生其输出。所以lsof 可以显示进程的文件描述符和相关的文件名等信息。也就是我们通过访问进程的文件描述符可以找到该文件的相关信息。&lt;/p&gt;
&lt;p&gt;当系统中的某个文件被意外地删除了，只要这个时候系统中还有进程正在访问该文件，那么我们就可以通过lsof从/proc目录下恢复该文件的内容。 假如由于误操作将/var/log/messages文件删除掉了，那么这时要将/var/log/messages文件恢复的方法如下：&lt;/p&gt;
&lt;p&gt;首先使用lsof来查看当前是否有进程打开/var/logmessages文件，如下：&lt;/p&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;table-block&#34;&gt;&lt;table class=&#34;frame-all grid-all stretch&#34;&gt;&lt;colgroup&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;lsof&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;grep /var/log/messages&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;syslogd 1283 root 2w REG 3,3 5381017 1773647 /var/log/messages (deleted)&lt;/p&gt;
&lt;p&gt;从上面的信息可以看到 PID 1283（syslogd）打开文件的文件描述符为 2。同时还可以看到/var/log/messages已经标记被删除了。因此我们可以在 /proc/1283/fd/2 （fd下的每个以数字命名的文件表示进程对应的文件描述符）中查看相应的信息，如下：&lt;/p&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;head -n 10 /proc/1283/fd/2&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;cat /proc/1283/fd/2 &amp;gt; ~/restored_messages&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;显示开启文件abc.txt的进程&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof abc.txt&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;显示22端口现在被什么程序占用&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof -i 22&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;显示abc进程现在正在打开的文件&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof -c abc&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;显示归属gid的进程情况&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof -g gid&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;显示指定目录下被进程开启的文件，不会遍历该目录下的所有子目录&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof +d /usr/local/&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;显示指定目录下被进程开启的文件，会遍历该目录下得所有子目录&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof +D /usr/local/&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;显示使用fd为4的进程&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof -d 4&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;不进行域名解析，缺省会进行，比较慢&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof -n&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;查看进程号为12的进程打开了哪些文件&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof -p 12&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;让lsof重复执行，缺省15s刷新&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;table-block&#34;&gt;&lt;table class=&#34;frame-all grid-all stretch&#34;&gt;&lt;colgroup&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;col style=&#34;width: 50%;&#34;&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;lsof&lt;br&gt;&lt;/td&gt;&lt;td class=&#34;halign-left valign-top&#34;&gt;-r [t]&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;p&gt;-r, lsof会永远执行，直到被中断&lt;/p&gt;
&lt;p&gt;+r, lsof会一直执行，直到没可显示的内容&lt;/p&gt;
&lt;p&gt;Example：&lt;/p&gt;
&lt;p&gt;查看目前ftp连接的情况：lsof -i &lt;a href=&#34;mailto:tcp@test.com&#34;&gt;tcp@test.com&lt;/a&gt;:ftp -r&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;列出打开文件的大小，如果大小为0，则空&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof -s&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;以UID，列出打开的文件&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;
&lt;div class=&#34;quote-block&#34;&gt;&lt;blockquote&gt;&lt;p&gt;lsof -u username&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/section&gt;
</description>
      
    </item>
    
  </channel>
</rss>
